"use strict";(self.webpackChunkrspress_doc_template=self.webpackChunkrspress_doc_template||[]).push([["93935"],{78093:function(e,n,s){s.r(n);var i=s(85893),r=s(50065),l=s(95895);function t(e){let n=Object.assign({h1:"h1",a:"a",p:"p",strong:"strong",em:"em",ul:"ul",li:"li",code:"code",pre:"pre",span:"span"},(0,r.ah)(),e.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.h1,{id:"fake-quantize",children:[(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#fake-quantize",children:"#"}),"Fake Quantize"]}),"\n",(0,i.jsx)(l.Z,{}),"\n",(0,i.jsx)(n.p,{}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.strong,{children:[(0,i.jsx)(n.em,{children:"class"})," horizon_plugin_pytorch.quantization.FakeQuantize (observer: type = <class 'horizon_plugin_pytorch.quantization.observer.MovingAverageMinMaxObserver'>, saturate: bool | None = None, in_place: bool = False, compat_mask: bool = True, channel_len: int = 1, fast_training=True, **observer_kwargs)"]})}),"\n",(0,i.jsx)(n.p,{children:"Simulate the quantize and dequantize operations in training time."}),"\n",(0,i.jsx)(n.p,{children:"The output of this module is given by"}),"\n",(0,i.jsx)(n.p,{children:"fake_quant_x = clamp(floor(x / scale + 0.5), quant_min, quant_max) * scale"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"scale"})," defines the scale factor used for quantization."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"zero_point"})," specifies the quantized value to which 0 in floating\npoint maps to"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"quant_min"})," specifies the minimum allowable quantized value."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"quant_max"})," specifies the maximum allowable quantized value."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"fake_quant_enabled"})," controls the application of fake quantization\non tensors, note that statistics can still be updated."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"observer_enabled"})," controls statistics collection on tensors"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"dtype"})," specifies the quantized dtype that is being emulated with\nfake-quantization, the allowable values is qint8 and qint16. The values\nof quant_min and quant_max should be chosen to be consistent with the\ndtype"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Parameters:"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"observer"})," (",(0,i.jsx)(n.code,{children:"type"}),") \u2013 Module for observing statistics on input\ntensors and calculating scale and zero-point."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"saturate"})," (",(0,i.jsx)(n.code,{children:"Optional"}),"[",(0,i.jsx)(n.code,{children:"bool"}),"]) \u2013 Whether zero out the grad for value out of quanti range."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"in_place"})," (",(0,i.jsx)(n.code,{children:"bool"}),") \u2013 Whether use in place fake quantize."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"compat_mask"})," (",(0,i.jsx)(n.code,{children:"bool"}),") \u2013 Whether pack the bool mask into bitfield\nwhen saturate = True."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"channel_len"})," (",(0,i.jsx)(n.code,{children:"int"}),") \u2013 Size of data at channel dim."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"fast_training"})," \u2013 Whether use fast training mode. If True, computing scale\nand fake quantization will be done in one step."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"observer_kwargs"})," \u2013 Arguments for the observer module"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"observer"})}),"\n",(0,i.jsx)(n.p,{children:"User provided module that collects statistics on the input\ntensor and provides a method to calculate scale and zero-point."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"extra_repr()"})}),"\n",(0,i.jsx)(n.p,{children:"Set the extra representation of the module"}),"\n",(0,i.jsx)(n.p,{children:"To print customized extra information, you should re-implement\nthis method in your own modules. Both single-line and multi-line\nstrings are acceptable."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"forward (x)"})}),"\n",(0,i.jsx)(n.p,{children:"Defines the computation performed at every call."}),"\n",(0,i.jsx)(n.p,{children:"Should be overridden by all subclasses."}),"\n",(0,i.jsxs)(n.p,{children:["NOTE:\nAlthough the recipe for forward pass needs to be defined within\nthis function, one should call the ",(0,i.jsx)(n.code,{children:"Module"})," instance afterwards\ninstead of this since the former takes care of running the\nregistered hooks while the latter silently ignores them."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"set_qparams (scale: Tensor | Sequence | float, zero_point: Tensor | Sequence | int | None = None)"})}),"\n",(0,i.jsx)(n.p,{children:"Set qparams, default symmetric."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"scale"})," ( ",(0,i.jsx)(n.em,{children:"Tensor"})," ",(0,i.jsx)(n.em,{children:"|"}),"  ",(0,i.jsx)(n.em,{children:"Sequence"})," ",(0,i.jsx)(n.em,{children:"|"}),"  ",(0,i.jsx)(n.em,{children:"float"}),")"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"zero_point"})," ( ",(0,i.jsx)(n.em,{children:"Tensor"})," ",(0,i.jsx)(n.em,{children:"|"}),"  ",(0,i.jsx)(n.em,{children:"Sequence"})," ",(0,i.jsx)(n.em,{children:"|"}),"  ",(0,i.jsx)(n.em,{children:"int"})," ",(0,i.jsx)(n.em,{children:"|"}),"  ",(0,i.jsx)(n.em,{children:"None"}),")"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.strong,{children:[(0,i.jsx)(n.em,{children:"classmethod"})," with_args (**kwargs)"]})}),"\n",(0,i.jsx)(n.p,{children:"Wrapper that allows creation of class factories."}),"\n",(0,i.jsx)(n.p,{children:"This can be useful when there is a need to create classes with the same\nconstructor arguments, but different instances. Can be used in conjunction with\n_callable_args"}),"\n",(0,i.jsx)(n.p,{children:"Example:"}),"\n",(0,i.jsx)(n.pre,{className:"code",children:(0,i.jsx)(n.pre,{className:"shiki css-variables has-line-number",style:{backgroundColor:"var(--shiki-color-background)"},tabIndex:"0",children:(0,i.jsxs)(n.code,{className:"language-text",meta:"",children:[(0,i.jsx)(n.span,{className:"line line-number",children:(0,i.jsx)(n.span,{style:{color:"var(--shiki-color-text)"},children:'>>> # xdoctest: +SKIP("Undefined vars")'})}),"\n",(0,i.jsx)(n.span,{className:"line line-number",children:(0,i.jsx)(n.span,{style:{color:"var(--shiki-color-text)"},children:">>> Foo.with_args = classmethod(_with_args)"})}),"\n",(0,i.jsx)(n.span,{className:"line line-number",children:(0,i.jsx)(n.span,{style:{color:"var(--shiki-color-text)"},children:">>> foo_builder = Foo.with_args(a=3, b=4).with_args(answer=42)"})}),"\n",(0,i.jsx)(n.span,{className:"line line-number",children:(0,i.jsx)(n.span,{style:{color:"var(--shiki-color-text)"},children:">>> foo_instance1 = foo_builder()"})}),"\n",(0,i.jsx)(n.span,{className:"line line-number",children:(0,i.jsx)(n.span,{style:{color:"var(--shiki-color-text)"},children:">>> foo_instance2 = foo_builder()"})}),"\n",(0,i.jsx)(n.span,{className:"line line-number",children:(0,i.jsx)(n.span,{style:{color:"var(--shiki-color-text)"},children:">>> id(foo_instance1) == id(foo_instance2)"})}),"\n",(0,i.jsx)(n.span,{className:"line line-number",children:(0,i.jsx)(n.span,{style:{color:"var(--shiki-color-text)"},children:"False"})}),"\n",(0,i.jsx)(n.span,{className:"line",children:(0,i.jsx)(n.span,{style:{color:"var(--shiki-color-text)"}})})]})})})]})}function a(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,r.ah)(),e.components);return n?(0,i.jsx)(n,Object.assign({},e,{children:(0,i.jsx)(t,e)})):t(e)}n.default=a,a.__RSPRESS_PAGE_META={},a.__RSPRESS_PAGE_META["3.0.22%2Fen%2Fguide%2Fplugin%2Fplugin_api_reference%2Ffake_quantize.md"]={toc:[],title:"Fake Quantize",frontmatter:{}}},95895:function(e,n,s){s(39710);var i=s(85893),r=s(67294),l=s(45687);s(20388);let t={"zh-CN":e=>`\u{9884}\u{8BA1}\u{9605}\u{8BFB}\u{65F6}\u{95F4}: ${e.minutes>=1?`${Math.ceil(e.minutes)} \u{5206}\u{949F}`:"\u5C0F\u4E8E 1 \u5206\u949F"}`,"en-US":e=>`Estimated reading time: ${e.minutes>=1?`${Math.ceil(e.minutes)} minutes`:"less than 1 minute"}`};function a(e,n,s){let i=Object.keys(t).includes(n)?n:s;return t[i](e)}n.Z=e=>{let{defaultLocale:n="en-US"}=e,s=(0,l.Vi)().page.readingTimeData,t=(0,l.Jr)(),c=(0,l.e7)(),[o,d]=(0,r.useState)(a(s,t,n));return(0,r.useEffect)(()=>{d(a(s,t,n))},[t,s]),(0,i.jsx)("span",{"data-dark":String(c),className:"rp-reading-time",children:o})}}}]);