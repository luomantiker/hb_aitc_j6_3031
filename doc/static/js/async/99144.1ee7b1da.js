"use strict";(self.webpackChunkrspress_doc_template=self.webpackChunkrspress_doc_template||[]).push([["99144"],{26460:function(r,s,e){e.r(s);var t=e(85893),i=e(50065),x=e(95895);function n(r){return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(x.Z,{}),"\n","\n",(0,t.jsx)("div",{className:"table-container",children:(0,t.jsxs)("table",{className:"scrollable-table",children:[(0,t.jsx)("thead",{children:(0,t.jsxs)("tr",{children:[(0,t.jsx)("th",{children:"ONNX Operator Name"}),(0,t.jsx)("th",{children:"HMCT convert description"}),(0,t.jsx)("th",{children:"PTQ ONNX Operator"}),(0,t.jsx)("th",{children:"Map Description & Graph Fusion Description"}),(0,t.jsx)("th",{children:"HBIR Operator Name"}),(0,t.jsx)("th",{children:"BPU Support Constraints"})]})}),(0,t.jsxs)("tbody",{children:[(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"Abs"}),(0,t.jsx)("td",{rowSpan:"1",children:"The operator is converted into a look-up-table operator"}),(0,t.jsx)("td",{rowSpan:"1",children:"HzLut"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset\u20029",(0,t.jsx)("br",{}),"func.func\u2002@HzLut(...)\u2002{",(0,t.jsx)("br",{}),"\u2002\u2002return\u2002b30.lut(...)",(0,t.jsx)("br",{}),"}"]}),(0,t.jsx)("td",{children:"b30.lut"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"inputs:"}),(0,t.jsx)("br",{}),"Type: int8, int16",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"outputs:"}),(0,t.jsx)("br",{}),"If input is int8, output is int8",(0,t.jsx)("br",{}),"If input is int16, output is int8/int16",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"Acos"}),(0,t.jsx)("td",{rowSpan:"1",children:"The operator is converted into a look-up-table operator"}),(0,t.jsx)("td",{rowSpan:"1",children:"HzLut"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset\u20029",(0,t.jsx)("br",{}),"func.func\u2002@HzLut(...)\u2002{",(0,t.jsx)("br",{}),"\u2002\u2002return\u2002b30.lut(...)",(0,t.jsx)("br",{}),"}"]}),(0,t.jsx)("td",{children:"b30.lut"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"inputs:"}),(0,t.jsx)("br",{}),"Type: int8, int16",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"outputs:"}),(0,t.jsx)("br",{}),"If input is int8, output is int8",(0,t.jsx)("br",{}),"If input is int16, output is int8/int16",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"Acosh"}),(0,t.jsx)("td",{rowSpan:"1",children:"The operator is converted into a look-up-table operator"}),(0,t.jsx)("td",{rowSpan:"1",children:"HzLut"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset\u20029",(0,t.jsx)("br",{}),"func.func\u2002@HzLut(...)\u2002{",(0,t.jsx)("br",{}),"\u2002\u2002return\u2002b30.lut(...)",(0,t.jsx)("br",{}),"}"]}),(0,t.jsx)("td",{children:"b30.lut"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"inputs:"}),(0,t.jsx)("br",{}),"Type: int8, int16",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"outputs:"}),(0,t.jsx)("br",{}),"If input is int8, output is int8",(0,t.jsx)("br",{}),"If input is int16, output is int8/int16",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"Add"}),(0,t.jsx)("td",{rowSpan:"1",children:"None"}),(0,t.jsx)("td",{rowSpan:"1",children:"Add"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset9",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,\u2002adaptor:\u2002NodeAdaptor,\u2002y:\u2002mlir.Type,\u2002lhs:\u2002mlir.Value,\u2002rhs:\u2002mlir.Value",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.add(lhs,\u2002rhs,\u2002output_type=y)"]}),(0,t.jsx)("td",{children:"hbir.add"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"lhs:"}),(0,t.jsx)("br",{}),"Type: int8, int16, int32, if type is int32, this hbir.add op must be fusible to a Conv op",(0,t.jsx)("br",{}),"Shape: [*]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"rhs:"}),(0,t.jsx)("br",{}),"Same as lhs",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as lhs",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"And"}),(0,t.jsx)("td",{rowSpan:"1",children:"None"}),(0,t.jsx)("td",{rowSpan:"1",children:"And"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset9",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,\u2002adaptor:\u2002NodeAdaptor,\u2002y:\u2002mlir.Type,\u2002lhs:\u2002mlir.Value,\u2002rhs:\u2002mlir.Value",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002#\u2002lhs\u2002=\u2002adaptor.operands[0].value.astype(np.int8)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002#\u2002rhs\u2002=\u2002adaptor.operands[1].value.astype(np.int8)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.logical_and(lhs,\u2002rhs,\u2002output_type=y)"]}),(0,t.jsx)("td",{children:"hbir.logical_and"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"lhs:"}),(0,t.jsx)("br",{}),"Type: int8, int16, bool8",(0,t.jsx)("br",{}),"Shape: [*]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"rhs:"}),(0,t.jsx)("br",{}),"Same as lhs",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Type: bool8",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"ArgMin"}),(0,t.jsx)("td",{rowSpan:"1",children:"None"}),(0,t.jsx)("td",{rowSpan:"1",children:"ArgMin"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset9",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,\u2002adaptor:\u2002NodeAdaptor,\u2002y:\u2002mlir.Type,\u2002x:\u2002mlir.Value,\u2002*,\u2002axis=0,\u2002keepdims=1",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.reduce_argmin(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002x,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002dims=[axis],",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002keepDim=bool(keepdims),",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002output_type=y,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002)"]}),(0,t.jsx)("td",{children:"hbir.reduce_argmin"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"input:"}),(0,t.jsx)("br",{}),"Type: int8, int16",(0,t.jsx)("br",{}),"Shape: [*]",(0,t.jsx)("br",{}),"Dim: reduce axis dim size \u2208 [1, 65535]",(0,t.jsx)("br",{}),"Element : reduce Elements size \u2208 [1, 65535]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as input, ReduceArgMax/ReduceArgMin's output can be of type int32 or int64, as long as the size of the reduced axis can be represented using an int16 number",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"Asin"}),(0,t.jsx)("td",{rowSpan:"1",children:"The operator is converted into a look-up-table operator"}),(0,t.jsx)("td",{rowSpan:"1",children:"HzLut"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset\u20029",(0,t.jsx)("br",{}),"func.func\u2002@HzLut(...)\u2002{",(0,t.jsx)("br",{}),"\u2002\u2002return\u2002b30.lut(...)",(0,t.jsx)("br",{}),"}"]}),(0,t.jsx)("td",{children:"b30.lut"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"inputs:"}),(0,t.jsx)("br",{}),"Type: int8, int16",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"outputs:"}),(0,t.jsx)("br",{}),"If input is int8, output is int8",(0,t.jsx)("br",{}),"If input is int16, output is int8/int16",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"Asinh"}),(0,t.jsx)("td",{rowSpan:"1",children:"The operator is converted into a look-up-table operator"}),(0,t.jsx)("td",{rowSpan:"1",children:"HzLut"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset\u20029",(0,t.jsx)("br",{}),"func.func\u2002@HzLut(...)\u2002{",(0,t.jsx)("br",{}),"\u2002\u2002return\u2002b30.lut(...)",(0,t.jsx)("br",{}),"}"]}),(0,t.jsx)("td",{children:"b30.lut"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"inputs:"}),(0,t.jsx)("br",{}),"Type: int8, int16",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"outputs:"}),(0,t.jsx)("br",{}),"If input is int8, output is int8",(0,t.jsx)("br",{}),"If input is int16, output is int8/int16",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"Atan"}),(0,t.jsx)("td",{rowSpan:"1",children:"The operator is converted into a look-up-table operator"}),(0,t.jsx)("td",{rowSpan:"1",children:"HzLut"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset\u20029",(0,t.jsx)("br",{}),"func.func\u2002@HzLut(...)\u2002{",(0,t.jsx)("br",{}),"\u2002\u2002return\u2002b30.lut(...)",(0,t.jsx)("br",{}),"}"]}),(0,t.jsx)("td",{children:"b30.lut"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"inputs:"}),(0,t.jsx)("br",{}),"Type: int8, int16",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"outputs:"}),(0,t.jsx)("br",{}),"If input is int8, output is int8",(0,t.jsx)("br",{}),"If input is int16, output is int8/int16",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"Atanh"}),(0,t.jsx)("td",{rowSpan:"1",children:"The operator is converted into a look-up-table operator"}),(0,t.jsx)("td",{rowSpan:"1",children:"HzLut"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset\u20029",(0,t.jsx)("br",{}),"func.func\u2002@HzLut(...)\u2002{",(0,t.jsx)("br",{}),"\u2002\u2002return\u2002b30.lut(...)",(0,t.jsx)("br",{}),"}"]}),(0,t.jsx)("td",{children:"b30.lut"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"inputs:"}),(0,t.jsx)("br",{}),"Type: int8, int16",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"outputs:"}),(0,t.jsx)("br",{}),"If input is int8, output is int8",(0,t.jsx)("br",{}),"If input is int16, output is int8/int16",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"2",children:"AveragePool"}),(0,t.jsx)("td",{rowSpan:"2",children:"None"}),(0,t.jsx)("td",{rowSpan:"2",children:"AveragePool"}),(0,t.jsxs)("td",{rowSpan:"2",children:["//opset9",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002adaptor:\u2002NodeAdaptor,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002y:\u2002mlir.Type,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002x:\u2002mlir.Value,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002*,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002kernel_shape,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002pads=[0,\u20020],",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002strides=[1],",(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002auto_pad="NOTSET",',(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002ceil_mode=0,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002count_include_pad=0,",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002if\u2002auto_pad\u2002!=\u2002"NOTSET":',(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002raise\u2002ValueError(",(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002"Operator\u2002AveragePool\u2002does\u2002not\u2002support\u2002attribute\u2002auto_pad.\u2002It\u2002is\u2002a\u2002deprecated\u2002attribute.\u2002"',(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002kernel_dim\u2002=\u2002len(kernel_shape)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002if\u2002kernel_dim\u2002<\u20021\u2002or\u2002kernel_dim\u2002>\u20022:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002raise\u2002ValueError(",(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002f"Operator\u2002AveragePool\u2002does\u2002not\u2002support\u2002kernel_dim\u2002{kernel_dim}"',(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002dilations\u2002=\u2002[1]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002if\u2002kernel_dim\u2002==\u20021:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002x\u2002=\u2002hbir.transpose(x,\u2002[0,\u20022,\u20021])",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002elif\u2002kernel_dim\u2002==\u20022:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002x\u2002=\u2002hbir.transpose(x,\u2002[0,\u20022,\u20023,\u20021])",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002if\u2002dilations\u2002==\u2002[1]:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002dilations\u2002=\u2002dilations\u2002*\u2002kernel_dim",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002if\u2002strides\u2002==\u2002[1]:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002strides\u2002=\u2002strides\u2002*\u2002kernel_dim",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002if\u2002pads\u2002==\u2002[0,\u20020]:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002pads\u2002=\u2002pads\u2002*\u2002kernel_dim",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002#\u2002input\u2002trans:\u2002nchw->nhwc",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002#\u2002output\u2002trans:\u2002nhwc->nchw",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002x\u2002=\u2002hbir.avg_pool(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002x,\u2002kernel_shape,\u2002strides,\u2002pads,\u2002dilation=dilations,\u2002ceilMode=bool(ceil_mode)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002)",(0,t.jsx)("br",{}),(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002if\u2002kernel_dim\u2002==\u20021:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002return\u2002hbir.transpose(x,\u2002[0,\u20022,\u20021],\u2002output_type=y)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.transpose(x,\u2002[0,\u20023,\u20021,\u20022],\u2002output_type=y)"]}),(0,t.jsx)("td",{children:"hbir.avg_pool"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"input:"}),(0,t.jsx)("br",{}),"Type: int8, int16",(0,t.jsx)("br",{}),"Shape: [*,H,W,C]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as input",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"kernel:"}),(0,t.jsx)("br",{}),"Shape: [KH,KW]",(0,t.jsx)("br",{}),"Dim: KH, KW \u2208 [1, 256]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"stride:"}),(0,t.jsx)("br",{}),"Shape: [SH,SW]",(0,t.jsx)("br",{}),"Dim: SH, SW \u2208 [1, 256]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"pad:"}),(0,t.jsx)("br",{}),"Shape: [PN,PH,PW,PC]",(0,t.jsx)("br",{}),"PN,PH,PW,PC \u2208 [-3, 256]",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{children:"hbir.transpose"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"input:"}),(0,t.jsx)("br",{}),"No limits",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as input",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"Cast"}),(0,t.jsx)("td",{rowSpan:"1",children:"None"}),(0,t.jsx)("td",{rowSpan:"1",children:"Cast"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset9",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(self,\u2002adaptor:\u2002NodeAdaptor,\u2002y:\u2002mlir.Type,\u2002x:\u2002mlir.Value,\u2002*,\u2002to):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.cast_type(x,\u2002output_type=y)"]}),(0,t.jsx)("td",{children:"hbir.cast_type"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"input:"}),(0,t.jsx)("br",{}),"Type: int8, int16, bool8",(0,t.jsx)("br",{}),"Shape: [*]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as input",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"Ceil"}),(0,t.jsx)("td",{rowSpan:"1",children:"The operator is converted into a look-up-table operator"}),(0,t.jsx)("td",{rowSpan:"1",children:"HzLut"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset\u20029",(0,t.jsx)("br",{}),"func.func\u2002@HzLut(...)\u2002{",(0,t.jsx)("br",{}),"\u2002\u2002return\u2002b30.lut(...)",(0,t.jsx)("br",{}),"}"]}),(0,t.jsx)("td",{children:"b30.lut"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"inputs:"}),(0,t.jsx)("br",{}),"Type: int8, int16",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"outputs:"}),(0,t.jsx)("br",{}),"If input is int8, output is int8",(0,t.jsx)("br",{}),"If input is int16, output is int8/int16",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"Celu"}),(0,t.jsx)("td",{rowSpan:"1",children:"The operator is converted into a look-up-table operator"}),(0,t.jsx)("td",{rowSpan:"1",children:"HzLut"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset\u20029",(0,t.jsx)("br",{}),"func.func\u2002@HzLut(...)\u2002{",(0,t.jsx)("br",{}),"\u2002\u2002return\u2002b30.lut(...)",(0,t.jsx)("br",{}),"}"]}),(0,t.jsx)("td",{children:"b30.lut"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"inputs:"}),(0,t.jsx)("br",{}),"Type: int8, int16",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"outputs:"}),(0,t.jsx)("br",{}),"If input is int8, output is int8",(0,t.jsx)("br",{}),"If input is int16, output is int8/int16",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"Clip"}),(0,t.jsx)("td",{rowSpan:"1",children:"The operator is converted into a look-up-table operator"}),(0,t.jsx)("td",{rowSpan:"1",children:"HzLut"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset\u20029",(0,t.jsx)("br",{}),"func.func\u2002@HzLut(...)\u2002{",(0,t.jsx)("br",{}),"\u2002\u2002return\u2002b30.lut(...)",(0,t.jsx)("br",{}),"}"]}),(0,t.jsx)("td",{children:"b30.lut"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"inputs:"}),(0,t.jsx)("br",{}),"Type: int8, int16",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"outputs:"}),(0,t.jsx)("br",{}),"If input is int8, output is int8",(0,t.jsx)("br",{}),"If input is int16, output is int8/int16",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"Concat"}),(0,t.jsx)("td",{rowSpan:"1",children:"None"}),(0,t.jsx)("td",{rowSpan:"1",children:"Concat"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset9",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(self,\u2002adaptor:\u2002NodeAdaptor,\u2002y:\u2002mlir.Type,\u2002*args,\u2002axis):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.concat(args,\u2002dim=axis,\u2002output_type=y)"]}),(0,t.jsx)("td",{children:"hbir.concat"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"input:"}),(0,t.jsx)("br",{}),"Arg Number: input number \u2208 [1, 1024]",(0,t.jsx)("br",{}),"Dim: all dims < 131072 ",(0,t.jsx)("br",{}),"size < 2G",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as input",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"3",children:"Conv"}),(0,t.jsx)("td",{rowSpan:"3",children:"None"}),(0,t.jsx)("td",{rowSpan:"3",children:"Conv"}),(0,t.jsxs)("td",{rowSpan:"3",children:["//opset9",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002adaptor:\u2002NodeAdaptor,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002y:\u2002mlir.Type,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002x:\u2002mlir.Value,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002w:\u2002mlir.Value,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002b:\u2002Optional[mlir.Value]\u2002=\u2002None,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002*,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002dilations=(1,\u20021),",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002group=1,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002kernel_shape,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002pads=(0,\u20020,\u20020,\u20020),",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002strides=(1,\u20021),",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002kernel_dim\u2002=\u2002len(kernel_shape)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002if\u2002kernel_dim\u2002==\u20022:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002#\u2002input\u2002trans:\u2002nchw->nhwc",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002#\u2002output\u2002trans:\u2002nhwc->nchw",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002x\u2002=\u2002hbir.transpose(x,\u2002[0,\u20022,\u20023,\u20021])",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002w\u2002=\u2002hbir.transpose(w,\u2002[0,\u20022,\u20023,\u20021])",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002x\u2002=\u2002hbir.conv2d(x,\u2002w,\u2002strides,\u2002pads,\u2002dilations,\u2002group,\u2002bias=b)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002return\u2002hbir.transpose(x,\u2002[0,\u20023,\u20021,\u20022],\u2002output_type=y)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002elif\u2002kernel_dim\u2002==\u20023:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002#\u2002input\u2002trans:\u2002ncdhw->ndhwc",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002#\u2002output\u2002trans:\u2002ndhwc->ncdhw",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002x\u2002=\u2002hbir.transpose(x,\u2002[0,\u20022,\u20023,\u20024,\u20021])",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002w\u2002=\u2002hbir.transpose(w,\u2002[0,\u20022,\u20023,\u20024,\u20021])",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002x\u2002=\u2002hbir.conv3d(x,\u2002w,\u2002strides,\u2002pads,\u2002dilations,\u2002group,\u2002bias=b)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002return\u2002hbir.transpose(x,\u2002[0,\u20024,\u20021,\u20022,\u20023],\u2002output_type=y)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002else:",(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002raise\u2002ValueError("Only\u2002Conv2d\u2002and\u2002Conv3d\u2002supported\u2002for\u2002now.")']}),(0,t.jsx)("td",{children:"hbir.conv3d"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"lhs:"}),(0,t.jsx)("br",{}),"Type: int8",(0,t.jsx)("br",{}),"Shape: [*,D,H,W,C]",(0,t.jsx)("br",{}),"Dim: * \u2208 [1, 128]; D,H,W \u2208 [1, 65536]; C \u2208 [1, 4096];",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"rhs:"}),(0,t.jsx)("br",{}),"Type: int8",(0,t.jsx)("br",{}),"Shape: [N,KD,KH,KW,C]",(0,t.jsx)("br",{}),"N \u2208 [1, 65536]; KD,KH,KW \u2208 [1, 9]; Dim: C \u2208 [1, 4096];",(0,t.jsx)("br",{}),"Size: KD \xd7 KH \xd7 KW \xd7 C \u2208 [1, 131072]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"bias:"}),(0,t.jsx)("br",{}),"Type: f32",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as lhs",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"stride:"}),(0,t.jsx)("br",{}),"Shape: [SD,SH,SW]",(0,t.jsx)("br",{}),"Dim: SD,SH,SW must be 1 or 2 and equal to each other.",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"pad:"}),(0,t.jsx)("br",{}),"Shape: [P_front, P_top, P_left, P_back, P_bottom, P_right]",(0,t.jsx)("br",{}),"Dim: P_front,P_back \u2208 [0, KD/2], P_top,P_bottom \u2208 [0, KH/2], P_left,P_right \u2208 [0, KW/2]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"groupNum:"}),(0,t.jsx)("br",{}),"fin.c is divisible by group number",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"dilation:"}),(0,t.jsx)("br",{}),"Shape: [DD,DH,DW]",(0,t.jsx)("br",{}),"DD,DH,DW = 1 when group number more than 1",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{children:"hbir.conv2d"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"input:"}),(0,t.jsx)("br",{}),"Type: int8, int16; input and weight cannot both be int16",(0,t.jsx)("br",{}),"Shape: [*,H,W,C]",(0,t.jsx)("br",{}),"Dim: * \u2208 [1, 4096]; H,W,C \u2208 [1, 65536]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"weight:"}),(0,t.jsx)("br",{}),"Type: int8, int16; input and weight cannot both be int16",(0,t.jsx)("br",{}),"Shape: [N,KH,KW,C]",(0,t.jsx)("br",{}),"Dim: C \u2208 [1, 8192]; KH,KW \u2208 [1, 31]; N \u2208 [1, 65536] if fout is the last layer of conv else [1, 8192]",(0,t.jsx)("br",{}),"Size: KH \xd7 KW \xd7 C \u2208 [1, 65536]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"bias:"}),(0,t.jsx)("br",{}),"Type: f32",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Type: int8, int16, int32",(0,t.jsx)("br",{}),"Other constraints: Same as fin",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"stride:"}),(0,t.jsx)("br",{}),"Shape: [SH,SW]",(0,t.jsx)("br",{}),"Dim: SH,SW \u2208 [1, 256]; SH,SW \u2208 {1} if dilation > 1",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"pad:"}),(0,t.jsx)("br",{}),"Shape: [P_top,P_left,P_bottom,P_right]",(0,t.jsx)("br",{}),"Dim: P_top,P_bottom \u2208 [-H/2, 256], P_left,P_right \u2208 [-W/2, 256]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"groupNum:"}),(0,t.jsx)("br",{}),"fin.c is divisible by group number",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"dilation:"}),(0,t.jsx)("br",{}),"Shape: [DH,DW]",(0,t.jsx)("br",{}),"Dim: DH,DW \u2208 [1, 18]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"others:"}),(0,t.jsx)("br",{}),"Stride only support odd number and 2 when conv is a int16 depthwise conv",(0,t.jsx)("br",{}),"For each group, fin.c \u2208 [1, 8192], KH \xd7 KW \xd7 fin.c \u2208 [1, 65535], fin.c = C when group = 1",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{children:"hbir.transpose"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"input:"}),(0,t.jsx)("br",{}),"No limits",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as input",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"2",children:"ConvTranspose"}),(0,t.jsx)("td",{rowSpan:"2",children:"None"}),(0,t.jsx)("td",{rowSpan:"2",children:"ConvTranspose"}),(0,t.jsxs)("td",{rowSpan:"2",children:["//opset9",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002adaptor:\u2002NodeAdaptor,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002y:\u2002mlir.Type,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002x:\u2002mlir.Value,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002w:\u2002mlir.Value,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002b:\u2002Optional[mlir.Value]\u2002=\u2002None,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002*,",(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002auto_pad="NOTSET",',(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002dilations=(1,\u20021),",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002group=1,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002kernel_shape=None,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002output_padding=None,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002output_shape=None,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002pads=(0,\u20020,\u20020,\u20020),",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002strides=(1,\u20021),",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002auto_pad\u2002=\u2002auto_pad\u2002if\u2002type(auto_pad)\u2002==\u2002str\u2002else\u2002auto_pad.decode()",(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002if\u2002auto_pad\u2002!=\u2002"NOTSET":',(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002raise\u2002ValueError(",(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002f"Operator\u2002ConvTranspose\u2002does\u2002not\u2002support\u2002auto_pad\u2002with\u2002value:\u2002{auto_pad}"',(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002)",(0,t.jsx)("br",{}),(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002if\u2002output_padding\u2002is\u2002not\u2002None:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002for\u2002idx,\u2002p\u2002in\u2002enumerate(output_padding):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002pads[(len(pads)\u2002//\u20022)\u2002+\u2002idx]\u2002-=\u2002p",(0,t.jsx)("br",{}),(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002kernel_dim\u2002=\u2002len(kernel_shape)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002if\u2002kernel_dim\u2002!=\u20022:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002raise\u2002ValueError(",(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002f"Only\u2002support\u2002ConvTranspose\u20022D\u2002Operator,\u2002got\u2002kernel_dim={kernel_dim}"',(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002#\u2002input\u2002trans:\u2002nchw->nhwc",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002#\u2002output\u2002trans:\u2002nhwc->nchw",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002x\u2002=\u2002hbir.transpose(x,\u2002[0,\u20022,\u20023,\u20021])",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002w\u2002=\u2002hbir.transpose(w,\u2002[0,\u20022,\u20023,\u20021])",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002x\u2002=\u2002hbir.conv2dtranspose(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002x,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002weight=w,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002stride=strides,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002pad=pads,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002dilation=dilations,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002groupNum=group,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002bias=b,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002illegalWeight=True,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002x\u2002=\u2002hbir.transpose(x,\u2002[0,\u20023,\u20021,\u20022],\u2002output_type=y)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002x"]}),(0,t.jsx)("td",{children:"hbir.conv2dtranspose"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"input:"}),(0,t.jsx)("br",{}),"Type: int8, int16; input and weight cannot both be int16",(0,t.jsx)("br",{}),"Shape: [*,H,W,C]",(0,t.jsx)("br",{}),"Dim: * \u2208 [1, 128]; H,W \u2208 [1, 65536]; C \u2208 [1, 2048]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"weight:"}),(0,t.jsx)("br",{}),"Type: int8, int16; input and weight cannot both be int16",(0,t.jsx)("br",{}),"Shape: [N,KH,KW,C]",(0,t.jsx)("br",{}),"Dim: N,C \u2208 [1, 2048]; KH,KW \u2208 [1, 14]; KH,KW cannot both be 1",(0,t.jsx)("br",{}),"Size: KH \xd7 KW \xd7 C \u2208 [1, 65536]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"bias:"}),(0,t.jsx)("br",{}),"Type: f32",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as input, the type additionally supports int32",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"stride:"}),(0,t.jsx)("br",{}),"Shape: [SH,SW]",(0,t.jsx)("br",{}),"Dim: SH,SW \u2208 [1, 14]; SH < KH; SW < KW;",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"pad:"}),(0,t.jsx)("br",{}),"Shape: [P_top,P_left,P_bottom,P_right]",(0,t.jsx)("br",{}),"Dim: P_top,P_left,P_bottom,P_right \u2208 [0, 256]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"dilation:"}),(0,t.jsx)("br",{}),"Shape: [DH,DW]",(0,t.jsx)("br",{}),"Dim: DH,DW \u2208 {1}",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{children:"hbir.transpose"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"input:"}),(0,t.jsx)("br",{}),"No limits",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as input",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"Cos"}),(0,t.jsx)("td",{rowSpan:"1",children:"The operator is converted into a look-up-table operator"}),(0,t.jsx)("td",{rowSpan:"1",children:"HzLut"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset\u20029",(0,t.jsx)("br",{}),"func.func\u2002@HzLut(...)\u2002{",(0,t.jsx)("br",{}),"\u2002\u2002return\u2002b30.lut(...)",(0,t.jsx)("br",{}),"}"]}),(0,t.jsx)("td",{children:"b30.lut"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"inputs:"}),(0,t.jsx)("br",{}),"Type: int8, int16",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"outputs:"}),(0,t.jsx)("br",{}),"If input is int8, output is int8",(0,t.jsx)("br",{}),"If input is int16, output is int8/int16",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"Cosh"}),(0,t.jsx)("td",{rowSpan:"1",children:"None"}),(0,t.jsx)("td",{rowSpan:"1",children:"Cosh"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset9",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(self,\u2002adaptor:\u2002NodeAdaptor,\u2002y:\u2002mlir.Type,\u2002x:\u2002mlir.Value):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.cosh(x,\u2002output_type=y)"]}),(0,t.jsx)("td",{children:"hbir.cosh"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"input:"}),(0,t.jsx)("br",{}),"Type: int8, int16",(0,t.jsx)("br",{}),"Shape: [*]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as input",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"CumSum"}),(0,t.jsx)("td",{rowSpan:"1",children:"None"}),(0,t.jsx)("td",{rowSpan:"1",children:"CumSum"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset11",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002adaptor:\u2002NodeAdaptor,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002y:\u2002mlir.Type,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002x:\u2002mlir.Value,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002axis:\u2002mlir.Value,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002*,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002exclusive=0,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002reverse=0,",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002axis\u2002=\u2002adaptor.operands[1].value.tolist()",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.cumsum(x,\u2002axis,\u2002exclusive=exclusive,\u2002reverse=reverse)"]}),(0,t.jsx)("td",{children:"hbir.cumsum"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"input:"}),(0,t.jsx)("br",{}),"Type: int8",(0,t.jsx)("br",{}),"            Shape: [*, dim[axis], *]",(0,t.jsx)("br",{}),"Dim: * \u2208 [1, 65536]; dim[axis] \u2208 [1, 8192]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as input",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"2",children:"Div"}),(0,t.jsx)("td",{rowSpan:"2",children:"The operator is splited"}),(0,t.jsx)("td",{rowSpan:"1",children:"HzLut"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset\u20029",(0,t.jsx)("br",{}),"func.func\u2002@HzLut(...)\u2002{",(0,t.jsx)("br",{}),"\u2002\u2002return\u2002b30.lut(...)",(0,t.jsx)("br",{}),"}"]}),(0,t.jsx)("td",{children:"b30.lut"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"inputs:"}),(0,t.jsx)("br",{}),"Type: int8, int16",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"outputs:"}),(0,t.jsx)("br",{}),"If input is int8, output is int8",(0,t.jsx)("br",{}),"If input is int16, output is int8/int16",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"Mul"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset9",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,\u2002adaptor:\u2002NodeAdaptor,\u2002y:\u2002mlir.Type,\u2002lhs:\u2002mlir.Value,\u2002rhs:\u2002mlir.Value",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.mul(lhs,\u2002rhs,\u2002output_type=y)"]}),(0,t.jsx)("td",{children:"hbir.mul"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"lhs:"}),(0,t.jsx)("br",{}),"Type: int8, int16",(0,t.jsx)("br",{}),"Shape: [*]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"rhs:"}),(0,t.jsx)("br",{}),"Same as lhs",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as lhs",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"Elu"}),(0,t.jsx)("td",{rowSpan:"1",children:"The operator is converted into a look-up-table operator"}),(0,t.jsx)("td",{rowSpan:"1",children:"HzLut"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset\u20029",(0,t.jsx)("br",{}),"func.func\u2002@HzLut(...)\u2002{",(0,t.jsx)("br",{}),"\u2002\u2002return\u2002b30.lut(...)",(0,t.jsx)("br",{}),"}"]}),(0,t.jsx)("td",{children:"b30.lut"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"inputs:"}),(0,t.jsx)("br",{}),"Type: int8, int16",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"outputs:"}),(0,t.jsx)("br",{}),"If input is int8, output is int8",(0,t.jsx)("br",{}),"If input is int16, output is int8/int16",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"Equal"}),(0,t.jsx)("td",{rowSpan:"1",children:"None"}),(0,t.jsx)("td",{rowSpan:"1",children:"Equal"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset9",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,\u2002adaptor:\u2002NodeAdaptor,\u2002y:\u2002mlir.Type,\u2002lhs:\u2002mlir.Value,\u2002rhs:\u2002mlir.Value",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.equal(lhs,\u2002rhs,\u2002output_type=y)"]}),(0,t.jsx)("td",{children:"hbir.equal"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"lhs:"}),(0,t.jsx)("br",{}),"Type: int8, int16, bool8",(0,t.jsx)("br",{}),"Shape: [*]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"rhs:"}),(0,t.jsx)("br",{}),"Same as lhs",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Type: bool8",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"Erf"}),(0,t.jsx)("td",{rowSpan:"1",children:"The operator is converted into a look-up-table operator"}),(0,t.jsx)("td",{rowSpan:"1",children:"HzLut"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset\u20029",(0,t.jsx)("br",{}),"func.func\u2002@HzLut(...)\u2002{",(0,t.jsx)("br",{}),"\u2002\u2002return\u2002b30.lut(...)",(0,t.jsx)("br",{}),"}"]}),(0,t.jsx)("td",{children:"b30.lut"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"inputs:"}),(0,t.jsx)("br",{}),"Type: int8, int16",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"outputs:"}),(0,t.jsx)("br",{}),"If input is int8, output is int8",(0,t.jsx)("br",{}),"If input is int16, output is int8/int16",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"Exp"}),(0,t.jsx)("td",{rowSpan:"1",children:"None"}),(0,t.jsx)("td",{rowSpan:"1",children:"Exp"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset9",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002adaptor:\u2002NodeAdaptor,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002y:\u2002mlir.Type,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002x:\u2002mlir.Value,",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.exp(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002x,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002output_type=y,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002)"]}),(0,t.jsx)("td",{children:"hbir.exp"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"input:"}),(0,t.jsx)("br",{}),"Type: int8, int16",(0,t.jsx)("br",{}),"Shape: [*]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as input",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"2",children:"Expand"}),(0,t.jsx)("td",{rowSpan:"2",children:"None"}),(0,t.jsx)("td",{rowSpan:"2",children:"Expand"}),(0,t.jsxs)("td",{rowSpan:"2",children:["//opset9",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,\u2002adaptor:\u2002NodeAdaptor,\u2002y:\u2002mlir.Type,\u2002data:\u2002mlir.Value,\u2002shape:\u2002mlir.Value",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002original_shape\u2002=\u2002adaptor.operands[0].type.shape",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002new_shape\u2002=\u2002adaptor.operands[1].value",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002original_shape\u2002=\u2002[",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u20021,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002]\u2002*\u2002(len(new_shape)\u2002-\u2002len(original_shape))\u2002+\u2002original_shape",(0,t.jsx)("br",{}),(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002repeat_list\u2002=\u2002[]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002for\u2002i\u2002in\u2002range(len(original_shape)):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002if\u2002(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002original_shape[i]\u2002!=\u2002new_shape[i]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002and\u2002original_shape[i]\u2002!=\u20021",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002and\u2002new_shape[i]\u2002!=\u20021",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002raise\u2002ValueError(",(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002f"Operator\u2002Expand\u2002does\u2002not\u2002support\u2002this\u2002shape.\u2002original_shape:\u2002{original_shape},\u2002new_shape:\u2002{new_shape}"',(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002if\u2002original_shape[i]\u2002==\u20021:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002repeat_list.append(new_shape[i])",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002else:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002repeat_list.append(1)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002data\u2002=\u2002hbir.reshape(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002data,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002original_shape,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002output_type=mlir.UnrankedTensorType.get(mlir.ShapedType(y).element_type),",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.tile(data,\u2002repeat_list,\u2002output_type=y)"]}),(0,t.jsx)("td",{children:"hbir.reshape"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"input:"}),(0,t.jsx)("br",{}),"No limits",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as input",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{children:"hbir.tile"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"input:"}),(0,t.jsx)("br",{}),"No limits",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as input",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"Flatten"}),(0,t.jsx)("td",{rowSpan:"1",children:"The operator is replaced"}),(0,t.jsx)("td",{rowSpan:"1",children:"Reshape"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset9",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,\u2002adaptor:\u2002NodeAdaptor,\u2002y:\u2002mlir.Type,\u2002x:\u2002mlir.Value,\u2002shape:\u2002mlir.Value",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002out_shape\u2002=\u2002adaptor.results[0].type.shape",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.reshape(x,\u2002out_shape)",(0,t.jsx)("br",{}),"//opset18",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002adaptor:\u2002NodeAdaptor,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002y:\u2002mlir.Type,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002x:\u2002mlir.Value,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002shape:\u2002mlir.Value,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002*,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002allowzero=0,",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002input_shape\u2002=\u2002adaptor.operands[0].type.shape",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002out_shape\u2002=\u2002adaptor.results[0].type.shape",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002new_shape\u2002=\u2002np.copy(out_shape)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002if\u2002allowzero\u2002==\u20020:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002zeros_index\u2002=\u2002np.where(out_shape\u2002==\u20020)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002new_shape[zeros_index]\u2002=\u2002np.array(object=input_shape)[zeros_index]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.reshape(x,\u2002shape=new_shape)"]}),(0,t.jsx)("td",{children:"hbir.reshape"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"input:"}),(0,t.jsx)("br",{}),"No limits",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as input",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"Floor"}),(0,t.jsx)("td",{rowSpan:"1",children:"The operator is converted into a look-up-table operator"}),(0,t.jsx)("td",{rowSpan:"1",children:"HzLut"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset\u20029",(0,t.jsx)("br",{}),"func.func\u2002@HzLut(...)\u2002{",(0,t.jsx)("br",{}),"\u2002\u2002return\u2002b30.lut(...)",(0,t.jsx)("br",{}),"}"]}),(0,t.jsx)("td",{children:"b30.lut"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"inputs:"}),(0,t.jsx)("br",{}),"Type: int8, int16",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"outputs:"}),(0,t.jsx)("br",{}),"If input is int8, output is int8",(0,t.jsx)("br",{}),"If input is int16, output is int8/int16",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"10",children:"GRU"}),(0,t.jsx)("td",{rowSpan:"10",children:"The operator is splited"}),(0,t.jsx)("td",{rowSpan:"1",children:"Split"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset9",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,\u2002adaptor:\u2002NodeAdaptor,\u2002y:\u2002mlir.Type,\u2002x:\u2002mlir.Value,\u2002*args,\u2002axis=0,\u2002split",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002ret_list\u2002=\u2002[]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002shape\u2002=\u2002adaptor.operands[0].type.shape",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002dim\u2002=\u2002len(shape)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002axis\u2002=\u2002axis\u2002if\u2002axis\u2002>=\u20020\u2002else\u2002(dim\u2002+\u2002axis)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002asum\u2002=\u20020",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002for\u2002i\u2002in\u2002range(len(split)):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002begin\u2002=\u2002np.array([0\u2002if\u2002i\u2002!=\u2002axis\u2002else\u2002asum\u2002for\u2002i\u2002in\u2002range(dim)])",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002asum\u2002+=\u2002split[i]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002end\u2002=\u2002np.array([shape[i]\u2002if\u2002i\u2002!=\u2002axis\u2002else\u2002asum\u2002for\u2002i\u2002in\u2002range(dim)])",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002step\u2002=\u2002np.ones(shape=dim,\u2002dtype=np.int64)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002output_type\u2002=\u2002y[i]\u2002if\u2002isinstance(y,\u2002list)\u2002else\u2002y",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002ret_list.append(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002hbir.slice(x,\u2002begin=begin,\u2002end=end,\u2002step=step,\u2002output_type=output_type)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002ret_list",(0,t.jsx)("br",{}),"//opset13",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,\u2002adaptor:\u2002NodeAdaptor,\u2002y:\u2002mlir.Type,\u2002x:\u2002mlir.Value,\u2002*args,\u2002axis=0",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002split\u2002=\u2002None",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002if\u2002len(args)\u2002!=\u20020:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002split\u2002=\u2002adaptor.operands[1].value.tolist()",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002#\u2002format:\u2002ele\u2002=\u2002ceil(dim\u2002/\u2002num),\u2002the\u2002last\u2002one\u2002is\u2002dim\u2002-\u2002ele\u2002*\u2002(num\u2002-1)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002#\u2002for\u2002example,\u2002num_outputs\u2002is\u20023,\u2002dim\u2002is\u2002128,\u2002get\u2002split\u2002[43,\u200243,\u200242]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002if\u2002split\u2002is\u2002None:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002split\u2002=\u2002[]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002tmp_shape\u2002=\u2002adaptor.operands[0].type.shape",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002num_outputs\u2002=\u2002len(adaptor.results)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002ele\u2002=\u2002int(math.ceil(tmp_shape[axis]\u2002/\u2002num_outputs))",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002if\u2002tmp_shape[axis]\u2002%\u2002num_outputs\u2002==\u20020:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002split\u2002=\u2002[int(tmp_shape[axis]\u2002/\u2002num_outputs)]\u2002*\u2002num_outputs",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002else:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002split\u2002=\u2002[ele]\u2002*\u2002(num_outputs\u2002-\u20021)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002split.append(tmp_shape[axis]\u2002-\u2002ele\u2002*\u2002(num_outputs\u2002-\u20021))",(0,t.jsx)("br",{}),(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002ret_list\u2002=\u2002[]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002shape\u2002=\u2002adaptor.operands[0].type.shape",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002dim\u2002=\u2002len(shape)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002asum\u2002=\u20020",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002for\u2002i\u2002in\u2002range(len(split)):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002begin\u2002=\u2002np.array([0\u2002if\u2002i\u2002!=\u2002axis\u2002else\u2002asum\u2002for\u2002i\u2002in\u2002range(dim)])",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002asum\u2002+=\u2002split[i]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002end\u2002=\u2002np.array([shape[i]\u2002if\u2002i\u2002!=\u2002axis\u2002else\u2002asum\u2002for\u2002i\u2002in\u2002range(dim)])",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002step\u2002=\u2002np.ones(dim,\u2002dtype=np.int64)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002output_type\u2002=\u2002y[i]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002ret_list.append(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002hbir.slice(x,\u2002begin=begin,\u2002end=end,\u2002step=step,\u2002output_type=output_type)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002ret_list",(0,t.jsx)("br",{}),"//opset18",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002adaptor:\u2002NodeAdaptor,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002y:\u2002mlir.Type,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002x:\u2002mlir.Value,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002*args,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002axis=0,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002num_outputs=0,",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002split\u2002=\u2002None",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002if\u2002len(args)\u2002!=\u20020:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002split\u2002=\u2002adaptor.operands[1].value.tolist()",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002#\u2002format:\u2002ele\u2002=\u2002ceil(dim\u2002/\u2002num),\u2002the\u2002last\u2002one\u2002is\u2002dim\u2002-\u2002ele\u2002*\u2002(num\u2002-1)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002#\u2002for\u2002example,\u2002num_outputs\u2002is\u20023,\u2002dim\u2002is\u2002128,\u2002get\u2002split\u2002[43,\u200243,\u200242]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002if\u2002split\u2002is\u2002None:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002split\u2002=\u2002[]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002tmp_shape\u2002=\u2002adaptor.operands[0].type.shape",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002ele\u2002=\u2002int(math.ceil(tmp_shape[axis]\u2002/\u2002num_outputs))",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002if\u2002tmp_shape[axis]\u2002%\u2002num_outputs\u2002==\u20020:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002split\u2002=\u2002[int(tmp_shape[axis]\u2002/\u2002num_outputs)]\u2002*\u2002num_outputs",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002else:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002split\u2002=\u2002[ele]\u2002*\u2002(num_outputs\u2002-\u20021)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002split.append(tmp_shape[axis]\u2002-\u2002ele\u2002*\u2002(num_outputs\u2002-\u20021))",(0,t.jsx)("br",{}),(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002ret_list\u2002=\u2002[]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002shape\u2002=\u2002adaptor.operands[0].type.shape",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002dim\u2002=\u2002len(shape)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002asum\u2002=\u20020",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002for\u2002i\u2002in\u2002range(len(split)):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002begin\u2002=\u2002np.array([0\u2002if\u2002i\u2002!=\u2002axis\u2002else\u2002asum\u2002for\u2002i\u2002in\u2002range(dim)])",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002asum\u2002+=\u2002split[i]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002end\u2002=\u2002np.array([shape[i]\u2002if\u2002i\u2002!=\u2002axis\u2002else\u2002asum\u2002for\u2002i\u2002in\u2002range(dim)])",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002step\u2002=\u2002np.ones(dim,\u2002dtype=np.int64)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002output_type\u2002=\u2002y[i]\u2002if\u2002isinstance(y,\u2002list)\u2002else\u2002y",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002ret_list.append(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002hbir.slice(x,\u2002begin=begin,\u2002end=end,\u2002step=step,\u2002output_type=output_type)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002ret_list"]}),(0,t.jsx)("td",{children:"hbir.slice"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"input:"}),(0,t.jsx)("br",{}),"Dim: all dims < 2097152 ",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as input",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"Transpose"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset9",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(self,\u2002adaptor:\u2002NodeAdaptor,\u2002y:\u2002mlir.Type,\u2002x:\u2002mlir.Value,\u2002perm):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.transpose(x,\u2002perm,\u2002output_type=y)"]}),(0,t.jsx)("td",{children:"hbir.transpose"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"input:"}),(0,t.jsx)("br",{}),"No limits",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as input",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"2",children:"MatMul"}),(0,t.jsxs)("td",{rowSpan:"2",children:["//opset9",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,\u2002adaptor:\u2002NodeAdaptor,\u2002output_type:\u2002mlir.Type,\u2002a:\u2002mlir.Value,\u2002b:\u2002mlir.Value",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002lhs_shape\u2002=\u2002np.array(adaptor.operands[0].type.shape)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002rhs_shape\u2002=\u2002np.array(adaptor.operands[0].type.shape)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002lhs_rank\u2002=\u2002len(lhs_shape)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002rhs_rank\u2002=\u2002len(rhs_shape)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002if\u2002lhs_rank\u2002==\u20021\u2002and\u2002rhs_rank\u2002==\u20021:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002#\u2002the\u2002output\u2002of\u20021D\u2002matmul\u2002is\u2002a\u2002scalar,\u2002the\u2002out_shape\u2002is\u2002none,\u2002so\u2002add\u2002reshape",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002out_shape\u2002=\u2002adaptor.results[0].type.shape",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002return\u2002hbir.reshape(hbir.matmul(a,\u2002b),\u2002out_shape,\u2002output_type=output_type)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002else:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002return\u2002hbir.matmul(a,\u2002b,\u2002output_type=output_type)"]}),(0,t.jsx)("td",{children:"hbir.reshape"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"input:"}),(0,t.jsx)("br",{}),"No limits",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as input",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{children:"hbir.matmul"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"lhs:"}),(0,t.jsx)("br",{}),"Type: int8, int16; lhs and rhs cannot both be int16",(0,t.jsx)("br",{}),"Shape: [*,M,C]",(0,t.jsx)("br",{}),"Dim: * \u2208 [1, 4096], M,C \u2208 [1, 8192]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"rhs:"}),(0,t.jsx)("br",{}),"Type: int8, int16; lhs and rhs cannot both be int16",(0,t.jsx)("br",{}),"Shape: [*,C,N]",(0,t.jsx)("br",{}),"Dim: * \u2208 [1, 4096]; C,N \u2208 [1, 8192]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Type: int8, int16, int32",(0,t.jsx)("br",{}),"Shape: [*,M,N]",(0,t.jsx)("br",{}),"Other constraints: Same as lhs",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"Mul"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset9",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,\u2002adaptor:\u2002NodeAdaptor,\u2002y:\u2002mlir.Type,\u2002lhs:\u2002mlir.Value,\u2002rhs:\u2002mlir.Value",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.mul(lhs,\u2002rhs,\u2002output_type=y)"]}),(0,t.jsx)("td",{children:"hbir.mul"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"lhs:"}),(0,t.jsx)("br",{}),"Type: int8, int16",(0,t.jsx)("br",{}),"Shape: [*]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"rhs:"}),(0,t.jsx)("br",{}),"Same as lhs",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as lhs",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"HzLut"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset\u20029",(0,t.jsx)("br",{}),"func.func\u2002@HzLut(...)\u2002{",(0,t.jsx)("br",{}),"\u2002\u2002return\u2002b30.lut(...)",(0,t.jsx)("br",{}),"}"]}),(0,t.jsx)("td",{children:"b30.lut"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"inputs:"}),(0,t.jsx)("br",{}),"Type: int8, int16",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"outputs:"}),(0,t.jsx)("br",{}),"If input is int8, output is int8",(0,t.jsx)("br",{}),"If input is int16, output is int8/int16",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"Add"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset9",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,\u2002adaptor:\u2002NodeAdaptor,\u2002y:\u2002mlir.Type,\u2002lhs:\u2002mlir.Value,\u2002rhs:\u2002mlir.Value",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.add(lhs,\u2002rhs,\u2002output_type=y)"]}),(0,t.jsx)("td",{children:"hbir.add"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"lhs:"}),(0,t.jsx)("br",{}),"Type: int8, int16, int32, if type is int32, this hbir.add op must be fusible to a Conv op",(0,t.jsx)("br",{}),"Shape: [*]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"rhs:"}),(0,t.jsx)("br",{}),"Same as lhs",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as lhs",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"Reshape"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset9",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,\u2002adaptor:\u2002NodeAdaptor,\u2002y:\u2002mlir.Type,\u2002x:\u2002mlir.Value,\u2002shape:\u2002mlir.Value",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002out_shape\u2002=\u2002adaptor.results[0].type.shape",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.reshape(x,\u2002out_shape)",(0,t.jsx)("br",{}),"//opset18",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002adaptor:\u2002NodeAdaptor,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002y:\u2002mlir.Type,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002x:\u2002mlir.Value,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002shape:\u2002mlir.Value,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002*,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002allowzero=0,",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002input_shape\u2002=\u2002adaptor.operands[0].type.shape",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002out_shape\u2002=\u2002adaptor.results[0].type.shape",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002new_shape\u2002=\u2002np.copy(out_shape)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002if\u2002allowzero\u2002==\u20020:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002zeros_index\u2002=\u2002np.where(out_shape\u2002==\u20020)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002new_shape[zeros_index]\u2002=\u2002np.array(object=input_shape)[zeros_index]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.reshape(x,\u2002shape=new_shape)"]}),(0,t.jsx)("td",{children:"hbir.reshape"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"input:"}),(0,t.jsx)("br",{}),"No limits",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as input",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"Sub"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset9",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,\u2002adaptor:\u2002NodeAdaptor,\u2002y:\u2002mlir.Type,\u2002lhs:\u2002mlir.Value,\u2002rhs:\u2002mlir.Value",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.sub(lhs,\u2002rhs,\u2002output_type=y)"]}),(0,t.jsx)("td",{children:"hbir.sub"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"lhs:"}),(0,t.jsx)("br",{}),"Type: int8, int16",(0,t.jsx)("br",{}),"Shape: [*]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"rhs:"}),(0,t.jsx)("br",{}),"Same as lhs",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as lhs",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"Concat"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset9",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(self,\u2002adaptor:\u2002NodeAdaptor,\u2002y:\u2002mlir.Type,\u2002*args,\u2002axis):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.concat(args,\u2002dim=axis,\u2002output_type=y)"]}),(0,t.jsx)("td",{children:"hbir.concat"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"input:"}),(0,t.jsx)("br",{}),"Arg Number: input number \u2208 [1, 1024]",(0,t.jsx)("br",{}),"Dim: all dims < 131072 ",(0,t.jsx)("br",{}),"size < 2G",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as input",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"Gather"}),(0,t.jsx)("td",{rowSpan:"1",children:"None"}),(0,t.jsx)("td",{rowSpan:"1",children:"Gather"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset9",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002adaptor:\u2002NodeAdaptor,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002y:\u2002mlir.Type,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002x:\u2002mlir.Value,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002indices:\u2002mlir.Value,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002axis=0,",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.index(x,\u2002index=indices,\u2002dim=axis,\u2002output_type=y)",(0,t.jsx)("br",{}),"//opset11",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002adaptor:\u2002NodeAdaptor,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002y:\u2002mlir.Type,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002x:\u2002mlir.Value,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002indices:\u2002mlir.Value,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002axis=0,",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.index(x,\u2002index=indices,\u2002dim=axis,\u2002output_type=y)",(0,t.jsx)("br",{}),"//opset13",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002adaptor:\u2002NodeAdaptor,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002y:\u2002mlir.Type,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002x:\u2002mlir.Value,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002indices:\u2002mlir.Value,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002axis=0,",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.index(x,\u2002index=indices,\u2002dim=axis,\u2002output_type=y)"]}),(0,t.jsx)("td",{children:"hbir.index"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"input:"}),(0,t.jsx)("br",{}),"Type: int8",(0,t.jsx)("br",{}),"Shape: [*]",(0,t.jsx)("br",{}),"Dim: dims \u2208 [1, 65536]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"index:"}),(0,t.jsx)("br",{}),"Type: int8, int16, int32, int64",(0,t.jsx)("br",{}),"Shape: [*]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as input except Dim constraints",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"Gelu"}),(0,t.jsx)("td",{rowSpan:"1",children:"The operator is converted into a look-up-table operator"}),(0,t.jsx)("td",{rowSpan:"1",children:"HzLut"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset\u20029",(0,t.jsx)("br",{}),"func.func\u2002@HzLut(...)\u2002{",(0,t.jsx)("br",{}),"\u2002\u2002return\u2002b30.lut(...)",(0,t.jsx)("br",{}),"}"]}),(0,t.jsx)("td",{children:"b30.lut"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"inputs:"}),(0,t.jsx)("br",{}),"Type: int8, int16",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"outputs:"}),(0,t.jsx)("br",{}),"If input is int8, output is int8",(0,t.jsx)("br",{}),"If input is int16, output is int8/int16",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"3",children:"Gemm"}),(0,t.jsx)("td",{rowSpan:"3",children:"The operator is replaced"}),(0,t.jsx)("td",{rowSpan:"3",children:"Conv"}),(0,t.jsxs)("td",{rowSpan:"3",children:["//opset9",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002adaptor:\u2002NodeAdaptor,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002y:\u2002mlir.Type,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002x:\u2002mlir.Value,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002w:\u2002mlir.Value,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002b:\u2002Optional[mlir.Value]\u2002=\u2002None,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002*,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002dilations=(1,\u20021),",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002group=1,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002kernel_shape,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002pads=(0,\u20020,\u20020,\u20020),",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002strides=(1,\u20021),",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002kernel_dim\u2002=\u2002len(kernel_shape)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002if\u2002kernel_dim\u2002==\u20022:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002#\u2002input\u2002trans:\u2002nchw->nhwc",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002#\u2002output\u2002trans:\u2002nhwc->nchw",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002x\u2002=\u2002hbir.transpose(x,\u2002[0,\u20022,\u20023,\u20021])",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002w\u2002=\u2002hbir.transpose(w,\u2002[0,\u20022,\u20023,\u20021])",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002x\u2002=\u2002hbir.conv2d(x,\u2002w,\u2002strides,\u2002pads,\u2002dilations,\u2002group,\u2002bias=b)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002return\u2002hbir.transpose(x,\u2002[0,\u20023,\u20021,\u20022],\u2002output_type=y)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002elif\u2002kernel_dim\u2002==\u20023:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002#\u2002input\u2002trans:\u2002ncdhw->ndhwc",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002#\u2002output\u2002trans:\u2002ndhwc->ncdhw",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002x\u2002=\u2002hbir.transpose(x,\u2002[0,\u20022,\u20023,\u20024,\u20021])",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002w\u2002=\u2002hbir.transpose(w,\u2002[0,\u20022,\u20023,\u20024,\u20021])",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002x\u2002=\u2002hbir.conv3d(x,\u2002w,\u2002strides,\u2002pads,\u2002dilations,\u2002group,\u2002bias=b)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002return\u2002hbir.transpose(x,\u2002[0,\u20024,\u20021,\u20022,\u20023],\u2002output_type=y)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002else:",(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002raise\u2002ValueError("Only\u2002Conv2d\u2002and\u2002Conv3d\u2002supported\u2002for\u2002now.")']}),(0,t.jsx)("td",{children:"hbir.conv3d"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"lhs:"}),(0,t.jsx)("br",{}),"Type: int8",(0,t.jsx)("br",{}),"Shape: [*,D,H,W,C]",(0,t.jsx)("br",{}),"Dim: * \u2208 [1, 128]; D,H,W \u2208 [1, 65536]; C \u2208 [1, 4096];",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"rhs:"}),(0,t.jsx)("br",{}),"Type: int8",(0,t.jsx)("br",{}),"Shape: [N,KD,KH,KW,C]",(0,t.jsx)("br",{}),"N \u2208 [1, 65536]; KD,KH,KW \u2208 [1, 9]; Dim: C \u2208 [1, 4096];",(0,t.jsx)("br",{}),"Size: KD \xd7 KH \xd7 KW \xd7 C \u2208 [1, 131072]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"bias:"}),(0,t.jsx)("br",{}),"Type: f32",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as lhs",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"stride:"}),(0,t.jsx)("br",{}),"Shape: [SD,SH,SW]",(0,t.jsx)("br",{}),"Dim: SD,SH,SW must be 1 or 2 and equal to each other.",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"pad:"}),(0,t.jsx)("br",{}),"Shape: [P_front, P_top, P_left, P_back, P_bottom, P_right]",(0,t.jsx)("br",{}),"Dim: P_front,P_back \u2208 [0, KD/2], P_top,P_bottom \u2208 [0, KH/2], P_left,P_right \u2208 [0, KW/2]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"groupNum:"}),(0,t.jsx)("br",{}),"fin.c is divisible by group number",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"dilation:"}),(0,t.jsx)("br",{}),"Shape: [DD,DH,DW]",(0,t.jsx)("br",{}),"DD,DH,DW = 1 when group number more than 1",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{children:"hbir.conv2d"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"input:"}),(0,t.jsx)("br",{}),"Type: int8, int16; input and weight cannot both be int16",(0,t.jsx)("br",{}),"Shape: [*,H,W,C]",(0,t.jsx)("br",{}),"Dim: * \u2208 [1, 4096]; H,W,C \u2208 [1, 65536]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"weight:"}),(0,t.jsx)("br",{}),"Type: int8, int16; input and weight cannot both be int16",(0,t.jsx)("br",{}),"Shape: [N,KH,KW,C]",(0,t.jsx)("br",{}),"Dim: C \u2208 [1, 8192]; KH,KW \u2208 [1, 31]; N \u2208 [1, 65536] if fout is the last layer of conv else [1, 8192]",(0,t.jsx)("br",{}),"Size: KH \xd7 KW \xd7 C \u2208 [1, 65536]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"bias:"}),(0,t.jsx)("br",{}),"Type: f32",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Type: int8, int16, int32",(0,t.jsx)("br",{}),"Other constraints: Same as fin",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"stride:"}),(0,t.jsx)("br",{}),"Shape: [SH,SW]",(0,t.jsx)("br",{}),"Dim: SH,SW \u2208 [1, 256]; SH,SW \u2208 {1} if dilation > 1",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"pad:"}),(0,t.jsx)("br",{}),"Shape: [P_top,P_left,P_bottom,P_right]",(0,t.jsx)("br",{}),"Dim: P_top,P_bottom \u2208 [-H/2, 256], P_left,P_right \u2208 [-W/2, 256]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"groupNum:"}),(0,t.jsx)("br",{}),"fin.c is divisible by group number",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"dilation:"}),(0,t.jsx)("br",{}),"Shape: [DH,DW]",(0,t.jsx)("br",{}),"Dim: DH,DW \u2208 [1, 18]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"others:"}),(0,t.jsx)("br",{}),"Stride only support odd number and 2 when conv is a int16 depthwise conv",(0,t.jsx)("br",{}),"For each group, fin.c \u2208 [1, 8192], KH \xd7 KW \xd7 fin.c \u2208 [1, 65535], fin.c = C when group = 1",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{children:"hbir.transpose"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"input:"}),(0,t.jsx)("br",{}),"No limits",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as input",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"GlobalAveragePool"}),(0,t.jsx)("td",{rowSpan:"1",children:"None"}),(0,t.jsx)("td",{rowSpan:"1",children:"GlobalAveragePool"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset9",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(self,\u2002adaptor:\u2002NodeAdaptor,\u2002y:\u2002mlir.Type,\u2002x:\u2002mlir.Value):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.reduce_mean(x,\u2002dims=[-2,\u2002-1],\u2002keepDim=True,\u2002output_type=y)"]}),(0,t.jsx)("td",{children:"hbir.reduce_mean"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"input:"}),(0,t.jsx)("br",{}),"Type: int8, int16",(0,t.jsx)("br",{}),"Shape: [*]",(0,t.jsx)("br",{}),"Dim: reduce axis dim size \u2208 [1, 65535]",(0,t.jsx)("br",{}),"Element : reduce Elements size \u2208 [1, 65535]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as input, ReduceArgMax/ReduceArgMin's output can be of type int32 or int64, as long as the size of the reduced axis can be represented using an int16 number",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"GlobalMaxPool"}),(0,t.jsx)("td",{rowSpan:"1",children:"None"}),(0,t.jsx)("td",{rowSpan:"1",children:"GlobalMaxPool"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset9",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(self,\u2002adaptor:\u2002NodeAdaptor,\u2002y:\u2002mlir.Type,\u2002x:\u2002mlir.Value):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002#\u2002do\u2002not\u2002use\u2002transpose,\u2002transpose\u2002dims\u2002directly",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002input_shape\u2002=\u2002adaptor.operands[0].type.shape",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002input_rank\u2002=\u2002len(input_shape)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002if\u2002input_rank\u2002<\u20023:",(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002raise\u2002ValueError("input\u2002size\u2002can\u2002not\u2002be\u2002less\u2002than\u20023")',(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002dims\u2002=\u2002[]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002for\u2002i\u2002in\u2002range(input_rank\u2002-\u20022):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002dims.append(-(i\u2002+\u20021))",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.reduce_max(x,\u2002dims=dims,\u2002keepDim=True,\u2002output_type=y)"]}),(0,t.jsx)("td",{children:"hbir.reduce_max"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"input:"}),(0,t.jsx)("br",{}),"Type: int8, int16",(0,t.jsx)("br",{}),"Shape: [*]",(0,t.jsx)("br",{}),"Dim: reduce axis dim size \u2208 [1, 65535]",(0,t.jsx)("br",{}),"Element : reduce Elements size \u2208 [1, 65535]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as input, ReduceArgMax/ReduceArgMin's output can be of type int32 or int64, as long as the size of the reduced axis can be represented using an int16 number",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"Greater"}),(0,t.jsx)("td",{rowSpan:"1",children:"None"}),(0,t.jsx)("td",{rowSpan:"1",children:"Greater"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset9",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,\u2002adaptor:\u2002NodeAdaptor,\u2002y:\u2002mlir.Type,\u2002lhs:\u2002mlir.Value,\u2002rhs:\u2002mlir.Value",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.greater(lhs,\u2002rhs,\u2002output_type=y)"]}),(0,t.jsx)("td",{children:"hbir.greater"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"lhs:"}),(0,t.jsx)("br",{}),"Type: int8, int16",(0,t.jsx)("br",{}),"Shape: [*]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"rhs:"}),(0,t.jsx)("br",{}),"Same as lhs",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Type: bool8",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"GreaterOrEqual"}),(0,t.jsx)("td",{rowSpan:"1",children:"None"}),(0,t.jsx)("td",{rowSpan:"1",children:"GreaterOrEqual"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset12",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,\u2002adaptor:\u2002NodeAdaptor,\u2002y:\u2002mlir.Type,\u2002lhs:\u2002mlir.Value,\u2002rhs:\u2002mlir.Value",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.greater_equal(lhs,\u2002rhs,\u2002output_type=y)"]}),(0,t.jsx)("td",{children:"hbir.greater_equal"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"lhs:"}),(0,t.jsx)("br",{}),"Type: int8, int16",(0,t.jsx)("br",{}),"Shape: [*]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"rhs:"}),(0,t.jsx)("br",{}),"Same as lhs",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Type: bool8",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"2",children:"GridSample"}),(0,t.jsx)("td",{rowSpan:"2",children:"None"}),(0,t.jsx)("td",{rowSpan:"2",children:"GridSample"}),(0,t.jsxs)("td",{rowSpan:"2",children:["//opset16",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002adaptor:\u2002NodeAdaptor,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002y:\u2002mlir.Type,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002x:\u2002mlir.Value,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002Grid:\u2002mlir.Value,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002*,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002align_corners=0,",(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002mode="bilinear",',(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002padding_mode="zeros",',(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002if\u2002isinstance(mode,\u2002bytes):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002mode\u2002=\u2002mode.decode()",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002#\u2002Currently\u2002only\u2002supports\u2002nearest\u2002and\u2002bilinear",(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002if\u2002mode\u2002not\u2002in\u2002["nearest",\u2002"bilinear"]:',(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002raise\u2002ValueError(",(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002f"Operator\u2002GridSample\u2002does\u2002not\u2002support\u2002resize\u2002mode:\u2002{mode}"',(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002padding_mode\u2002=\u2002(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002padding_mode\u2002if\u2002type(padding_mode)\u2002==\u2002str\u2002else\u2002padding_mode.decode()",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002)",(0,t.jsx)("br",{}),(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002x\u2002=\u2002hbir.transpose(x,\u2002[0,\u20022,\u20023,\u20021])",(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002if\u2002padding_mode\u2002==\u2002"zeros":',(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002x\u2002=\u2002hbir.grid_sample(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002x,\u2002Grid,\u2002mode=mode,\u2002alignCorner=bool(align_corners),\u2002padValue=0",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002)",(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002elif\u2002padding_mode\u2002==\u2002"border":',(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002x\u2002=\u2002hbir.grid_sample(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002x,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002Grid,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002mode=mode,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002alignCorner=bool(align_corners),",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002expansionMode=padding_mode,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002else:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002raise\u2002ValueError(",(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002f"Operator\u2002GridSample\u2002does\u2002not\u2002support\u2002padding_mode\u2002{padding_mode}"',(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.transpose(x,\u2002[0,\u20023,\u20021,\u20022],\u2002output_type=y)",(0,t.jsx)("br",{}),"//horizon",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002adaptor:\u2002NodeAdaptor,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002y:\u2002mlir.Type,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002x:\u2002mlir.Value,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002Grid:\u2002mlir.Value,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002*,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002align_corners=0,",(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002mode="bilinear",',(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002padding_mode="zeros",',(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002padding_mode\u2002=\u2002(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002padding_mode\u2002if\u2002type(padding_mode)\u2002==\u2002str\u2002else\u2002padding_mode.decode()",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002)",(0,t.jsx)("br",{}),(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002x\u2002=\u2002hbir.transpose(x,\u2002[0,\u20022,\u20023,\u20021])",(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002if\u2002padding_mode\u2002==\u2002"zeros":',(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002x\u2002=\u2002hbir.grid_sample(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002x,\u2002Grid,\u2002mode=mode,\u2002alignCorner=bool(align_corners),\u2002padValue=0",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002)",(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002elif\u2002padding_mode\u2002==\u2002"border":',(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002x\u2002=\u2002hbir.grid_sample(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002x,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002Grid,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002mode=mode,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002alignCorner=bool(align_corners),",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002expansionMode=padding_mode,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002else:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002raise\u2002ValueError(",(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002f"Operator\u2002GridSample\u2002does\u2002not\u2002support\u2002padding_mode\u2002{padding_mode}"',(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.transpose(x,\u2002[0,\u20023,\u20021,\u20022],\u2002output_type=y)"]}),(0,t.jsx)("td",{children:"hbir.grid_sample"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"input:"}),(0,t.jsx)("br",{}),"Type: int8",(0,t.jsx)("br",{}),"Shape: [*,H,W,C]",(0,t.jsx)("br",{}),"Dim: H,W \u2208 [1, 1024]; H*W \u2264 720*1024; other dims \u2208 [1, 65536]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"grid:"}),(0,t.jsx)("br",{}),"Type: int16",(0,t.jsx)("br",{}),"Shape: [*,H,W,2]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as input except Dim constraints",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{children:"hbir.transpose"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"input:"}),(0,t.jsx)("br",{}),"No limits",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as input",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"7",children:"GroupNormalization"}),(0,t.jsx)("td",{rowSpan:"7",children:"The operator is splited"}),(0,t.jsx)("td",{rowSpan:"1",children:"Reshape"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset9",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,\u2002adaptor:\u2002NodeAdaptor,\u2002y:\u2002mlir.Type,\u2002x:\u2002mlir.Value,\u2002shape:\u2002mlir.Value",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002out_shape\u2002=\u2002adaptor.results[0].type.shape",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.reshape(x,\u2002out_shape)",(0,t.jsx)("br",{}),"//opset18",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002adaptor:\u2002NodeAdaptor,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002y:\u2002mlir.Type,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002x:\u2002mlir.Value,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002shape:\u2002mlir.Value,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002*,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002allowzero=0,",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002input_shape\u2002=\u2002adaptor.operands[0].type.shape",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002out_shape\u2002=\u2002adaptor.results[0].type.shape",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002new_shape\u2002=\u2002np.copy(out_shape)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002if\u2002allowzero\u2002==\u20020:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002zeros_index\u2002=\u2002np.where(out_shape\u2002==\u20020)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002new_shape[zeros_index]\u2002=\u2002np.array(object=input_shape)[zeros_index]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.reshape(x,\u2002shape=new_shape)"]}),(0,t.jsx)("td",{children:"hbir.reshape"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"input:"}),(0,t.jsx)("br",{}),"No limits",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as input",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"2",children:"ReduceMean"}),(0,t.jsxs)("td",{rowSpan:"2",children:["//opset9",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002adaptor:\u2002NodeAdaptor,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002y:\u2002mlir.Type,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002x:\u2002mlir.Value,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002*,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002axes=None,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002keepdims=1,",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002if\u2002axes\u2002is\u2002None:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002axes\u2002=\u2002list(range(mlir.ShapedType(x.type).rank))",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.reduce_mean(x,\u2002dims=axes,\u2002keepDim=bool(keepdims),\u2002output_type=y)",(0,t.jsx)("br",{}),"//opset18",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002adaptor:\u2002NodeAdaptor,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002y:\u2002mlir.Type,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002x:\u2002mlir.Value,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002*args,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002keepdims=1,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002noop_with_empty_axes=0,",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002axes\u2002=\u2002None",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002if\u2002len(args)\u2002!=\u20020:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002axes\u2002=\u2002adaptor.operands[1].value.tolist()",(0,t.jsx)("br",{}),(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002if\u2002axes\u2002is\u2002None:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002axes\u2002=\u2002[]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002if\u2002noop_with_empty_axes\u2002==\u20020:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002#\u2002Reduce\u2002all\u2002axes",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002axes\u2002=\u2002list(range(mlir.ShapedType(x.type).rank))",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002else:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002#\u2002act\u2002like\u2002identity\u2002operands,\u2002here\u2002convert\u2002to\u2002reshape",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002return\u2002hbir.reshape(x,\u2002adaptor.operands[0].type.shape)",(0,t.jsx)("br",{}),(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002self.mlir_op_func(x,\u2002dims=axes,\u2002keepDim=bool(keepdims),\u2002output_type=y)"]}),(0,t.jsx)("td",{children:"hbir.reduce_mean"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"input:"}),(0,t.jsx)("br",{}),"Type: int8, int16",(0,t.jsx)("br",{}),"Shape: [*]",(0,t.jsx)("br",{}),"Dim: reduce axis dim size \u2208 [1, 65535]",(0,t.jsx)("br",{}),"Element : reduce Elements size \u2208 [1, 65535]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as input, ReduceArgMax/ReduceArgMin's output can be of type int32 or int64, as long as the size of the reduced axis can be represented using an int16 number",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{children:"hbir.reshape"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"input:"}),(0,t.jsx)("br",{}),"No limits",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as input",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"Sub"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset9",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,\u2002adaptor:\u2002NodeAdaptor,\u2002y:\u2002mlir.Type,\u2002lhs:\u2002mlir.Value,\u2002rhs:\u2002mlir.Value",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.sub(lhs,\u2002rhs,\u2002output_type=y)"]}),(0,t.jsx)("td",{children:"hbir.sub"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"lhs:"}),(0,t.jsx)("br",{}),"Type: int8, int16",(0,t.jsx)("br",{}),"Shape: [*]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"rhs:"}),(0,t.jsx)("br",{}),"Same as lhs",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as lhs",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"Mul"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset9",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,\u2002adaptor:\u2002NodeAdaptor,\u2002y:\u2002mlir.Type,\u2002lhs:\u2002mlir.Value,\u2002rhs:\u2002mlir.Value",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.mul(lhs,\u2002rhs,\u2002output_type=y)"]}),(0,t.jsx)("td",{children:"hbir.mul"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"lhs:"}),(0,t.jsx)("br",{}),"Type: int8, int16",(0,t.jsx)("br",{}),"Shape: [*]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"rhs:"}),(0,t.jsx)("br",{}),"Same as lhs",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as lhs",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"Add"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset9",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,\u2002adaptor:\u2002NodeAdaptor,\u2002y:\u2002mlir.Type,\u2002lhs:\u2002mlir.Value,\u2002rhs:\u2002mlir.Value",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.add(lhs,\u2002rhs,\u2002output_type=y)"]}),(0,t.jsx)("td",{children:"hbir.add"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"lhs:"}),(0,t.jsx)("br",{}),"Type: int8, int16, int32, if type is int32, this hbir.add op must be fusible to a Conv op",(0,t.jsx)("br",{}),"Shape: [*]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"rhs:"}),(0,t.jsx)("br",{}),"Same as lhs",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as lhs",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"HzLut"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset\u20029",(0,t.jsx)("br",{}),"func.func\u2002@HzLut(...)\u2002{",(0,t.jsx)("br",{}),"\u2002\u2002return\u2002b30.lut(...)",(0,t.jsx)("br",{}),"}"]}),(0,t.jsx)("td",{children:"b30.lut"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"inputs:"}),(0,t.jsx)("br",{}),"Type: int8, int16",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"outputs:"}),(0,t.jsx)("br",{}),"If input is int8, output is int8",(0,t.jsx)("br",{}),"If input is int16, output is int8/int16",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"HardSigmoid"}),(0,t.jsx)("td",{rowSpan:"1",children:"The operator is converted into a look-up-table operator"}),(0,t.jsx)("td",{rowSpan:"1",children:"HzLut"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset\u20029",(0,t.jsx)("br",{}),"func.func\u2002@HzLut(...)\u2002{",(0,t.jsx)("br",{}),"\u2002\u2002return\u2002b30.lut(...)",(0,t.jsx)("br",{}),"}"]}),(0,t.jsx)("td",{children:"b30.lut"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"inputs:"}),(0,t.jsx)("br",{}),"Type: int8, int16",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"outputs:"}),(0,t.jsx)("br",{}),"If input is int8, output is int8",(0,t.jsx)("br",{}),"If input is int16, output is int8/int16",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"HardSwish"}),(0,t.jsx)("td",{rowSpan:"1",children:"The operator is converted into a look-up-table operator"}),(0,t.jsx)("td",{rowSpan:"1",children:"HzLut"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset\u20029",(0,t.jsx)("br",{}),"func.func\u2002@HzLut(...)\u2002{",(0,t.jsx)("br",{}),"\u2002\u2002return\u2002b30.lut(...)",(0,t.jsx)("br",{}),"}"]}),(0,t.jsx)("td",{children:"b30.lut"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"inputs:"}),(0,t.jsx)("br",{}),"Type: int8, int16",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"outputs:"}),(0,t.jsx)("br",{}),"If input is int8, output is int8",(0,t.jsx)("br",{}),"If input is int16, output is int8/int16",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"6",children:"InstanceNormalization"}),(0,t.jsx)("td",{rowSpan:"6",children:"The operator is splited"}),(0,t.jsx)("td",{rowSpan:"2",children:"ReduceMean"}),(0,t.jsxs)("td",{rowSpan:"2",children:["//opset9",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002adaptor:\u2002NodeAdaptor,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002y:\u2002mlir.Type,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002x:\u2002mlir.Value,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002*,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002axes=None,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002keepdims=1,",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002if\u2002axes\u2002is\u2002None:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002axes\u2002=\u2002list(range(mlir.ShapedType(x.type).rank))",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.reduce_mean(x,\u2002dims=axes,\u2002keepDim=bool(keepdims),\u2002output_type=y)",(0,t.jsx)("br",{}),"//opset18",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002adaptor:\u2002NodeAdaptor,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002y:\u2002mlir.Type,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002x:\u2002mlir.Value,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002*args,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002keepdims=1,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002noop_with_empty_axes=0,",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002axes\u2002=\u2002None",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002if\u2002len(args)\u2002!=\u20020:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002axes\u2002=\u2002adaptor.operands[1].value.tolist()",(0,t.jsx)("br",{}),(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002if\u2002axes\u2002is\u2002None:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002axes\u2002=\u2002[]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002if\u2002noop_with_empty_axes\u2002==\u20020:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002#\u2002Reduce\u2002all\u2002axes",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002axes\u2002=\u2002list(range(mlir.ShapedType(x.type).rank))",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002else:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002#\u2002act\u2002like\u2002identity\u2002operands,\u2002here\u2002convert\u2002to\u2002reshape",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002return\u2002hbir.reshape(x,\u2002adaptor.operands[0].type.shape)",(0,t.jsx)("br",{}),(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002self.mlir_op_func(x,\u2002dims=axes,\u2002keepDim=bool(keepdims),\u2002output_type=y)"]}),(0,t.jsx)("td",{children:"hbir.reduce_mean"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"input:"}),(0,t.jsx)("br",{}),"Type: int8, int16",(0,t.jsx)("br",{}),"Shape: [*]",(0,t.jsx)("br",{}),"Dim: reduce axis dim size \u2208 [1, 65535]",(0,t.jsx)("br",{}),"Element : reduce Elements size \u2208 [1, 65535]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as input, ReduceArgMax/ReduceArgMin's output can be of type int32 or int64, as long as the size of the reduced axis can be represented using an int16 number",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{children:"hbir.reshape"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"input:"}),(0,t.jsx)("br",{}),"No limits",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as input",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"Sub"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset9",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,\u2002adaptor:\u2002NodeAdaptor,\u2002y:\u2002mlir.Type,\u2002lhs:\u2002mlir.Value,\u2002rhs:\u2002mlir.Value",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.sub(lhs,\u2002rhs,\u2002output_type=y)"]}),(0,t.jsx)("td",{children:"hbir.sub"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"lhs:"}),(0,t.jsx)("br",{}),"Type: int8, int16",(0,t.jsx)("br",{}),"Shape: [*]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"rhs:"}),(0,t.jsx)("br",{}),"Same as lhs",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as lhs",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"Mul"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset9",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,\u2002adaptor:\u2002NodeAdaptor,\u2002y:\u2002mlir.Type,\u2002lhs:\u2002mlir.Value,\u2002rhs:\u2002mlir.Value",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.mul(lhs,\u2002rhs,\u2002output_type=y)"]}),(0,t.jsx)("td",{children:"hbir.mul"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"lhs:"}),(0,t.jsx)("br",{}),"Type: int8, int16",(0,t.jsx)("br",{}),"Shape: [*]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"rhs:"}),(0,t.jsx)("br",{}),"Same as lhs",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as lhs",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"Add"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset9",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,\u2002adaptor:\u2002NodeAdaptor,\u2002y:\u2002mlir.Type,\u2002lhs:\u2002mlir.Value,\u2002rhs:\u2002mlir.Value",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.add(lhs,\u2002rhs,\u2002output_type=y)"]}),(0,t.jsx)("td",{children:"hbir.add"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"lhs:"}),(0,t.jsx)("br",{}),"Type: int8, int16, int32, if type is int32, this hbir.add op must be fusible to a Conv op",(0,t.jsx)("br",{}),"Shape: [*]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"rhs:"}),(0,t.jsx)("br",{}),"Same as lhs",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as lhs",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"HzLut"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset\u20029",(0,t.jsx)("br",{}),"func.func\u2002@HzLut(...)\u2002{",(0,t.jsx)("br",{}),"\u2002\u2002return\u2002b30.lut(...)",(0,t.jsx)("br",{}),"}"]}),(0,t.jsx)("td",{children:"b30.lut"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"inputs:"}),(0,t.jsx)("br",{}),"Type: int8, int16",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"outputs:"}),(0,t.jsx)("br",{}),"If input is int8, output is int8",(0,t.jsx)("br",{}),"If input is int16, output is int8/int16",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"9",children:"LSTM"}),(0,t.jsx)("td",{rowSpan:"9",children:"The operator is splited"}),(0,t.jsx)("td",{rowSpan:"1",children:"HzLut"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset\u20029",(0,t.jsx)("br",{}),"func.func\u2002@HzLut(...)\u2002{",(0,t.jsx)("br",{}),"\u2002\u2002return\u2002b30.lut(...)",(0,t.jsx)("br",{}),"}"]}),(0,t.jsx)("td",{children:"b30.lut"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"inputs:"}),(0,t.jsx)("br",{}),"Type: int8, int16",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"outputs:"}),(0,t.jsx)("br",{}),"If input is int8, output is int8",(0,t.jsx)("br",{}),"If input is int16, output is int8/int16",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"Split"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset9",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,\u2002adaptor:\u2002NodeAdaptor,\u2002y:\u2002mlir.Type,\u2002x:\u2002mlir.Value,\u2002*args,\u2002axis=0,\u2002split",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002ret_list\u2002=\u2002[]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002shape\u2002=\u2002adaptor.operands[0].type.shape",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002dim\u2002=\u2002len(shape)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002axis\u2002=\u2002axis\u2002if\u2002axis\u2002>=\u20020\u2002else\u2002(dim\u2002+\u2002axis)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002asum\u2002=\u20020",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002for\u2002i\u2002in\u2002range(len(split)):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002begin\u2002=\u2002np.array([0\u2002if\u2002i\u2002!=\u2002axis\u2002else\u2002asum\u2002for\u2002i\u2002in\u2002range(dim)])",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002asum\u2002+=\u2002split[i]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002end\u2002=\u2002np.array([shape[i]\u2002if\u2002i\u2002!=\u2002axis\u2002else\u2002asum\u2002for\u2002i\u2002in\u2002range(dim)])",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002step\u2002=\u2002np.ones(shape=dim,\u2002dtype=np.int64)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002output_type\u2002=\u2002y[i]\u2002if\u2002isinstance(y,\u2002list)\u2002else\u2002y",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002ret_list.append(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002hbir.slice(x,\u2002begin=begin,\u2002end=end,\u2002step=step,\u2002output_type=output_type)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002ret_list",(0,t.jsx)("br",{}),"//opset13",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,\u2002adaptor:\u2002NodeAdaptor,\u2002y:\u2002mlir.Type,\u2002x:\u2002mlir.Value,\u2002*args,\u2002axis=0",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002split\u2002=\u2002None",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002if\u2002len(args)\u2002!=\u20020:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002split\u2002=\u2002adaptor.operands[1].value.tolist()",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002#\u2002format:\u2002ele\u2002=\u2002ceil(dim\u2002/\u2002num),\u2002the\u2002last\u2002one\u2002is\u2002dim\u2002-\u2002ele\u2002*\u2002(num\u2002-1)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002#\u2002for\u2002example,\u2002num_outputs\u2002is\u20023,\u2002dim\u2002is\u2002128,\u2002get\u2002split\u2002[43,\u200243,\u200242]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002if\u2002split\u2002is\u2002None:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002split\u2002=\u2002[]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002tmp_shape\u2002=\u2002adaptor.operands[0].type.shape",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002num_outputs\u2002=\u2002len(adaptor.results)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002ele\u2002=\u2002int(math.ceil(tmp_shape[axis]\u2002/\u2002num_outputs))",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002if\u2002tmp_shape[axis]\u2002%\u2002num_outputs\u2002==\u20020:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002split\u2002=\u2002[int(tmp_shape[axis]\u2002/\u2002num_outputs)]\u2002*\u2002num_outputs",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002else:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002split\u2002=\u2002[ele]\u2002*\u2002(num_outputs\u2002-\u20021)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002split.append(tmp_shape[axis]\u2002-\u2002ele\u2002*\u2002(num_outputs\u2002-\u20021))",(0,t.jsx)("br",{}),(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002ret_list\u2002=\u2002[]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002shape\u2002=\u2002adaptor.operands[0].type.shape",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002dim\u2002=\u2002len(shape)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002asum\u2002=\u20020",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002for\u2002i\u2002in\u2002range(len(split)):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002begin\u2002=\u2002np.array([0\u2002if\u2002i\u2002!=\u2002axis\u2002else\u2002asum\u2002for\u2002i\u2002in\u2002range(dim)])",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002asum\u2002+=\u2002split[i]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002end\u2002=\u2002np.array([shape[i]\u2002if\u2002i\u2002!=\u2002axis\u2002else\u2002asum\u2002for\u2002i\u2002in\u2002range(dim)])",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002step\u2002=\u2002np.ones(dim,\u2002dtype=np.int64)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002output_type\u2002=\u2002y[i]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002ret_list.append(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002hbir.slice(x,\u2002begin=begin,\u2002end=end,\u2002step=step,\u2002output_type=output_type)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002ret_list",(0,t.jsx)("br",{}),"//opset18",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002adaptor:\u2002NodeAdaptor,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002y:\u2002mlir.Type,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002x:\u2002mlir.Value,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002*args,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002axis=0,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002num_outputs=0,",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002split\u2002=\u2002None",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002if\u2002len(args)\u2002!=\u20020:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002split\u2002=\u2002adaptor.operands[1].value.tolist()",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002#\u2002format:\u2002ele\u2002=\u2002ceil(dim\u2002/\u2002num),\u2002the\u2002last\u2002one\u2002is\u2002dim\u2002-\u2002ele\u2002*\u2002(num\u2002-1)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002#\u2002for\u2002example,\u2002num_outputs\u2002is\u20023,\u2002dim\u2002is\u2002128,\u2002get\u2002split\u2002[43,\u200243,\u200242]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002if\u2002split\u2002is\u2002None:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002split\u2002=\u2002[]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002tmp_shape\u2002=\u2002adaptor.operands[0].type.shape",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002ele\u2002=\u2002int(math.ceil(tmp_shape[axis]\u2002/\u2002num_outputs))",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002if\u2002tmp_shape[axis]\u2002%\u2002num_outputs\u2002==\u20020:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002split\u2002=\u2002[int(tmp_shape[axis]\u2002/\u2002num_outputs)]\u2002*\u2002num_outputs",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002else:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002split\u2002=\u2002[ele]\u2002*\u2002(num_outputs\u2002-\u20021)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002split.append(tmp_shape[axis]\u2002-\u2002ele\u2002*\u2002(num_outputs\u2002-\u20021))",(0,t.jsx)("br",{}),(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002ret_list\u2002=\u2002[]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002shape\u2002=\u2002adaptor.operands[0].type.shape",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002dim\u2002=\u2002len(shape)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002asum\u2002=\u20020",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002for\u2002i\u2002in\u2002range(len(split)):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002begin\u2002=\u2002np.array([0\u2002if\u2002i\u2002!=\u2002axis\u2002else\u2002asum\u2002for\u2002i\u2002in\u2002range(dim)])",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002asum\u2002+=\u2002split[i]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002end\u2002=\u2002np.array([shape[i]\u2002if\u2002i\u2002!=\u2002axis\u2002else\u2002asum\u2002for\u2002i\u2002in\u2002range(dim)])",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002step\u2002=\u2002np.ones(dim,\u2002dtype=np.int64)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002output_type\u2002=\u2002y[i]\u2002if\u2002isinstance(y,\u2002list)\u2002else\u2002y",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002ret_list.append(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002hbir.slice(x,\u2002begin=begin,\u2002end=end,\u2002step=step,\u2002output_type=output_type)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002ret_list"]}),(0,t.jsx)("td",{children:"hbir.slice"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"input:"}),(0,t.jsx)("br",{}),"Dim: all dims < 2097152 ",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as input",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"Mul"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset9",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,\u2002adaptor:\u2002NodeAdaptor,\u2002y:\u2002mlir.Type,\u2002lhs:\u2002mlir.Value,\u2002rhs:\u2002mlir.Value",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.mul(lhs,\u2002rhs,\u2002output_type=y)"]}),(0,t.jsx)("td",{children:"hbir.mul"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"lhs:"}),(0,t.jsx)("br",{}),"Type: int8, int16",(0,t.jsx)("br",{}),"Shape: [*]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"rhs:"}),(0,t.jsx)("br",{}),"Same as lhs",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as lhs",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"Concat"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset9",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(self,\u2002adaptor:\u2002NodeAdaptor,\u2002y:\u2002mlir.Type,\u2002*args,\u2002axis):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.concat(args,\u2002dim=axis,\u2002output_type=y)"]}),(0,t.jsx)("td",{children:"hbir.concat"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"input:"}),(0,t.jsx)("br",{}),"Arg Number: input number \u2208 [1, 1024]",(0,t.jsx)("br",{}),"Dim: all dims < 131072 ",(0,t.jsx)("br",{}),"size < 2G",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as input",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"Transpose"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset9",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(self,\u2002adaptor:\u2002NodeAdaptor,\u2002y:\u2002mlir.Type,\u2002x:\u2002mlir.Value,\u2002perm):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.transpose(x,\u2002perm,\u2002output_type=y)"]}),(0,t.jsx)("td",{children:"hbir.transpose"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"input:"}),(0,t.jsx)("br",{}),"No limits",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as input",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"Add"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset9",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,\u2002adaptor:\u2002NodeAdaptor,\u2002y:\u2002mlir.Type,\u2002lhs:\u2002mlir.Value,\u2002rhs:\u2002mlir.Value",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.add(lhs,\u2002rhs,\u2002output_type=y)"]}),(0,t.jsx)("td",{children:"hbir.add"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"lhs:"}),(0,t.jsx)("br",{}),"Type: int8, int16, int32, if type is int32, this hbir.add op must be fusible to a Conv op",(0,t.jsx)("br",{}),"Shape: [*]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"rhs:"}),(0,t.jsx)("br",{}),"Same as lhs",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as lhs",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"3",children:"Conv"}),(0,t.jsxs)("td",{rowSpan:"3",children:["//opset9",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002adaptor:\u2002NodeAdaptor,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002y:\u2002mlir.Type,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002x:\u2002mlir.Value,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002w:\u2002mlir.Value,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002b:\u2002Optional[mlir.Value]\u2002=\u2002None,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002*,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002dilations=(1,\u20021),",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002group=1,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002kernel_shape,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002pads=(0,\u20020,\u20020,\u20020),",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002strides=(1,\u20021),",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002kernel_dim\u2002=\u2002len(kernel_shape)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002if\u2002kernel_dim\u2002==\u20022:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002#\u2002input\u2002trans:\u2002nchw->nhwc",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002#\u2002output\u2002trans:\u2002nhwc->nchw",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002x\u2002=\u2002hbir.transpose(x,\u2002[0,\u20022,\u20023,\u20021])",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002w\u2002=\u2002hbir.transpose(w,\u2002[0,\u20022,\u20023,\u20021])",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002x\u2002=\u2002hbir.conv2d(x,\u2002w,\u2002strides,\u2002pads,\u2002dilations,\u2002group,\u2002bias=b)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002return\u2002hbir.transpose(x,\u2002[0,\u20023,\u20021,\u20022],\u2002output_type=y)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002elif\u2002kernel_dim\u2002==\u20023:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002#\u2002input\u2002trans:\u2002ncdhw->ndhwc",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002#\u2002output\u2002trans:\u2002ndhwc->ncdhw",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002x\u2002=\u2002hbir.transpose(x,\u2002[0,\u20022,\u20023,\u20024,\u20021])",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002w\u2002=\u2002hbir.transpose(w,\u2002[0,\u20022,\u20023,\u20024,\u20021])",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002x\u2002=\u2002hbir.conv3d(x,\u2002w,\u2002strides,\u2002pads,\u2002dilations,\u2002group,\u2002bias=b)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002return\u2002hbir.transpose(x,\u2002[0,\u20024,\u20021,\u20022,\u20023],\u2002output_type=y)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002else:",(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002raise\u2002ValueError("Only\u2002Conv2d\u2002and\u2002Conv3d\u2002supported\u2002for\u2002now.")']}),(0,t.jsx)("td",{children:"hbir.conv3d"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"lhs:"}),(0,t.jsx)("br",{}),"Type: int8",(0,t.jsx)("br",{}),"Shape: [*,D,H,W,C]",(0,t.jsx)("br",{}),"Dim: * \u2208 [1, 128]; D,H,W \u2208 [1, 65536]; C \u2208 [1, 4096];",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"rhs:"}),(0,t.jsx)("br",{}),"Type: int8",(0,t.jsx)("br",{}),"Shape: [N,KD,KH,KW,C]",(0,t.jsx)("br",{}),"N \u2208 [1, 65536]; KD,KH,KW \u2208 [1, 9]; Dim: C \u2208 [1, 4096];",(0,t.jsx)("br",{}),"Size: KD \xd7 KH \xd7 KW \xd7 C \u2208 [1, 131072]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"bias:"}),(0,t.jsx)("br",{}),"Type: f32",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as lhs",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"stride:"}),(0,t.jsx)("br",{}),"Shape: [SD,SH,SW]",(0,t.jsx)("br",{}),"Dim: SD,SH,SW must be 1 or 2 and equal to each other.",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"pad:"}),(0,t.jsx)("br",{}),"Shape: [P_front, P_top, P_left, P_back, P_bottom, P_right]",(0,t.jsx)("br",{}),"Dim: P_front,P_back \u2208 [0, KD/2], P_top,P_bottom \u2208 [0, KH/2], P_left,P_right \u2208 [0, KW/2]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"groupNum:"}),(0,t.jsx)("br",{}),"fin.c is divisible by group number",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"dilation:"}),(0,t.jsx)("br",{}),"Shape: [DD,DH,DW]",(0,t.jsx)("br",{}),"DD,DH,DW = 1 when group number more than 1",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{children:"hbir.conv2d"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"input:"}),(0,t.jsx)("br",{}),"Type: int8, int16; input and weight cannot both be int16",(0,t.jsx)("br",{}),"Shape: [*,H,W,C]",(0,t.jsx)("br",{}),"Dim: * \u2208 [1, 4096]; H,W,C \u2208 [1, 65536]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"weight:"}),(0,t.jsx)("br",{}),"Type: int8, int16; input and weight cannot both be int16",(0,t.jsx)("br",{}),"Shape: [N,KH,KW,C]",(0,t.jsx)("br",{}),"Dim: C \u2208 [1, 8192]; KH,KW \u2208 [1, 31]; N \u2208 [1, 65536] if fout is the last layer of conv else [1, 8192]",(0,t.jsx)("br",{}),"Size: KH \xd7 KW \xd7 C \u2208 [1, 65536]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"bias:"}),(0,t.jsx)("br",{}),"Type: f32",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Type: int8, int16, int32",(0,t.jsx)("br",{}),"Other constraints: Same as fin",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"stride:"}),(0,t.jsx)("br",{}),"Shape: [SH,SW]",(0,t.jsx)("br",{}),"Dim: SH,SW \u2208 [1, 256]; SH,SW \u2208 {1} if dilation > 1",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"pad:"}),(0,t.jsx)("br",{}),"Shape: [P_top,P_left,P_bottom,P_right]",(0,t.jsx)("br",{}),"Dim: P_top,P_bottom \u2208 [-H/2, 256], P_left,P_right \u2208 [-W/2, 256]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"groupNum:"}),(0,t.jsx)("br",{}),"fin.c is divisible by group number",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"dilation:"}),(0,t.jsx)("br",{}),"Shape: [DH,DW]",(0,t.jsx)("br",{}),"Dim: DH,DW \u2208 [1, 18]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"others:"}),(0,t.jsx)("br",{}),"Stride only support odd number and 2 when conv is a int16 depthwise conv",(0,t.jsx)("br",{}),"For each group, fin.c \u2208 [1, 8192], KH \xd7 KW \xd7 fin.c \u2208 [1, 65535], fin.c = C when group = 1",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{children:"hbir.transpose"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"input:"}),(0,t.jsx)("br",{}),"No limits",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as input",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"4",children:"LayerNormalization"}),(0,t.jsx)("td",{rowSpan:"4",children:"The operator is splited"}),(0,t.jsx)("td",{rowSpan:"2",children:"ReduceMean"}),(0,t.jsxs)("td",{rowSpan:"2",children:["//opset9",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002adaptor:\u2002NodeAdaptor,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002y:\u2002mlir.Type,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002x:\u2002mlir.Value,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002*,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002axes=None,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002keepdims=1,",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002if\u2002axes\u2002is\u2002None:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002axes\u2002=\u2002list(range(mlir.ShapedType(x.type).rank))",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.reduce_mean(x,\u2002dims=axes,\u2002keepDim=bool(keepdims),\u2002output_type=y)",(0,t.jsx)("br",{}),"//opset18",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002adaptor:\u2002NodeAdaptor,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002y:\u2002mlir.Type,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002x:\u2002mlir.Value,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002*args,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002keepdims=1,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002noop_with_empty_axes=0,",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002axes\u2002=\u2002None",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002if\u2002len(args)\u2002!=\u20020:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002axes\u2002=\u2002adaptor.operands[1].value.tolist()",(0,t.jsx)("br",{}),(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002if\u2002axes\u2002is\u2002None:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002axes\u2002=\u2002[]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002if\u2002noop_with_empty_axes\u2002==\u20020:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002#\u2002Reduce\u2002all\u2002axes",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002axes\u2002=\u2002list(range(mlir.ShapedType(x.type).rank))",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002else:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002#\u2002act\u2002like\u2002identity\u2002operands,\u2002here\u2002convert\u2002to\u2002reshape",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002return\u2002hbir.reshape(x,\u2002adaptor.operands[0].type.shape)",(0,t.jsx)("br",{}),(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002self.mlir_op_func(x,\u2002dims=axes,\u2002keepDim=bool(keepdims),\u2002output_type=y)"]}),(0,t.jsx)("td",{children:"hbir.reduce_mean"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"input:"}),(0,t.jsx)("br",{}),"Type: int8, int16",(0,t.jsx)("br",{}),"Shape: [*]",(0,t.jsx)("br",{}),"Dim: reduce axis dim size \u2208 [1, 65535]",(0,t.jsx)("br",{}),"Element : reduce Elements size \u2208 [1, 65535]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as input, ReduceArgMax/ReduceArgMin's output can be of type int32 or int64, as long as the size of the reduced axis can be represented using an int16 number",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{children:"hbir.reshape"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"input:"}),(0,t.jsx)("br",{}),"No limits",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as input",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"GlobalAveragePool"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset9",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(self,\u2002adaptor:\u2002NodeAdaptor,\u2002y:\u2002mlir.Type,\u2002x:\u2002mlir.Value):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.reduce_mean(x,\u2002dims=[-2,\u2002-1],\u2002keepDim=True,\u2002output_type=y)"]}),(0,t.jsx)("td",{children:"hbir.reduce_mean"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"input:"}),(0,t.jsx)("br",{}),"Type: int8, int16",(0,t.jsx)("br",{}),"Shape: [*]",(0,t.jsx)("br",{}),"Dim: reduce axis dim size \u2208 [1, 65535]",(0,t.jsx)("br",{}),"Element : reduce Elements size \u2208 [1, 65535]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as input, ReduceArgMax/ReduceArgMin's output can be of type int32 or int64, as long as the size of the reduced axis can be represented using an int16 number",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"Sub"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset9",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,\u2002adaptor:\u2002NodeAdaptor,\u2002y:\u2002mlir.Type,\u2002lhs:\u2002mlir.Value,\u2002rhs:\u2002mlir.Value",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.sub(lhs,\u2002rhs,\u2002output_type=y)"]}),(0,t.jsx)("td",{children:"hbir.sub"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"lhs:"}),(0,t.jsx)("br",{}),"Type: int8, int16",(0,t.jsx)("br",{}),"Shape: [*]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"rhs:"}),(0,t.jsx)("br",{}),"Same as lhs",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as lhs",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"LeakyRelu"}),(0,t.jsx)("td",{rowSpan:"1",children:"The operator is converted into a look-up-table operator"}),(0,t.jsx)("td",{rowSpan:"1",children:"HzLut"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset\u20029",(0,t.jsx)("br",{}),"func.func\u2002@HzLut(...)\u2002{",(0,t.jsx)("br",{}),"\u2002\u2002return\u2002b30.lut(...)",(0,t.jsx)("br",{}),"}"]}),(0,t.jsx)("td",{children:"b30.lut"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"inputs:"}),(0,t.jsx)("br",{}),"Type: int8, int16",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"outputs:"}),(0,t.jsx)("br",{}),"If input is int8, output is int8",(0,t.jsx)("br",{}),"If input is int16, output is int8/int16",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"Less"}),(0,t.jsx)("td",{rowSpan:"1",children:"None"}),(0,t.jsx)("td",{rowSpan:"1",children:"Less"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset9",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,\u2002adaptor:\u2002NodeAdaptor,\u2002y:\u2002mlir.Type,\u2002lhs:\u2002mlir.Value,\u2002rhs:\u2002mlir.Value",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.less(lhs,\u2002rhs,\u2002output_type=y)"]}),(0,t.jsx)("td",{children:"hbir.less"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"lhs:"}),(0,t.jsx)("br",{}),"Type: int8, int16",(0,t.jsx)("br",{}),"Shape: [*]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"rhs:"}),(0,t.jsx)("br",{}),"Same as lhs",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Type: bool8",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"LessOrEqual"}),(0,t.jsx)("td",{rowSpan:"1",children:"None"}),(0,t.jsx)("td",{rowSpan:"1",children:"LessOrEqual"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset12",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,\u2002adaptor:\u2002NodeAdaptor,\u2002y:\u2002mlir.Type,\u2002lhs:\u2002mlir.Value,\u2002rhs:\u2002mlir.Value",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.less_equal(lhs,\u2002rhs,\u2002output_type=y)"]}),(0,t.jsx)("td",{children:"hbir.less_equal"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"lhs:"}),(0,t.jsx)("br",{}),"Type: int8, int16",(0,t.jsx)("br",{}),"Shape: [*]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"rhs:"}),(0,t.jsx)("br",{}),"Same as lhs",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Type: bool8",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"Log"}),(0,t.jsx)("td",{rowSpan:"1",children:"The operator is converted into a look-up-table operator"}),(0,t.jsx)("td",{rowSpan:"1",children:"HzLut"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset\u20029",(0,t.jsx)("br",{}),"func.func\u2002@HzLut(...)\u2002{",(0,t.jsx)("br",{}),"\u2002\u2002return\u2002b30.lut(...)",(0,t.jsx)("br",{}),"}"]}),(0,t.jsx)("td",{children:"b30.lut"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"inputs:"}),(0,t.jsx)("br",{}),"Type: int8, int16",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"outputs:"}),(0,t.jsx)("br",{}),"If input is int8, output is int8",(0,t.jsx)("br",{}),"If input is int16, output is int8/int16",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"5",children:"MatMul"}),(0,t.jsx)("td",{rowSpan:"5",children:"The operator is splited"}),(0,t.jsx)("td",{rowSpan:"2",children:"MatMul"}),(0,t.jsxs)("td",{rowSpan:"2",children:["//opset9",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,\u2002adaptor:\u2002NodeAdaptor,\u2002output_type:\u2002mlir.Type,\u2002a:\u2002mlir.Value,\u2002b:\u2002mlir.Value",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002lhs_shape\u2002=\u2002np.array(adaptor.operands[0].type.shape)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002rhs_shape\u2002=\u2002np.array(adaptor.operands[0].type.shape)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002lhs_rank\u2002=\u2002len(lhs_shape)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002rhs_rank\u2002=\u2002len(rhs_shape)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002if\u2002lhs_rank\u2002==\u20021\u2002and\u2002rhs_rank\u2002==\u20021:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002#\u2002the\u2002output\u2002of\u20021D\u2002matmul\u2002is\u2002a\u2002scalar,\u2002the\u2002out_shape\u2002is\u2002none,\u2002so\u2002add\u2002reshape",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002out_shape\u2002=\u2002adaptor.results[0].type.shape",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002return\u2002hbir.reshape(hbir.matmul(a,\u2002b),\u2002out_shape,\u2002output_type=output_type)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002else:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002return\u2002hbir.matmul(a,\u2002b,\u2002output_type=output_type)"]}),(0,t.jsx)("td",{children:"hbir.reshape"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"input:"}),(0,t.jsx)("br",{}),"No limits",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as input",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{children:"hbir.matmul"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"lhs:"}),(0,t.jsx)("br",{}),"Type: int8, int16; lhs and rhs cannot both be int16",(0,t.jsx)("br",{}),"Shape: [*,M,C]",(0,t.jsx)("br",{}),"Dim: * \u2208 [1, 4096], M,C \u2208 [1, 8192]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"rhs:"}),(0,t.jsx)("br",{}),"Type: int8, int16; lhs and rhs cannot both be int16",(0,t.jsx)("br",{}),"Shape: [*,C,N]",(0,t.jsx)("br",{}),"Dim: * \u2208 [1, 4096]; C,N \u2208 [1, 8192]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Type: int8, int16, int32",(0,t.jsx)("br",{}),"Shape: [*,M,N]",(0,t.jsx)("br",{}),"Other constraints: Same as lhs",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"3",children:"Conv"}),(0,t.jsxs)("td",{rowSpan:"3",children:["//opset9",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002adaptor:\u2002NodeAdaptor,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002y:\u2002mlir.Type,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002x:\u2002mlir.Value,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002w:\u2002mlir.Value,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002b:\u2002Optional[mlir.Value]\u2002=\u2002None,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002*,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002dilations=(1,\u20021),",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002group=1,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002kernel_shape,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002pads=(0,\u20020,\u20020,\u20020),",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002strides=(1,\u20021),",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002kernel_dim\u2002=\u2002len(kernel_shape)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002if\u2002kernel_dim\u2002==\u20022:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002#\u2002input\u2002trans:\u2002nchw->nhwc",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002#\u2002output\u2002trans:\u2002nhwc->nchw",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002x\u2002=\u2002hbir.transpose(x,\u2002[0,\u20022,\u20023,\u20021])",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002w\u2002=\u2002hbir.transpose(w,\u2002[0,\u20022,\u20023,\u20021])",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002x\u2002=\u2002hbir.conv2d(x,\u2002w,\u2002strides,\u2002pads,\u2002dilations,\u2002group,\u2002bias=b)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002return\u2002hbir.transpose(x,\u2002[0,\u20023,\u20021,\u20022],\u2002output_type=y)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002elif\u2002kernel_dim\u2002==\u20023:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002#\u2002input\u2002trans:\u2002ncdhw->ndhwc",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002#\u2002output\u2002trans:\u2002ndhwc->ncdhw",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002x\u2002=\u2002hbir.transpose(x,\u2002[0,\u20022,\u20023,\u20024,\u20021])",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002w\u2002=\u2002hbir.transpose(w,\u2002[0,\u20022,\u20023,\u20024,\u20021])",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002x\u2002=\u2002hbir.conv3d(x,\u2002w,\u2002strides,\u2002pads,\u2002dilations,\u2002group,\u2002bias=b)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002return\u2002hbir.transpose(x,\u2002[0,\u20024,\u20021,\u20022,\u20023],\u2002output_type=y)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002else:",(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002raise\u2002ValueError("Only\u2002Conv2d\u2002and\u2002Conv3d\u2002supported\u2002for\u2002now.")']}),(0,t.jsx)("td",{children:"hbir.conv3d"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"lhs:"}),(0,t.jsx)("br",{}),"Type: int8",(0,t.jsx)("br",{}),"Shape: [*,D,H,W,C]",(0,t.jsx)("br",{}),"Dim: * \u2208 [1, 128]; D,H,W \u2208 [1, 65536]; C \u2208 [1, 4096];",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"rhs:"}),(0,t.jsx)("br",{}),"Type: int8",(0,t.jsx)("br",{}),"Shape: [N,KD,KH,KW,C]",(0,t.jsx)("br",{}),"N \u2208 [1, 65536]; KD,KH,KW \u2208 [1, 9]; Dim: C \u2208 [1, 4096];",(0,t.jsx)("br",{}),"Size: KD \xd7 KH \xd7 KW \xd7 C \u2208 [1, 131072]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"bias:"}),(0,t.jsx)("br",{}),"Type: f32",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as lhs",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"stride:"}),(0,t.jsx)("br",{}),"Shape: [SD,SH,SW]",(0,t.jsx)("br",{}),"Dim: SD,SH,SW must be 1 or 2 and equal to each other.",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"pad:"}),(0,t.jsx)("br",{}),"Shape: [P_front, P_top, P_left, P_back, P_bottom, P_right]",(0,t.jsx)("br",{}),"Dim: P_front,P_back \u2208 [0, KD/2], P_top,P_bottom \u2208 [0, KH/2], P_left,P_right \u2208 [0, KW/2]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"groupNum:"}),(0,t.jsx)("br",{}),"fin.c is divisible by group number",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"dilation:"}),(0,t.jsx)("br",{}),"Shape: [DD,DH,DW]",(0,t.jsx)("br",{}),"DD,DH,DW = 1 when group number more than 1",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{children:"hbir.conv2d"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"input:"}),(0,t.jsx)("br",{}),"Type: int8, int16; input and weight cannot both be int16",(0,t.jsx)("br",{}),"Shape: [*,H,W,C]",(0,t.jsx)("br",{}),"Dim: * \u2208 [1, 4096]; H,W,C \u2208 [1, 65536]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"weight:"}),(0,t.jsx)("br",{}),"Type: int8, int16; input and weight cannot both be int16",(0,t.jsx)("br",{}),"Shape: [N,KH,KW,C]",(0,t.jsx)("br",{}),"Dim: C \u2208 [1, 8192]; KH,KW \u2208 [1, 31]; N \u2208 [1, 65536] if fout is the last layer of conv else [1, 8192]",(0,t.jsx)("br",{}),"Size: KH \xd7 KW \xd7 C \u2208 [1, 65536]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"bias:"}),(0,t.jsx)("br",{}),"Type: f32",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Type: int8, int16, int32",(0,t.jsx)("br",{}),"Other constraints: Same as fin",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"stride:"}),(0,t.jsx)("br",{}),"Shape: [SH,SW]",(0,t.jsx)("br",{}),"Dim: SH,SW \u2208 [1, 256]; SH,SW \u2208 {1} if dilation > 1",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"pad:"}),(0,t.jsx)("br",{}),"Shape: [P_top,P_left,P_bottom,P_right]",(0,t.jsx)("br",{}),"Dim: P_top,P_bottom \u2208 [-H/2, 256], P_left,P_right \u2208 [-W/2, 256]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"groupNum:"}),(0,t.jsx)("br",{}),"fin.c is divisible by group number",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"dilation:"}),(0,t.jsx)("br",{}),"Shape: [DH,DW]",(0,t.jsx)("br",{}),"Dim: DH,DW \u2208 [1, 18]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"others:"}),(0,t.jsx)("br",{}),"Stride only support odd number and 2 when conv is a int16 depthwise conv",(0,t.jsx)("br",{}),"For each group, fin.c \u2208 [1, 8192], KH \xd7 KW \xd7 fin.c \u2208 [1, 65535], fin.c = C when group = 1",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{children:"hbir.transpose"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"input:"}),(0,t.jsx)("br",{}),"No limits",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as input",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"Max"}),(0,t.jsx)("td",{rowSpan:"1",children:"None"}),(0,t.jsx)("td",{rowSpan:"1",children:"Max"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset9",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002adaptor:\u2002NodeAdaptor,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002y:\u2002mlir.Type,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002lhs:\u2002mlir.Value,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002rhs:\u2002mlir.Value,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002*args,",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002if\u2002len(args)\u2002!=\u20020:",(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002raise\u2002ValueError(f"Operator\u2002Max\u2002expects\u20022\u2002inputs,\u2002but\u2002got\u2002{len(args)+2}")',(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.max(lhs,\u2002rhs,\u2002output_type=y)"]}),(0,t.jsx)("td",{children:"hbir.max"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"lhs:"}),(0,t.jsx)("br",{}),"Type: int8, int16",(0,t.jsx)("br",{}),"Shape: [*]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"rhs:"}),(0,t.jsx)("br",{}),"Same as lhs",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as lhs",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"2",children:"MaxPool"}),(0,t.jsx)("td",{rowSpan:"2",children:"None"}),(0,t.jsx)("td",{rowSpan:"2",children:"MaxPool"}),(0,t.jsxs)("td",{rowSpan:"2",children:["//opset9",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002adaptor:\u2002NodeAdaptor,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002y:\u2002mlir.Type,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002x:\u2002mlir.Value,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002*,",(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002auto_pad="NOTSET",',(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002ceil_mode=0,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002dilations=[1],",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002kernel_shape,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002pads=[0,\u20020],",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002storage_order=0,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002strides=[1],",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002#\u2002auto_pad\u2002is\u2002a\u2002DEPRECATED\u2002attribute,\u2002so\u2002it\u2002is\u2002ignored\u2002here.",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002#\u2002onnx\u2002maxpool\u2002supports\u2002a\u2002second\u2002output,\u2002and\u2002it\u2002is\u2002the\u2002index\u2002of\u2002the\u2002first\u2002output.\u2002storage_order\u2002is\u2002used\u2002to\u2002control\u2002whether\u2002it\u2002is\u2002row-major\u2002order\u2002or\u2002column-major\u2002order.\u2002Since\u2002second\u2002output\u2002is\u2002not\u2002supported,\u2002so\u2002attribute\u2002storage_order\u2002is\u2002ignored\u2002here.",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002assert\u2002len(adaptor.results)\u2002==\u20021",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002kernel_dim\u2002=\u2002len(kernel_shape)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002if\u2002kernel_dim\u2002<\u20021\u2002or\u2002kernel_dim\u2002>\u20022:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002raise\u2002ValueError(",(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002f"Operator\u2002MaxPool\u2002does\u2002not\u2002support\u2002kernel_dim\u2002{kernel_dim}"',(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002if\u2002kernel_dim\u2002==\u20021:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002x\u2002=\u2002hbir.transpose(x,\u2002[0,\u20022,\u20021])",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002elif\u2002kernel_dim\u2002==\u20022:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002x\u2002=\u2002hbir.transpose(x,\u2002[0,\u20022,\u20023,\u20021])",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002if\u2002dilations\u2002==\u2002[1]:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002dilations\u2002=\u2002dilations\u2002*\u2002kernel_dim",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002if\u2002strides\u2002==\u2002[1]:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002strides\u2002=\u2002strides\u2002*\u2002kernel_dim",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002if\u2002pads\u2002==\u2002[0,\u20020]:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002pads\u2002=\u2002pads\u2002*\u2002kernel_dim",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002x\u2002=\u2002hbir.max_pool(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002x,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002kernel=kernel_shape,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002stride=strides,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002pad=pads,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002dilation=dilations,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002ceilMode=bool(ceil_mode),",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002if\u2002kernel_dim\u2002==\u20021:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002return\u2002hbir.transpose(x,\u2002[0,\u20022,\u20021],\u2002output_type=y)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.transpose(x,\u2002[0,\u20023,\u20021,\u20022],\u2002output_type=y)"]}),(0,t.jsx)("td",{children:"hbir.max_pool"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"input:"}),(0,t.jsx)("br",{}),"Type: int8, int16",(0,t.jsx)("br",{}),"Shape: [*,H,W,C]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as input",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"kernel:"}),(0,t.jsx)("br",{}),"Shape: [KH,KW]",(0,t.jsx)("br",{}),"Dim: KH, KW \u2208 [1, 256]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"stride:"}),(0,t.jsx)("br",{}),"Shape: [SH,SW]",(0,t.jsx)("br",{}),"Dim: SH, SW \u2208 [1, 256]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"pad:"}),(0,t.jsx)("br",{}),"Shape: [PN,PH,PW,PC]",(0,t.jsx)("br",{}),"PN,PH,PW,PC \u2208 [-3, 256]",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{children:"hbir.transpose"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"input:"}),(0,t.jsx)("br",{}),"No limits",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as input",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"Min"}),(0,t.jsx)("td",{rowSpan:"1",children:"None"}),(0,t.jsx)("td",{rowSpan:"1",children:"Min"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset9",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002adaptor:\u2002NodeAdaptor,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002y:\u2002mlir.Type,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002lhs:\u2002mlir.Value,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002rhs:\u2002mlir.Value,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002*args,",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002if\u2002len(args)\u2002!=\u20020:",(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002raise\u2002ValueError(f"Operator\u2002Min\u2002expects\u20022\u2002inputs,\u2002but\u2002got\u2002{len(args)+2}")',(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.min(lhs,\u2002rhs,\u2002output_type=y)"]}),(0,t.jsx)("td",{children:"hbir.min"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"lhs:"}),(0,t.jsx)("br",{}),"Type: int8, int16",(0,t.jsx)("br",{}),"Shape: [*]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"rhs:"}),(0,t.jsx)("br",{}),"Same as lhs",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as lhs",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"Mish"}),(0,t.jsx)("td",{rowSpan:"1",children:"The operator is converted into a look-up-table operator"}),(0,t.jsx)("td",{rowSpan:"1",children:"HzLut"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset\u20029",(0,t.jsx)("br",{}),"func.func\u2002@HzLut(...)\u2002{",(0,t.jsx)("br",{}),"\u2002\u2002return\u2002b30.lut(...)",(0,t.jsx)("br",{}),"}"]}),(0,t.jsx)("td",{children:"b30.lut"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"inputs:"}),(0,t.jsx)("br",{}),"Type: int8, int16",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"outputs:"}),(0,t.jsx)("br",{}),"If input is int8, output is int8",(0,t.jsx)("br",{}),"If input is int16, output is int8/int16",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"Mul"}),(0,t.jsx)("td",{rowSpan:"1",children:"None"}),(0,t.jsx)("td",{rowSpan:"1",children:"Mul"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset9",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,\u2002adaptor:\u2002NodeAdaptor,\u2002y:\u2002mlir.Type,\u2002lhs:\u2002mlir.Value,\u2002rhs:\u2002mlir.Value",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.mul(lhs,\u2002rhs,\u2002output_type=y)"]}),(0,t.jsx)("td",{children:"hbir.mul"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"lhs:"}),(0,t.jsx)("br",{}),"Type: int8, int16",(0,t.jsx)("br",{}),"Shape: [*]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"rhs:"}),(0,t.jsx)("br",{}),"Same as lhs",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as lhs",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"Neg"}),(0,t.jsx)("td",{rowSpan:"1",children:"None"}),(0,t.jsx)("td",{rowSpan:"1",children:"Neg"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset9",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(self,\u2002adaptor:\u2002NodeAdaptor,\u2002y:\u2002mlir.Type,\u2002x:\u2002mlir.Value):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.Neg(x)",(0,t.jsx)("br",{}),"//opset11",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002adaptor:\u2002NodeAdaptor,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002y:\u2002mlir.Type,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002x:\u2002mlir.Value,",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.neg(x,\u2002output_type=y)"]}),(0,t.jsx)("td",{children:"hbir.neg"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"input:"}),(0,t.jsx)("br",{}),"Type: int8, int16",(0,t.jsx)("br",{}),"Shape: [*]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as input",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"Not"}),(0,t.jsx)("td",{rowSpan:"1",children:"None"}),(0,t.jsx)("td",{rowSpan:"1",children:"Not"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset9",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(self,\u2002adaptor:\u2002NodeAdaptor,\u2002y:\u2002mlir.Type,\u2002x:\u2002mlir.Value):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.logical_not(x,\u2002output_type=y)"]}),(0,t.jsx)("td",{children:"hbir.logical_not"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"input:"}),(0,t.jsx)("br",{}),"Type: int8, int16, bool8",(0,t.jsx)("br",{}),"Shape: [*]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Type: bool8",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"Or"}),(0,t.jsx)("td",{rowSpan:"1",children:"None"}),(0,t.jsx)("td",{rowSpan:"1",children:"Or"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset9",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,\u2002adaptor:\u2002NodeAdaptor,\u2002y:\u2002mlir.Type,\u2002lhs:\u2002mlir.Value,\u2002rhs:\u2002mlir.Value",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002#\u2002lhs\u2002=\u2002adaptor.operands[0].value.astype(np.int8)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002#\u2002rhs\u2002=\u2002adaptor.operands[1].value.astype(np.int8)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.logical_or(lhs,\u2002rhs,\u2002output_type=y)"]}),(0,t.jsx)("td",{children:"hbir.logical_or"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"lhs:"}),(0,t.jsx)("br",{}),"Type: int8, int16, bool8",(0,t.jsx)("br",{}),"Shape: [*]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"rhs:"}),(0,t.jsx)("br",{}),"Same as lhs",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Type: bool8",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"PRelu"}),(0,t.jsx)("td",{rowSpan:"1",children:"The operator is converted into a look-up-table operator"}),(0,t.jsx)("td",{rowSpan:"1",children:"HzLut"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset\u20029",(0,t.jsx)("br",{}),"func.func\u2002@HzLut(...)\u2002{",(0,t.jsx)("br",{}),"\u2002\u2002return\u2002b30.lut(...)",(0,t.jsx)("br",{}),"}"]}),(0,t.jsx)("td",{children:"b30.lut"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"inputs:"}),(0,t.jsx)("br",{}),"Type: int8, int16",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"outputs:"}),(0,t.jsx)("br",{}),"If input is int8, output is int8",(0,t.jsx)("br",{}),"If input is int16, output is int8/int16",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"Pow"}),(0,t.jsx)("td",{rowSpan:"1",children:"The operator is converted into a look-up-table operator"}),(0,t.jsx)("td",{rowSpan:"1",children:"HzLut"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset\u20029",(0,t.jsx)("br",{}),"func.func\u2002@HzLut(...)\u2002{",(0,t.jsx)("br",{}),"\u2002\u2002return\u2002b30.lut(...)",(0,t.jsx)("br",{}),"}"]}),(0,t.jsx)("td",{children:"b30.lut"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"inputs:"}),(0,t.jsx)("br",{}),"Type: int8, int16",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"outputs:"}),(0,t.jsx)("br",{}),"If input is int8, output is int8",(0,t.jsx)("br",{}),"If input is int16, output is int8/int16",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"Reciprocal"}),(0,t.jsx)("td",{rowSpan:"1",children:"The operator is converted into a look-up-table operator"}),(0,t.jsx)("td",{rowSpan:"1",children:"HzLut"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset\u20029",(0,t.jsx)("br",{}),"func.func\u2002@HzLut(...)\u2002{",(0,t.jsx)("br",{}),"\u2002\u2002return\u2002b30.lut(...)",(0,t.jsx)("br",{}),"}"]}),(0,t.jsx)("td",{children:"b30.lut"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"inputs:"}),(0,t.jsx)("br",{}),"Type: int8, int16",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"outputs:"}),(0,t.jsx)("br",{}),"If input is int8, output is int8",(0,t.jsx)("br",{}),"If input is int16, output is int8/int16",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"3",children:"ReduceL1"}),(0,t.jsx)("td",{rowSpan:"3",children:"The operator is splited"}),(0,t.jsx)("td",{rowSpan:"1",children:"HzLut"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset\u20029",(0,t.jsx)("br",{}),"func.func\u2002@HzLut(...)\u2002{",(0,t.jsx)("br",{}),"\u2002\u2002return\u2002b30.lut(...)",(0,t.jsx)("br",{}),"}"]}),(0,t.jsx)("td",{children:"b30.lut"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"inputs:"}),(0,t.jsx)("br",{}),"Type: int8, int16",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"outputs:"}),(0,t.jsx)("br",{}),"If input is int8, output is int8",(0,t.jsx)("br",{}),"If input is int16, output is int8/int16",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"2",children:"ReduceSum"}),(0,t.jsxs)("td",{rowSpan:"2",children:["//opset9",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002adaptor:\u2002NodeAdaptor,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002y:\u2002mlir.Type,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002x:\u2002mlir.Value,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002*,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002axes=None,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002keepdims=1,",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002if\u2002axes\u2002is\u2002None:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002axes\u2002=\u2002list(range(mlir.ShapedType(x.type).rank))",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.reduce_sum(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002x,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002dims=axes,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002keepDim=bool(keepdims),",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002output_type=y,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002)",(0,t.jsx)("br",{}),"//opset13",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002adaptor:\u2002NodeAdaptor,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002y:\u2002mlir.Type,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002x:\u2002mlir.Value,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002axes=None,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002*args,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002keepdims=1,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002noop_with_empty_axes=0,",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002axes\u2002=\u2002adaptor.operands[1].value.tolist()\u2002if\u2002axes\u2002is\u2002not\u2002None\u2002else\u2002None",(0,t.jsx)("br",{}),(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002if\u2002axes\u2002is\u2002None:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002if\u2002noop_with_empty_axes\u2002==\u20020:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002#\u2002Reduce\u2002all\u2002axes",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002axes\u2002=\u2002list(range(mlir.ShapedType(x.type).rank))",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002else:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002#\u2002act\u2002like\u2002identity\u2002operands,\u2002here\u2002convert\u2002to\u2002reshape",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002return\u2002hbir.reshape(x,\u2002adaptor.operands[0].type.shape)",(0,t.jsx)("br",{}),(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.reduce_sum(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002x,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002dims=axes,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002keepDim=bool(keepdims),",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002output_type=y,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002)"]}),(0,t.jsx)("td",{children:"hbir.reduce_sum"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"input:"}),(0,t.jsx)("br",{}),"Type: int8, int16",(0,t.jsx)("br",{}),"Shape: [*]",(0,t.jsx)("br",{}),"Dim: reduce axis dim size \u2208 [1, 65535]",(0,t.jsx)("br",{}),"Element : reduce Elements size \u2208 [1, 65535]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as input, ReduceArgMax/ReduceArgMin's output can be of type int32 or int64, as long as the size of the reduced axis can be represented using an int16 number",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{children:"hbir.reshape"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"input:"}),(0,t.jsx)("br",{}),"No limits",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as input",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"4",children:"ReduceL2"}),(0,t.jsx)("td",{rowSpan:"4",children:"The operator is splited"}),(0,t.jsx)("td",{children:"Pow"}),(0,t.jsx)("td",{}),(0,t.jsx)("td",{}),(0,t.jsx)("td",{children:"Unsupported"})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"2",children:"ReduceSum"}),(0,t.jsxs)("td",{rowSpan:"2",children:["//opset9",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002adaptor:\u2002NodeAdaptor,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002y:\u2002mlir.Type,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002x:\u2002mlir.Value,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002*,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002axes=None,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002keepdims=1,",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002if\u2002axes\u2002is\u2002None:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002axes\u2002=\u2002list(range(mlir.ShapedType(x.type).rank))",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.reduce_sum(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002x,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002dims=axes,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002keepDim=bool(keepdims),",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002output_type=y,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002)",(0,t.jsx)("br",{}),"//opset13",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002adaptor:\u2002NodeAdaptor,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002y:\u2002mlir.Type,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002x:\u2002mlir.Value,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002axes=None,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002*args,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002keepdims=1,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002noop_with_empty_axes=0,",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002axes\u2002=\u2002adaptor.operands[1].value.tolist()\u2002if\u2002axes\u2002is\u2002not\u2002None\u2002else\u2002None",(0,t.jsx)("br",{}),(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002if\u2002axes\u2002is\u2002None:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002if\u2002noop_with_empty_axes\u2002==\u20020:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002#\u2002Reduce\u2002all\u2002axes",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002axes\u2002=\u2002list(range(mlir.ShapedType(x.type).rank))",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002else:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002#\u2002act\u2002like\u2002identity\u2002operands,\u2002here\u2002convert\u2002to\u2002reshape",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002return\u2002hbir.reshape(x,\u2002adaptor.operands[0].type.shape)",(0,t.jsx)("br",{}),(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.reduce_sum(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002x,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002dims=axes,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002keepDim=bool(keepdims),",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002output_type=y,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002)"]}),(0,t.jsx)("td",{children:"hbir.reduce_sum"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"input:"}),(0,t.jsx)("br",{}),"Type: int8, int16",(0,t.jsx)("br",{}),"Shape: [*]",(0,t.jsx)("br",{}),"Dim: reduce axis dim size \u2208 [1, 65535]",(0,t.jsx)("br",{}),"Element : reduce Elements size \u2208 [1, 65535]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as input, ReduceArgMax/ReduceArgMin's output can be of type int32 or int64, as long as the size of the reduced axis can be represented using an int16 number",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{children:"hbir.reshape"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"input:"}),(0,t.jsx)("br",{}),"No limits",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as input",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"Sqrt"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset9",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(self,\u2002adaptor:\u2002NodeAdaptor,\u2002y:\u2002mlir.Type,\u2002x:\u2002mlir.Value):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.sqrt(x,\u2002output_type=y)"]}),(0,t.jsx)("td",{children:"hbir.sqrt"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"input:"}),(0,t.jsx)("br",{}),"Type: int8, int16",(0,t.jsx)("br",{}),"Shape: [*]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as input",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"2",children:"ReduceMax"}),(0,t.jsx)("td",{rowSpan:"2",children:"None"}),(0,t.jsx)("td",{rowSpan:"2",children:"ReduceMax"}),(0,t.jsxs)("td",{rowSpan:"2",children:["//opset9",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002adaptor:\u2002NodeAdaptor,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002y:\u2002mlir.Type,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002x:\u2002mlir.Value,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002*,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002axes=None,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002keepdims=1,",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002if\u2002axes\u2002is\u2002None:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002axes\u2002=\u2002list(range(mlir.ShapedType(x.type).rank))",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.reduce_max(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002x,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002dims=axes,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002keepDim=bool(keepdims),",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002output_type=y,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002)",(0,t.jsx)("br",{}),"//opset18",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002adaptor:\u2002NodeAdaptor,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002y:\u2002mlir.Type,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002x:\u2002mlir.Value,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002*args,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002keepdims=1,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002noop_with_empty_axes=0,",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002axes\u2002=\u2002None",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002if\u2002len(args)\u2002!=\u20020:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002axes\u2002=\u2002adaptor.operands[1].value.tolist()",(0,t.jsx)("br",{}),(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002if\u2002axes\u2002is\u2002None:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002axes\u2002=\u2002[]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002if\u2002noop_with_empty_axes\u2002==\u20020:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002#\u2002Reduce\u2002all\u2002axes",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002axes\u2002=\u2002list(range(mlir.ShapedType(x.type).rank))",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002else:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002#\u2002act\u2002like\u2002identity\u2002operands,\u2002here\u2002convert\u2002to\u2002reshape",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002return\u2002hbir.reshape(x,\u2002adaptor.operands[0].type.shape)",(0,t.jsx)("br",{}),(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002self.mlir_op_func(x,\u2002dims=axes,\u2002keepDim=bool(keepdims),\u2002output_type=y)"]}),(0,t.jsx)("td",{children:"hbir.reduce_max"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"input:"}),(0,t.jsx)("br",{}),"Type: int8, int16",(0,t.jsx)("br",{}),"Shape: [*]",(0,t.jsx)("br",{}),"Dim: reduce axis dim size \u2208 [1, 65535]",(0,t.jsx)("br",{}),"Element : reduce Elements size \u2208 [1, 65535]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as input, ReduceArgMax/ReduceArgMin's output can be of type int32 or int64, as long as the size of the reduced axis can be represented using an int16 number",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{children:"hbir.reshape"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"input:"}),(0,t.jsx)("br",{}),"No limits",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as input",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"2",children:"ReduceMean"}),(0,t.jsx)("td",{rowSpan:"2",children:"None"}),(0,t.jsx)("td",{rowSpan:"2",children:"ReduceMean"}),(0,t.jsxs)("td",{rowSpan:"2",children:["//opset9",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002adaptor:\u2002NodeAdaptor,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002y:\u2002mlir.Type,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002x:\u2002mlir.Value,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002*,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002axes=None,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002keepdims=1,",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002if\u2002axes\u2002is\u2002None:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002axes\u2002=\u2002list(range(mlir.ShapedType(x.type).rank))",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.reduce_mean(x,\u2002dims=axes,\u2002keepDim=bool(keepdims),\u2002output_type=y)",(0,t.jsx)("br",{}),"//opset18",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002adaptor:\u2002NodeAdaptor,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002y:\u2002mlir.Type,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002x:\u2002mlir.Value,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002*args,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002keepdims=1,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002noop_with_empty_axes=0,",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002axes\u2002=\u2002None",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002if\u2002len(args)\u2002!=\u20020:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002axes\u2002=\u2002adaptor.operands[1].value.tolist()",(0,t.jsx)("br",{}),(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002if\u2002axes\u2002is\u2002None:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002axes\u2002=\u2002[]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002if\u2002noop_with_empty_axes\u2002==\u20020:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002#\u2002Reduce\u2002all\u2002axes",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002axes\u2002=\u2002list(range(mlir.ShapedType(x.type).rank))",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002else:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002#\u2002act\u2002like\u2002identity\u2002operands,\u2002here\u2002convert\u2002to\u2002reshape",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002return\u2002hbir.reshape(x,\u2002adaptor.operands[0].type.shape)",(0,t.jsx)("br",{}),(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002self.mlir_op_func(x,\u2002dims=axes,\u2002keepDim=bool(keepdims),\u2002output_type=y)"]}),(0,t.jsx)("td",{children:"hbir.reduce_mean"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"input:"}),(0,t.jsx)("br",{}),"Type: int8, int16",(0,t.jsx)("br",{}),"Shape: [*]",(0,t.jsx)("br",{}),"Dim: reduce axis dim size \u2208 [1, 65535]",(0,t.jsx)("br",{}),"Element : reduce Elements size \u2208 [1, 65535]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as input, ReduceArgMax/ReduceArgMin's output can be of type int32 or int64, as long as the size of the reduced axis can be represented using an int16 number",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{children:"hbir.reshape"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"input:"}),(0,t.jsx)("br",{}),"No limits",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as input",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"2",children:"ReduceMin"}),(0,t.jsx)("td",{rowSpan:"2",children:"None"}),(0,t.jsx)("td",{rowSpan:"2",children:"ReduceMin"}),(0,t.jsxs)("td",{rowSpan:"2",children:["//opset9",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002adaptor:\u2002NodeAdaptor,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002y:\u2002mlir.Type,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002x:\u2002mlir.Value,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002*,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002axes=None,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002keepdims=1,",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002if\u2002axes\u2002is\u2002None:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002axes\u2002=\u2002list(range(mlir.ShapedType(x.type).rank))",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.reduce_min(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002x,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002dims=axes,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002keepDim=bool(keepdims),",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002output_type=y,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002)",(0,t.jsx)("br",{}),"//opset18",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002adaptor:\u2002NodeAdaptor,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002y:\u2002mlir.Type,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002x:\u2002mlir.Value,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002*args,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002keepdims=1,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002noop_with_empty_axes=0,",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002axes\u2002=\u2002None",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002if\u2002len(args)\u2002!=\u20020:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002axes\u2002=\u2002adaptor.operands[1].value.tolist()",(0,t.jsx)("br",{}),(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002if\u2002axes\u2002is\u2002None:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002axes\u2002=\u2002[]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002if\u2002noop_with_empty_axes\u2002==\u20020:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002#\u2002Reduce\u2002all\u2002axes",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002axes\u2002=\u2002list(range(mlir.ShapedType(x.type).rank))",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002else:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002#\u2002act\u2002like\u2002identity\u2002operands,\u2002here\u2002convert\u2002to\u2002reshape",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002return\u2002hbir.reshape(x,\u2002adaptor.operands[0].type.shape)",(0,t.jsx)("br",{}),(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002self.mlir_op_func(x,\u2002dims=axes,\u2002keepDim=bool(keepdims),\u2002output_type=y)"]}),(0,t.jsx)("td",{children:"hbir.reduce_min"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"input:"}),(0,t.jsx)("br",{}),"Type: int8, int16",(0,t.jsx)("br",{}),"Shape: [*]",(0,t.jsx)("br",{}),"Dim: reduce axis dim size \u2208 [1, 65535]",(0,t.jsx)("br",{}),"Element : reduce Elements size \u2208 [1, 65535]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as input, ReduceArgMax/ReduceArgMin's output can be of type int32 or int64, as long as the size of the reduced axis can be represented using an int16 number",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{children:"hbir.reshape"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"input:"}),(0,t.jsx)("br",{}),"No limits",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as input",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"2",children:"ReduceSum"}),(0,t.jsx)("td",{rowSpan:"2",children:"None"}),(0,t.jsx)("td",{rowSpan:"2",children:"ReduceSum"}),(0,t.jsxs)("td",{rowSpan:"2",children:["//opset9",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002adaptor:\u2002NodeAdaptor,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002y:\u2002mlir.Type,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002x:\u2002mlir.Value,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002*,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002axes=None,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002keepdims=1,",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002if\u2002axes\u2002is\u2002None:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002axes\u2002=\u2002list(range(mlir.ShapedType(x.type).rank))",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.reduce_sum(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002x,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002dims=axes,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002keepDim=bool(keepdims),",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002output_type=y,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002)",(0,t.jsx)("br",{}),"//opset13",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002adaptor:\u2002NodeAdaptor,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002y:\u2002mlir.Type,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002x:\u2002mlir.Value,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002axes=None,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002*args,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002keepdims=1,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002noop_with_empty_axes=0,",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002axes\u2002=\u2002adaptor.operands[1].value.tolist()\u2002if\u2002axes\u2002is\u2002not\u2002None\u2002else\u2002None",(0,t.jsx)("br",{}),(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002if\u2002axes\u2002is\u2002None:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002if\u2002noop_with_empty_axes\u2002==\u20020:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002#\u2002Reduce\u2002all\u2002axes",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002axes\u2002=\u2002list(range(mlir.ShapedType(x.type).rank))",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002else:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002#\u2002act\u2002like\u2002identity\u2002operands,\u2002here\u2002convert\u2002to\u2002reshape",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002return\u2002hbir.reshape(x,\u2002adaptor.operands[0].type.shape)",(0,t.jsx)("br",{}),(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.reduce_sum(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002x,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002dims=axes,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002keepDim=bool(keepdims),",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002output_type=y,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002)"]}),(0,t.jsx)("td",{children:"hbir.reduce_sum"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"input:"}),(0,t.jsx)("br",{}),"Type: int8, int16",(0,t.jsx)("br",{}),"Shape: [*]",(0,t.jsx)("br",{}),"Dim: reduce axis dim size \u2208 [1, 65535]",(0,t.jsx)("br",{}),"Element : reduce Elements size \u2208 [1, 65535]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as input, ReduceArgMax/ReduceArgMin's output can be of type int32 or int64, as long as the size of the reduced axis can be represented using an int16 number",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{children:"hbir.reshape"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"input:"}),(0,t.jsx)("br",{}),"No limits",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as input",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"Reshape"}),(0,t.jsx)("td",{rowSpan:"1",children:"None"}),(0,t.jsx)("td",{rowSpan:"1",children:"Reshape"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset9",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,\u2002adaptor:\u2002NodeAdaptor,\u2002y:\u2002mlir.Type,\u2002x:\u2002mlir.Value,\u2002shape:\u2002mlir.Value",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002out_shape\u2002=\u2002adaptor.results[0].type.shape",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.reshape(x,\u2002out_shape)",(0,t.jsx)("br",{}),"//opset18",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002adaptor:\u2002NodeAdaptor,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002y:\u2002mlir.Type,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002x:\u2002mlir.Value,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002shape:\u2002mlir.Value,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002*,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002allowzero=0,",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002input_shape\u2002=\u2002adaptor.operands[0].type.shape",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002out_shape\u2002=\u2002adaptor.results[0].type.shape",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002new_shape\u2002=\u2002np.copy(out_shape)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002if\u2002allowzero\u2002==\u20020:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002zeros_index\u2002=\u2002np.where(out_shape\u2002==\u20020)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002new_shape[zeros_index]\u2002=\u2002np.array(object=input_shape)[zeros_index]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.reshape(x,\u2002shape=new_shape)"]}),(0,t.jsx)("td",{children:"hbir.reshape"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"input:"}),(0,t.jsx)("br",{}),"No limits",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as input",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"2",children:"Resize"}),(0,t.jsx)("td",{rowSpan:"2",children:"None"}),(0,t.jsx)("td",{rowSpan:"2",children:"Resize"}),(0,t.jsxs)("td",{rowSpan:"2",children:["//opset10",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002adaptor:\u2002NodeAdaptor,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002y:\u2002mlir.Type,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002x:\u2002mlir.Value,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002scales:\u2002mlir.Value\u2002=\u2002None,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002*,",(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002mode="nearest",',(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002input_shape\u2002=\u2002np.array(adaptor.operands[0].type.shape)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002output_shape\u2002=\u2002np.array(adaptor.results[0].type.shape)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002#\u2002Only\u2002supports\u2002resizing\u2002operations\u2002with\u20024-dimensional\u2002features",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002assert\u2002len(input_shape)\u2002==\u20024",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002scale_tensor\u2002=\u2002adaptor.operands[1].value",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002resize_scale\u2002=\u2002scale_tensor[2:]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002if\u2002isinstance(mode,\u2002bytes):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002mode\u2002=\u2002mode.decode()",(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002if\u2002mode\u2002==\u2002"linear":',(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002mode\u2002=\u2002"bilinear"',(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002if\u2002mode\u2002not\u2002in\u2002["nearest",\u2002"bilinear"]:',(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002raise\u2002ValueError(f"Operator\u2002Resize\u2002does\u2002not\u2002support\u2002resize\u2002mode:\u2002{mode}")',(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002#\u2002resize\u200210\u2002only\u2002supports\u2002one\u2002resize\u2002method,\u2002which\u2002is\u2002the\u2002most\u2002basic\u2002resize\u2002method",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002step\u2002=\u20021\u2002/\u2002resize_scale",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002initial_offset\u2002=\u2002np.array([-0.5,\u2002-0.5])",(0,t.jsx)("br",{}),(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002#\u20021.\u2002when\u2002there\u2002is\u2002a\u2002ratio\u2002parameter,\u2002if\u2002the\u2002value\u2002of\u2002ratio\u2002is\u2002negative,\u2002you\u2002need\u2002to\u2002correct\u2002the\u2002value\u2002of\u2002initialOffset;",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002#\u20022.\u2002when\u2002there\u2002is\u2002a\u2002size\u2002parameter,\u2002if\u2002the\u2002value\u2002of\u2002step\u2002is\u2002negative,\u2002you\u2002need\u2002to\u2002correct\u2002the\u2002value\u2002of\u2002initialOffset;",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002rank\u2002=\u2002len(input_shape)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002numOfResizeAxis\u2002=\u20022",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002for\u2002i\u2002in\u2002range(numOfResizeAxis):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002axis\u2002=\u2002rank\u2002-\u2002numOfResizeAxis\u2002-\u20021\u2002+\u2002i",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002if\u2002step[i]\u2002<\u20020:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002initial_offset[i]\u2002=\u2002float(input_shape[axis])",(0,t.jsx)("br",{}),(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002x\u2002=\u2002hbir.transpose(x,\u2002[0,\u20022,\u20023,\u20021])",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002x\u2002=\u2002hbir.resize2d(",(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002x,\u2002step,\u2002initial_offset,\u2002mode,\u2002size=output_shape[2:],\u2002expansionMode="border"',(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002x\u2002=\u2002hbir.transpose(x,\u2002[0,\u20023,\u20021,\u20022],\u2002output_type=y)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002x",(0,t.jsx)("br",{}),"//opset11",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002adaptor:\u2002NodeAdaptor,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002y:\u2002mlir.Type,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002x:\u2002mlir.Value,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002roi:\u2002mlir.Value\u2002=\u2002None,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002scales:\u2002mlir.Value\u2002=\u2002None,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002sizes:\u2002mlir.Value\u2002=\u2002None,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002*,",(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002coordinate_transformation_mode="half_pixel",',(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002cubic_coeff_a="-0.75",',(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002exclude_outside=0,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002extrapolation_value=0,",(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002mode="nearest",',(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002nearest_mode="round_prefer_floor",',(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002input_shape\u2002=\u2002np.array(adaptor.operands[0].type.shape)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002output_shape\u2002=\u2002np.array(adaptor.results[0].type.shape)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002rank\u2002=\u2002len(input_shape)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002roi\u2002=\u2002adaptor.operands[1].value",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002#\u2002\u4EC5\u652F\u6301feature\u4E3A4\u7EF4\u7684resize\u64CD\u4F5C",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002assert\u2002len(input_shape)\u2002==\u20024",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002scale_tensor\u2002=\u2002adaptor.operands[2].value",(0,t.jsx)("br",{}),(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002if\u2002scale_tensor.size\u2002>\u20020:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002resize_shape\u2002=\u2002input_shape\u2002*\u2002scale_tensor",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002else:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002resize_shape\u2002=\u2002adaptor.operands[3].value",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002scale_tensor\u2002=\u2002np.array(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002[",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u20021,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u20021,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002resize_shape[2]\u2002/\u2002input_shape[2],",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002resize_shape[3]\u2002/\u2002input_shape[3],",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002)",(0,t.jsx)("br",{}),(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002length_original\u2002=\u2002input_shape[2:].astype(np.int32)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002length_resized\u2002=\u2002resize_shape[2:].astype(np.int32)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002coordinate_transformation_mode\u2002=\u2002(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002coordinate_transformation_mode.decode()",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002if\u2002isinstance(coordinate_transformation_mode,\u2002bytes)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002else\u2002coordinate_transformation_mode",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002)",(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002if\u2002coordinate_transformation_mode\u2002!=\u2002"tf_crop_and_resize"\u2002and\u2002np.array_equal(',(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002length_original,\u2002length_resized",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002x\u2002=\u2002hbir.transpose(x,\u2002[0,\u20022,\u20023,\u20021])",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002x\u2002=\u2002hbir.resize2d(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002x,\u2002step=[1.0,\u20021.0],\u2002initialOffset=[0.0,\u20020.0],\u2002ratio=(1.0,\u20021.0)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002x\u2002=\u2002hbir.transpose(x,\u2002[0,\u20023,\u20021,\u20022],\u2002output_type=y)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002return\u2002x",(0,t.jsx)("br",{}),(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002#\u2002resize\u2002\u8BA1\u7B97\u516C\u5F0F:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002#\u2002hw_in\u2002=\u2002initial_offset\u2002+\u2002hw_out\u2002*\u2002step",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002resize_scale\u2002=\u2002scale_tensor[2:]",(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002if\u2002coordinate_transformation_mode\u2002in\u2002["pytorch_half_pixel"]:',(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002step\u2002=\u20021\u2002/\u2002resize_scale",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002initial_offset\u2002=\u20020.5\u2002/\u2002resize_scale\u2002-\u20020.5",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002for\u2002index,\u2002resized_num\u2002in\u2002enumerate(length_resized):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002if\u2002resized_num\u2002<=\u20021:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002step[index]\u2002=\u20020.0",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002initial_offset[index]\u2002=\u20020.0",(0,t.jsx)("br",{}),(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002elif\u2002coordinate_transformation_mode\u2002in\u2002["half_pixel"]:',(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002step\u2002=\u20021\u2002/\u2002resize_scale",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002initial_offset\u2002=\u20020.5\u2002/\u2002resize_scale\u2002-\u20020.5",(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002elif\u2002coordinate_transformation_mode\u2002in\u2002["align_corners"]:',(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002step\u2002=\u2002(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002(length_original[0]\u2002-\u20021)\u2002/\u2002(length_resized[0]\u2002-\u20021),",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002(length_original[1]\u2002-\u20021)\u2002/\u2002(length_resized[1]\u2002-\u20021),",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002initial_offset\u2002=\u2002[0.0,\u20020.0]",(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002elif\u2002coordinate_transformation_mode\u2002in\u2002["asymmetric"]:',(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002step\u2002=\u20021\u2002/\u2002resize_scale",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002initial_offset\u2002=\u2002[0.0,\u20020.0]",(0,t.jsx)("br",{}),(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002elif\u2002coordinate_transformation_mode\u2002in\u2002["tf_half_pixel_for_nn"]:',(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002step\u2002=\u20021\u2002/\u2002resize_scale",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002initial_offset\u2002=\u20020.5\u2002/\u2002resize_scale",(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002elif\u2002coordinate_transformation_mode\u2002in\u2002["tf_crop_and_resize"]:',(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002start_x\u2002=\u2002roi[rank\u2002-\u20022\u2002:\u2002rank]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002end_x\u2002=\u2002roi[2\u2002*\u2002rank\u2002-\u20022\u2002:\u20022\u2002*\u2002rank]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002step\u2002=\u2002[1,\u20021]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002initial_offset\u2002=\u2002[0,\u20020]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002for\u2002index\u2002in\u2002range(len(length_resized)):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002if\u2002length_resized[index]\u2002>\u20021:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002step[index]\u2002=\u2002(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002(end_x[index]\u2002-\u2002start_x[index])",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002*\u2002(length_original[index]\u2002-\u20021)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002/\u2002(length_resized[index]\u2002-\u20021)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002initial_offset[index]\u2002=\u2002start_x[index]\u2002*\u2002(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002length_original[index]\u2002-\u20021",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002else:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002step[index]\u2002=\u20020",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002initial_offset[index]\u2002=\u2002(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u20020.5",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002*\u2002(start_x[index]\u2002+\u2002end_x[index])",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002*\u2002(length_original[index]\u2002-\u20021)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002else:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002raise\u2002ValueError(",(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002f"Operator\u2002Resize\u2002does\u2002not\u2002support\u2002coordinate_transformation_mode:\u2002{coordinate_transformation_mode}"',(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002)",(0,t.jsx)("br",{}),(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002if\u2002isinstance(mode,\u2002bytes):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002mode\u2002=\u2002mode.decode()",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002if\u2002isinstance(nearest_mode,\u2002bytes):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002nearest_mode\u2002=\u2002nearest_mode.decode()",(0,t.jsx)("br",{}),(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002if\u2002mode\u2002==\u2002"linear":',(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002mode\u2002=\u2002"bilinear"',(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002if\u2002mode\u2002==\u2002"cubic":',(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002mode\u2002=\u2002"bicubic"',(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002if\u2002mode\u2002not\u2002in\u2002["nearest",\u2002"bilinear",\u2002"bicubic"]:',(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002raise\u2002ValueError(f"Operator\u2002Resize\u2002does\u2002not\u2002support\u2002resize\u2002mode:\u2002{mode}")',(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002if\u2002mode\u2002==\u2002"nearest":',(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002if\u2002nearest_mode\u2002==\u2002"round_prefer_ceil":',(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002initial_offset\u2002+=\u2002np.array(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002[np.finfo(np.float32).eps,\u2002np.finfo(np.float32).eps]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002)",(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002if\u2002nearest_mode\u2002==\u2002"round_prefer_floor":',(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002initial_offset\u2002-=\u2002np.array(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002[np.finfo(np.float32).eps,\u2002np.finfo(np.float32).eps]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002)",(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002elif\u2002nearest_mode\u2002==\u2002"floor":',(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002initial_offset\u2002-=\u2002np.array([0.5,\u20020.5])",(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002elif\u2002nearest_mode\u2002==\u2002"ceil":',(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002initial_offset\u2002+=\u2002np.array([0.5,\u20020.5])",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002else:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002raise\u2002ValueError(",(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002f"Operator\u2002Resize\u2002does\u2002not\u2002support\u2002nearest_mode\u2002mode:\u2002{nearest_mode}"',(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002)",(0,t.jsx)("br",{}),(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002#\u20021.\u2002when\u2002there\u2002is\u2002a\u2002ratio\u2002parameter,\u2002if\u2002the\u2002value\u2002of\u2002ratio\u2002is\u2002negative,\u2002you\u2002need\u2002to\u2002correct\u2002the\u2002value\u2002of\u2002initialOffset;",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002#\u20022.\u2002when\u2002there\u2002is\u2002a\u2002size\u2002parameter,\u2002if\u2002the\u2002value\u2002of\u2002step\u2002is\u2002negative,\u2002you\u2002need\u2002to\u2002correct\u2002the\u2002value\u2002of\u2002initialOffset;",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002rank\u2002=\u2002len(input_shape)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002numOfResizeAxis\u2002=\u20022",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002for\u2002i\u2002in\u2002range(numOfResizeAxis):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002axis\u2002=\u2002rank\u2002-\u2002numOfResizeAxis\u2002-\u20021\u2002+\u2002i",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002if\u2002step[i]\u2002<\u20020:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002initial_offset[i]\u2002=\u2002float(input_shape[axis])",(0,t.jsx)("br",{}),(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002x\u2002=\u2002hbir.transpose(x,\u2002[0,\u20022,\u20023,\u20021])",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002x\u2002=\u2002hbir.resize2d(",(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002x,\u2002step,\u2002initial_offset,\u2002mode,\u2002size=output_shape[2:],\u2002expansionMode="border"',(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002x\u2002=\u2002hbir.transpose(x,\u2002[0,\u20023,\u20021,\u20022],\u2002output_type=y)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002x",(0,t.jsx)("br",{}),"//opset18",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002adaptor:\u2002NodeAdaptor,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002y:\u2002mlir.Type,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002x:\u2002mlir.Value,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002roi:\u2002mlir.Value\u2002=\u2002None,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002scales:\u2002mlir.Value\u2002=\u2002None,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002sizes:\u2002mlir.Value\u2002=\u2002None,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002*,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002antialias=0,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002axes=None,",(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002coordinate_transformation_mode="half_pixel",',(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002cubic_coeff_a="-0.75",',(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002exclude_outside=0,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002extrapolation_value=0,",(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002keep_aspect_ratio_policy="stretch",',(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002mode="nearest",',(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002nearest_mode="round_prefer_floor",',(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002input_shape\u2002=\u2002np.array(adaptor.operands[0].type.shape)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002length_original\u2002=\u2002input_shape[2:].astype(np.int32)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002output_shape\u2002=\u2002np.array(adaptor.results[0].type.shape)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002rank\u2002=\u2002len(input_shape)",(0,t.jsx)("br",{}),(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002#\u2002\u4EC5\u652F\u6301feature\u4E3A4\u7EF4\u7684resize\u64CD\u4F5C",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002assert\u2002len(input_shape)\u2002==\u20024",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002if\u2002roi\u2002is\u2002not\u2002None\u2002and\u2002len(adaptor.operands[1].value)\u2002>\u20020:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002roi\u2002=\u2002adaptor.operands[1].value",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002scale_tensor\u2002=\u2002(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002None",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002if\u2002(scales\u2002is\u2002None\u2002or\u2002(len(adaptor.operands[2].value)\u2002==\u20020))",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002else\u2002adaptor.operands[2].value",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002output_size\u2002=\u2002(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002None",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002if\u2002(sizes\u2002is\u2002None\u2002or\u2002(len(adaptor.operands[3].value)\u2002==\u20020))",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002else\u2002adaptor.operands[3].value",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002coordinate_transformation_mode\u2002=\u2002(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002coordinate_transformation_mode.decode()",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002if\u2002isinstance(coordinate_transformation_mode,\u2002bytes)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002else\u2002coordinate_transformation_mode",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002if\u2002isinstance(mode,\u2002bytes):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002mode\u2002=\u2002mode.decode()",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002if\u2002isinstance(nearest_mode,\u2002bytes):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002nearest_mode\u2002=\u2002nearest_mode.decode()",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002if\u2002isinstance(keep_aspect_ratio_policy,\u2002bytes):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002keep_aspect_ratio_policy\u2002=\u2002keep_aspect_ratio_policy.decode()",(0,t.jsx)("br",{}),(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002if\u2002antialias\u2002!=\u20020:",(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002raise\u2002ValueError("Operator\u2002Resize\u2002does\u2002not\u2002support\u2002antialias\u2002mode.")',(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002if\u2002output_size\u2002is\u2002None\u2002and\u2002scale_tensor\u2002is\u2002None:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002raise\u2002ValueError(",(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002"Operator\u2002Resize:\u2002one\u2002of\u2002scales\u2002and\u2002sizes\u2002must\u2002be\u2002specified."',(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002if\u2002output_size\u2002is\u2002not\u2002None\u2002and\u2002scale_tensor\u2002is\u2002not\u2002None:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002raise\u2002ValueError(",(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002"Operator\u2002Resize:\u2002only\u2002one\u2002of\u2002scales\u2002and\u2002sizes\u2002can\u2002be\u2002specified."',(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002)",(0,t.jsx)("br",{}),(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002if\u2002axes\u2002is\u2002not\u2002None:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002if\u2002len(axes)\u2002>\u20022:",(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002raise\u2002ValueError("Operator\u2002Resize\u2002supports\u2002specifying\u2002up\u2002to\u20022\u2002axes.")',(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002axes_num\u2002=\u2002len(axes)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002if\u2002output_size\u2002is\u2002not\u2002None:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002new_output_size\u2002=\u2002np.copy(input_shape)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002new_output_size[axes]\u2002=\u2002output_size",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002output_size\u2002=\u2002new_output_size",(0,t.jsx)("br",{}),(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002if\u2002scale_tensor\u2002is\u2002not\u2002None:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002new_scales\u2002=\u2002np.ones(rank,\u2002dtype=np.float32)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002new_scales[axes]\u2002=\u2002scale_tensor",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002scale_tensor\u2002=\u2002new_scales",(0,t.jsx)("br",{}),(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002if\u2002roi\u2002is\u2002not\u2002None:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002new_roi_begin\u2002=\u2002np.zeros(rank,\u2002dtype=np.float32)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002new_roi_end\u2002=\u2002np.ones(rank,\u2002dtype=np.float32)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002new_roi_begin[axes]\u2002=\u2002roi[:axes_num]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002new_roi_end[axes]\u2002=\u2002roi[axes_num:]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002roi\u2002=\u2002np.concatenate((new_roi_begin,\u2002new_roi_end))",(0,t.jsx)("br",{}),(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002if\u2002scale_tensor\u2002is\u2002not\u2002None:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002resize_shape\u2002=\u2002input_shape\u2002*\u2002scale_tensor",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002length_resized\u2002=\u2002resize_shape[2:].astype(np.int32)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002else:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002resize_shape\u2002=\u2002output_size",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002length_resized\u2002=\u2002resize_shape[2:].astype(np.int32)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002scale_tensor\u2002=\u2002np.array(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002[",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u20021,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u20021,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002resize_shape[2]\u2002/\u2002input_shape[2],",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002resize_shape[3]\u2002/\u2002input_shape[3],",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002)",(0,t.jsx)("br",{}),(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002if\u2002keep_aspect_ratio_policy\u2002!=\u2002"stretch":',(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002if\u2002keep_aspect_ratio_policy\u2002==\u2002"not_larger":',(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002scale\u2002=\u2002np.min(resize_shape[2:]\u2002/\u2002input_shape[2:])",(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002elif\u2002keep_aspect_ratio_policy\u2002==\u2002"not_smaller":',(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002scale\u2002=\u2002np.max(resize_shape[2:]\u2002/\u2002input_shape[2:])",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002else:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002raise\u2002ValueError(",(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002f"Invalid\u2002keep_aspect_ratio_policy={keep_aspect_ratio_policy!r}"',(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002)",(0,t.jsx)("br",{}),(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002scale_tensor[2]\u2002=\u2002scale_tensor[3]\u2002=\u2002scale",(0,t.jsx)("br",{}),(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002resize_shape\u2002=\u2002input_shape\u2002*\u2002scale_tensor",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002length_resized\u2002=\u2002[int(elem\u2002+\u20020.5)\u2002for\u2002elem\u2002in\u2002resize_shape[2:]]",(0,t.jsx)("br",{}),(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002if\u2002coordinate_transformation_mode\u2002!=\u2002"tf_crop_and_resize"\u2002and\u2002np.array_equal(',(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002length_original,\u2002length_resized",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002x\u2002=\u2002hbir.transpose(x,\u2002[0,\u20022,\u20023,\u20021])",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002x\u2002=\u2002hbir.resize2d(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002x,\u2002step=[1.0,\u20021.0],\u2002initialOffset=[0.0,\u20020.0],\u2002ratio=(1.0,\u20021.0)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002x\u2002=\u2002hbir.transpose(x,\u2002[0,\u20023,\u20021,\u20022],\u2002output_type=y)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002return\u2002x",(0,t.jsx)("br",{}),(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002#\u2002resize\u2002calculation\u2002formula:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002#\u2002hw_in\u2002=\u2002initial_offset\u2002+\u2002hw_out\u2002*\u2002step",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002resize_scale\u2002=\u2002scale_tensor[2:]",(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002if\u2002coordinate_transformation_mode\u2002in\u2002["pytorch_half_pixel"]:',(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002step\u2002=\u20021\u2002/\u2002resize_scale",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002initial_offset\u2002=\u20020.5\u2002/\u2002resize_scale\u2002-\u20020.5",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002for\u2002index,\u2002resized_num\u2002in\u2002enumerate(length_resized):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002if\u2002resized_num\u2002<=\u20021:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002step[index]\u2002=\u20020.0",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002initial_offset[index]\u2002=\u20020.0",(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002elif\u2002coordinate_transformation_mode\u2002in\u2002["half_pixel_symmetric"]:',(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002adjustment\u2002=\u2002length_resized\u2002/\u2002resize_shape[2:]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002center\u2002=\u2002length_original\u2002/\u20022",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002offset\u2002=\u2002center\u2002*\u2002(1\u2002-\u2002adjustment)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002step\u2002=\u20021\u2002/\u2002resize_scale",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002initial_offset\u2002=\u20020.5\u2002/\u2002resize_scale\u2002-\u20020.5\u2002+\u2002offset",(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002elif\u2002coordinate_transformation_mode\u2002in\u2002["half_pixel"]:',(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002step\u2002=\u20021\u2002/\u2002resize_scale",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002initial_offset\u2002=\u20020.5\u2002/\u2002resize_scale\u2002-\u20020.5",(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002elif\u2002coordinate_transformation_mode\u2002in\u2002["align_corners"]:',(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002step\u2002=\u2002(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002(length_original[0]\u2002-\u20021)\u2002/\u2002(length_resized[0]\u2002-\u20021),",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002(length_original[1]\u2002-\u20021)\u2002/\u2002(length_resized[1]\u2002-\u20021),",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002initial_offset\u2002=\u2002[0.0,\u20020.0]",(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002elif\u2002coordinate_transformation_mode\u2002in\u2002["asymmetric"]:',(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002step\u2002=\u20021\u2002/\u2002resize_scale",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002initial_offset\u2002=\u2002[0.0,\u20020.0]",(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002elif\u2002coordinate_transformation_mode\u2002in\u2002["tf_crop_and_resize"]:',(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002start_x\u2002=\u2002roi[rank\u2002-\u20022\u2002:\u2002rank]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002end_x\u2002=\u2002roi[2\u2002*\u2002rank\u2002-\u20022\u2002:\u20022\u2002*\u2002rank]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002step\u2002=\u2002[1,\u20021]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002initial_offset\u2002=\u2002[0,\u20020]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002for\u2002index\u2002in\u2002range(len(length_resized)):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002if\u2002length_resized[index]\u2002>\u20021:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002step[index]\u2002=\u2002(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002(end_x[index]\u2002-\u2002start_x[index])",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002*\u2002(length_original[index]\u2002-\u20021)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002/\u2002(length_resized[index]\u2002-\u20021)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002initial_offset[index]\u2002=\u2002start_x[index]\u2002*\u2002(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002length_original[index]\u2002-\u20021",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002else:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002step[index]\u2002=\u20020",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002initial_offset[index]\u2002=\u2002(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u20020.5",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002*\u2002(start_x[index]\u2002+\u2002end_x[index])",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002*\u2002(length_original[index]\u2002-\u20021)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002else:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002raise\u2002ValueError(",(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002f"Operator\u2002Resize\u2002does\u2002not\u2002support\u2002coordinate_transformation_mode:\u2002{coordinate_transformation_mode}"',(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002)",(0,t.jsx)("br",{}),(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002#\u2002Currently\u2002only\u2002nearest\u2002and\u2002bilinear\u2002are\u2002supported.",(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002if\u2002mode\u2002==\u2002"linear":',(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002mode\u2002=\u2002"bilinear"',(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002if\u2002mode\u2002==\u2002"cubic":',(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002mode\u2002=\u2002"bicubic"',(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002if\u2002mode\u2002not\u2002in\u2002["nearest",\u2002"bilinear",\u2002"bicubic"]:',(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002raise\u2002ValueError(f"Operator\u2002Resize\u2002does\u2002not\u2002support\u2002resize\u2002mode:\u2002{mode}")',(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002if\u2002mode\u2002==\u2002"nearest":',(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002if\u2002nearest_mode\u2002==\u2002"round_prefer_ceil":',(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002initial_offset\u2002+=\u2002np.array(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002[np.finfo(np.float32).eps,\u2002np.finfo(np.float32).eps]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002)",(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002if\u2002nearest_mode\u2002==\u2002"round_prefer_floor":',(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002initial_offset\u2002-=\u2002np.array(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002[np.finfo(np.float32).eps,\u2002np.finfo(np.float32).eps]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002)",(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002elif\u2002nearest_mode\u2002==\u2002"floor":',(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002initial_offset\u2002-=\u2002np.array([0.5,\u20020.5])",(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002elif\u2002nearest_mode\u2002==\u2002"ceil":',(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002initial_offset\u2002+=\u2002np.array([0.5,\u20020.5])",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002else:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002raise\u2002ValueError(",(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002f"Operator\u2002Resize\u2002does\u2002not\u2002support\u2002nearest_mode\u2002mode:\u2002{nearest_mode}"',(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002)",(0,t.jsx)("br",{}),(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002#\u20021.\u2002when\u2002there\u2002is\u2002a\u2002ratio\u2002parameter,\u2002if\u2002the\u2002value\u2002of\u2002ratio\u2002is\u2002negative,\u2002you\u2002need\u2002to\u2002correct\u2002the\u2002value\u2002of\u2002initialOffset;",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002#\u20022.\u2002when\u2002there\u2002is\u2002a\u2002size\u2002parameter,\u2002if\u2002the\u2002value\u2002of\u2002step\u2002is\u2002negative,\u2002you\u2002need\u2002to\u2002correct\u2002the\u2002value\u2002of\u2002initialOffset;",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002rank\u2002=\u2002len(input_shape)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002numOfResizeAxis\u2002=\u20022",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002for\u2002i\u2002in\u2002range(numOfResizeAxis):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002axis\u2002=\u2002rank\u2002-\u2002numOfResizeAxis\u2002-\u20021\u2002+\u2002i",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002if\u2002step[i]\u2002<\u20020:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002initial_offset[i]\u2002=\u2002float(input_shape[axis])",(0,t.jsx)("br",{}),(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002x\u2002=\u2002hbir.transpose(x,\u2002[0,\u20022,\u20023,\u20021])",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002x\u2002=\u2002hbir.resize2d(",(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002x,\u2002step,\u2002initial_offset,\u2002mode,\u2002size=output_shape[2:],\u2002expansionMode="border"',(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002x\u2002=\u2002hbir.transpose(x,\u2002[0,\u20023,\u20021,\u20022],\u2002output_type=y)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002x"]}),(0,t.jsx)("td",{children:"hbir.resize2d"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"input:"}),(0,t.jsx)("br",{}),"Type: int8",(0,t.jsx)("br",{}),"Shape: [*,H,W,C]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as input",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{children:"hbir.transpose"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"input:"}),(0,t.jsx)("br",{}),"No limits",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as input",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"Round"}),(0,t.jsx)("td",{rowSpan:"1",children:"The operator is converted into a look-up-table operator"}),(0,t.jsx)("td",{rowSpan:"1",children:"HzLut"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset\u20029",(0,t.jsx)("br",{}),"func.func\u2002@HzLut(...)\u2002{",(0,t.jsx)("br",{}),"\u2002\u2002return\u2002b30.lut(...)",(0,t.jsx)("br",{}),"}"]}),(0,t.jsx)("td",{children:"b30.lut"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"inputs:"}),(0,t.jsx)("br",{}),"Type: int8, int16",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"outputs:"}),(0,t.jsx)("br",{}),"If input is int8, output is int8",(0,t.jsx)("br",{}),"If input is int16, output is int8/int16",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"Selu"}),(0,t.jsx)("td",{rowSpan:"1",children:"The operator is converted into a look-up-table operator"}),(0,t.jsx)("td",{rowSpan:"1",children:"HzLut"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset\u20029",(0,t.jsx)("br",{}),"func.func\u2002@HzLut(...)\u2002{",(0,t.jsx)("br",{}),"\u2002\u2002return\u2002b30.lut(...)",(0,t.jsx)("br",{}),"}"]}),(0,t.jsx)("td",{children:"b30.lut"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"inputs:"}),(0,t.jsx)("br",{}),"Type: int8, int16",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"outputs:"}),(0,t.jsx)("br",{}),"If input is int8, output is int8",(0,t.jsx)("br",{}),"If input is int16, output is int8/int16",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"Sigmoid"}),(0,t.jsx)("td",{rowSpan:"1",children:"The operator is converted into a look-up-table operator"}),(0,t.jsx)("td",{rowSpan:"1",children:"HzLut"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset\u20029",(0,t.jsx)("br",{}),"func.func\u2002@HzLut(...)\u2002{",(0,t.jsx)("br",{}),"\u2002\u2002return\u2002b30.lut(...)",(0,t.jsx)("br",{}),"}"]}),(0,t.jsx)("td",{children:"b30.lut"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"inputs:"}),(0,t.jsx)("br",{}),"Type: int8, int16",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"outputs:"}),(0,t.jsx)("br",{}),"If input is int8, output is int8",(0,t.jsx)("br",{}),"If input is int16, output is int8/int16",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"Sign"}),(0,t.jsx)("td",{rowSpan:"1",children:"The operator is converted into a look-up-table operator"}),(0,t.jsx)("td",{rowSpan:"1",children:"HzLut"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset\u20029",(0,t.jsx)("br",{}),"func.func\u2002@HzLut(...)\u2002{",(0,t.jsx)("br",{}),"\u2002\u2002return\u2002b30.lut(...)",(0,t.jsx)("br",{}),"}"]}),(0,t.jsx)("td",{children:"b30.lut"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"inputs:"}),(0,t.jsx)("br",{}),"Type: int8, int16",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"outputs:"}),(0,t.jsx)("br",{}),"If input is int8, output is int8",(0,t.jsx)("br",{}),"If input is int16, output is int8/int16",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"Sin"}),(0,t.jsx)("td",{rowSpan:"1",children:"The operator is converted into a look-up-table operator"}),(0,t.jsx)("td",{rowSpan:"1",children:"HzLut"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset\u20029",(0,t.jsx)("br",{}),"func.func\u2002@HzLut(...)\u2002{",(0,t.jsx)("br",{}),"\u2002\u2002return\u2002b30.lut(...)",(0,t.jsx)("br",{}),"}"]}),(0,t.jsx)("td",{children:"b30.lut"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"inputs:"}),(0,t.jsx)("br",{}),"Type: int8, int16",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"outputs:"}),(0,t.jsx)("br",{}),"If input is int8, output is int8",(0,t.jsx)("br",{}),"If input is int16, output is int8/int16",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"Sinh"}),(0,t.jsx)("td",{rowSpan:"1",children:"The operator is converted into a look-up-table operator"}),(0,t.jsx)("td",{rowSpan:"1",children:"HzLut"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset\u20029",(0,t.jsx)("br",{}),"func.func\u2002@HzLut(...)\u2002{",(0,t.jsx)("br",{}),"\u2002\u2002return\u2002b30.lut(...)",(0,t.jsx)("br",{}),"}"]}),(0,t.jsx)("td",{children:"b30.lut"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"inputs:"}),(0,t.jsx)("br",{}),"Type: int8, int16",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"outputs:"}),(0,t.jsx)("br",{}),"If input is int8, output is int8",(0,t.jsx)("br",{}),"If input is int16, output is int8/int16",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"2",children:"Slice"}),(0,t.jsx)("td",{rowSpan:"2",children:"None"}),(0,t.jsx)("td",{rowSpan:"2",children:"Slice"}),(0,t.jsxs)("td",{rowSpan:"2",children:["//opset9",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002adaptor:\u2002NodeAdaptor,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002y:\u2002mlir.Type,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002data:\u2002mlir.Value,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002starts:\u2002mlir.Value,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002ends:\u2002mlir.Value,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002axes:\u2002Optional[mlir.Value]\u2002=\u2002None,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002steps:\u2002Optional[mlir.Value]\u2002=\u2002None,",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002input_shape\u2002=\u2002adaptor.operands[0].type.shape",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002input_rank\u2002=\u2002len(input_shape)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002starts\u2002=\u2002adaptor.operands[1].value",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002ends\u2002=\u2002adaptor.operands[2].value",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002steps\u2002=\u2002(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002np.ones(input_rank,\u2002dtype=np.int64)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002if\u2002steps\u2002is\u2002None",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002else\u2002adaptor.operands[3].value",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002if\u2002axes\u2002is\u2002None",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002else\u2002adaptor.operands[4].value",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002axes\u2002=\u2002(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002[i\u2002for\u2002i\u2002in\u2002range(input_rank)]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002if\u2002axes\u2002is\u2002None",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002else\u2002adaptor.operands[3].value",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002)",(0,t.jsx)("br",{}),(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002assert\u2002len(starts)\u2002==\u2002len(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002ends",(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002),\u2002"Incompatible\u2002attributes\u2002starts\u2002and\u2002ends\u2002for\u2002Slice."',(0,t.jsx)("br",{}),(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002new_start\u2002=\u2002np.zeros(input_rank,\u2002dtype=np.int64)\u2002\u2002#\u2002start\u2002from\u2002zero",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002new_end\u2002=\u2002np.array(input_shape)\u2002\u2002#\u2002end\u2002with\u2002original\u2002shape\u2002limit",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002new_step\u2002=\u2002np.ones(input_rank,\u2002dtype=np.int64)\u2002\u2002#\u2002step\u2002default\u20021",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002if\u2002len(starts)\u2002==\u2002len(axes):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002for\u2002idx,\u2002axis\u2002in\u2002enumerate(axes):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002new_start[axis]\u2002=\u2002starts[idx]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002new_end[axis]\u2002=\u2002ends[idx]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002new_step[axis]\u2002=\u2002steps[idx]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002elif\u2002len(starts)\u2002==\u20021:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002for\u2002index\u2002in\u2002range(input_rank):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002if\u2002index\u2002in\u2002axes:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002new_start[index]\u2002=\u2002starts[0]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002new_end[index]\u2002=\u2002ends[0]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002new_step[index]\u2002=\u2002steps[0]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002else:",(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002raise\u2002ValueError("Incompatible\u2002attributes\u2002starts\u2002and\u2002axes\u2002for\u2002Slice.")',(0,t.jsx)("br",{}),(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.slice(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002data,\u2002begin=new_start,\u2002end=new_end,\u2002step=new_step,\u2002output_type=y",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002)",(0,t.jsx)("br",{}),"//opset10",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002adaptor:\u2002NodeAdaptor,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002y:\u2002mlir.Type,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002data:\u2002mlir.Value,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002starts:\u2002mlir.Value,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002ends:\u2002mlir.Value,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002axes:\u2002Optional[mlir.Value]\u2002=\u2002None,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002steps:\u2002Optional[mlir.Value]\u2002=\u2002None,",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002input_shape\u2002=\u2002adaptor.operands[0].type.shape",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002input_rank\u2002=\u2002len(input_shape)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002starts\u2002=\u2002adaptor.operands[1].value",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002ends\u2002=\u2002adaptor.operands[2].value",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002steps\u2002=\u2002(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002np.ones(input_rank,\u2002dtype=np.int64)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002if\u2002steps\u2002is\u2002None",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002else\u2002adaptor.operands[3].value",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002if\u2002axes\u2002is\u2002None",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002else\u2002adaptor.operands[4].value",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002axes\u2002=\u2002(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002[i\u2002for\u2002i\u2002in\u2002range(input_rank)]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002if\u2002axes\u2002is\u2002None",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002else\u2002adaptor.operands[3].value",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002)",(0,t.jsx)("br",{}),(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002assert\u2002len(starts)\u2002==\u2002len(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002ends",(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002),\u2002"Incompatible\u2002attributes\u2002starts\u2002and\u2002ends\u2002for\u2002Slice."',(0,t.jsx)("br",{}),(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002new_start\u2002=\u2002np.zeros(input_rank,\u2002dtype=np.int64)\u2002\u2002#\u2002start\u2002from\u2002zero",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002new_end\u2002=\u2002np.array(input_shape)\u2002\u2002#\u2002end\u2002with\u2002original\u2002shape\u2002limit",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002new_step\u2002=\u2002np.ones(input_rank,\u2002dtype=np.int64)\u2002\u2002#\u2002step\u2002default\u20021",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002if\u2002len(starts)\u2002==\u2002len(axes):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002for\u2002idx,\u2002axis\u2002in\u2002enumerate(axes):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002new_start[axis]\u2002=\u2002starts[idx]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002new_end[axis]\u2002=\u2002ends[idx]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002new_step[axis]\u2002=\u2002steps[idx]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002elif\u2002len(starts)\u2002==\u20021:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002for\u2002index\u2002in\u2002range(input_rank):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002if\u2002index\u2002in\u2002axes:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002new_start[index]\u2002=\u2002starts[0]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002new_end[index]\u2002=\u2002ends[0]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002new_step[index]\u2002=\u2002steps[0]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002else:",(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002raise\u2002ValueError("Incompatible\u2002attributes\u2002starts\u2002and\u2002axes\u2002for\u2002Slice.")',(0,t.jsx)("br",{}),(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002#\u2002torch2onnx,\u2002axes\u2002is\u2002all\u2002-1.\u2002need\u2002transpose\u2002to\u2002hbir",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002if\u2002(steps\u2002==\u2002-1).any():",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002return\u2002hbir.flip(data,\u2002axes)",(0,t.jsx)("br",{}),(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.slice(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002data,\u2002begin=new_start,\u2002end=new_end,\u2002step=new_step,\u2002output_type=y",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002)",(0,t.jsx)("br",{}),"//opset13",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002adaptor:\u2002NodeAdaptor,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002y:\u2002mlir.Type,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002data:\u2002mlir.Value,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002starts:\u2002mlir.Value,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002ends:\u2002mlir.Value,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002axes:\u2002Optional[mlir.Value]\u2002=\u2002None,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002steps:\u2002Optional[mlir.Value]\u2002=\u2002None,",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002input_shape\u2002=\u2002adaptor.operands[0].type.shape",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002input_rank\u2002=\u2002len(input_shape)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002starts\u2002=\u2002adaptor.operands[1].value",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002ends\u2002=\u2002adaptor.operands[2].value",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002steps\u2002=\u2002(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002np.ones(input_rank,\u2002dtype=np.int64)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002if\u2002steps\u2002is\u2002None",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002else\u2002adaptor.operands[3].value",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002if\u2002axes\u2002is\u2002None",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002else\u2002adaptor.operands[4].value",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002axes\u2002=\u2002(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002[i\u2002for\u2002i\u2002in\u2002range(input_rank)]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002if\u2002axes\u2002is\u2002None",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002else\u2002adaptor.operands[3].value",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002)",(0,t.jsx)("br",{}),(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002assert\u2002len(starts)\u2002==\u2002len(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002ends",(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002),\u2002"Incompatible\u2002attributes\u2002starts\u2002and\u2002ends\u2002for\u2002Slice."',(0,t.jsx)("br",{}),(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002new_start\u2002=\u2002np.zeros(input_rank,\u2002dtype=np.int64)\u2002\u2002#\u2002start\u2002from\u2002zero",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002new_end\u2002=\u2002np.array(input_shape)\u2002\u2002#\u2002end\u2002with\u2002original\u2002shape\u2002limit",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002new_step\u2002=\u2002np.ones(input_rank,\u2002dtype=np.int64)\u2002\u2002#\u2002step\u2002default\u20021",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002if\u2002len(starts)\u2002==\u2002len(axes):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002for\u2002idx,\u2002axis\u2002in\u2002enumerate(axes):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002new_start[axis]\u2002=\u2002starts[idx]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002new_end[axis]\u2002=\u2002ends[idx]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002new_step[axis]\u2002=\u2002steps[idx]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002elif\u2002len(starts)\u2002==\u20021:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002for\u2002index\u2002in\u2002range(input_rank):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002if\u2002index\u2002in\u2002axes:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002new_start[index]\u2002=\u2002starts[0]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002new_end[index]\u2002=\u2002ends[0]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002new_step[index]\u2002=\u2002steps[0]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002else:",(0,t.jsx)("br",{}),'\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002raise\u2002ValueError("Incompatible\u2002attributes\u2002starts\u2002and\u2002axes\u2002for\u2002Slice.")',(0,t.jsx)("br",{}),(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002#\u2002torch2onnx,\u2002axes\u2002is\u2002all\u2002-1",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002if\u2002(steps\u2002==\u2002-1).any():",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002return\u2002hbir.flip(data,\u2002axes)",(0,t.jsx)("br",{}),(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.slice(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002data,\u2002begin=new_start,\u2002end=new_end,\u2002step=new_step,\u2002output_type=y",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002)"]}),(0,t.jsx)("td",{children:"hbir.slice"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"input:"}),(0,t.jsx)("br",{}),"Dim: all dims < 2097152 ",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as input",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{children:"hbir.flip"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"input:"}),(0,t.jsx)("br",{}),"Type: int8",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as input",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"8",children:"Softmax"}),(0,t.jsx)("td",{rowSpan:"8",children:"The operator is splited"}),(0,t.jsx)("td",{rowSpan:"1",children:"Sub"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset9",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,\u2002adaptor:\u2002NodeAdaptor,\u2002y:\u2002mlir.Type,\u2002lhs:\u2002mlir.Value,\u2002rhs:\u2002mlir.Value",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.sub(lhs,\u2002rhs,\u2002output_type=y)"]}),(0,t.jsx)("td",{children:"hbir.sub"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"lhs:"}),(0,t.jsx)("br",{}),"Type: int8, int16",(0,t.jsx)("br",{}),"Shape: [*]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"rhs:"}),(0,t.jsx)("br",{}),"Same as lhs",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as lhs",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"HzLut"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset\u20029",(0,t.jsx)("br",{}),"func.func\u2002@HzLut(...)\u2002{",(0,t.jsx)("br",{}),"\u2002\u2002return\u2002b30.lut(...)",(0,t.jsx)("br",{}),"}"]}),(0,t.jsx)("td",{children:"b30.lut"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"inputs:"}),(0,t.jsx)("br",{}),"Type: int8, int16",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"outputs:"}),(0,t.jsx)("br",{}),"If input is int8, output is int8",(0,t.jsx)("br",{}),"If input is int16, output is int8/int16",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"2",children:"ReduceSum"}),(0,t.jsxs)("td",{rowSpan:"2",children:["//opset9",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002adaptor:\u2002NodeAdaptor,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002y:\u2002mlir.Type,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002x:\u2002mlir.Value,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002*,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002axes=None,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002keepdims=1,",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002if\u2002axes\u2002is\u2002None:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002axes\u2002=\u2002list(range(mlir.ShapedType(x.type).rank))",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.reduce_sum(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002x,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002dims=axes,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002keepDim=bool(keepdims),",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002output_type=y,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002)",(0,t.jsx)("br",{}),"//opset13",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002adaptor:\u2002NodeAdaptor,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002y:\u2002mlir.Type,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002x:\u2002mlir.Value,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002axes=None,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002*args,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002keepdims=1,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002noop_with_empty_axes=0,",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002axes\u2002=\u2002adaptor.operands[1].value.tolist()\u2002if\u2002axes\u2002is\u2002not\u2002None\u2002else\u2002None",(0,t.jsx)("br",{}),(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002if\u2002axes\u2002is\u2002None:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002if\u2002noop_with_empty_axes\u2002==\u20020:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002#\u2002Reduce\u2002all\u2002axes",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002axes\u2002=\u2002list(range(mlir.ShapedType(x.type).rank))",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002else:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002#\u2002act\u2002like\u2002identity\u2002operands,\u2002here\u2002convert\u2002to\u2002reshape",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002return\u2002hbir.reshape(x,\u2002adaptor.operands[0].type.shape)",(0,t.jsx)("br",{}),(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.reduce_sum(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002x,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002dims=axes,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002keepDim=bool(keepdims),",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002output_type=y,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002)"]}),(0,t.jsx)("td",{children:"hbir.reduce_sum"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"input:"}),(0,t.jsx)("br",{}),"Type: int8, int16",(0,t.jsx)("br",{}),"Shape: [*]",(0,t.jsx)("br",{}),"Dim: reduce axis dim size \u2208 [1, 65535]",(0,t.jsx)("br",{}),"Element : reduce Elements size \u2208 [1, 65535]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as input, ReduceArgMax/ReduceArgMin's output can be of type int32 or int64, as long as the size of the reduced axis can be represented using an int16 number",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{children:"hbir.reshape"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"input:"}),(0,t.jsx)("br",{}),"No limits",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as input",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"2",children:"ReduceMax"}),(0,t.jsxs)("td",{rowSpan:"2",children:["//opset9",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002adaptor:\u2002NodeAdaptor,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002y:\u2002mlir.Type,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002x:\u2002mlir.Value,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002*,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002axes=None,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002keepdims=1,",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002if\u2002axes\u2002is\u2002None:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002axes\u2002=\u2002list(range(mlir.ShapedType(x.type).rank))",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.reduce_max(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002x,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002dims=axes,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002keepDim=bool(keepdims),",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002output_type=y,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002)",(0,t.jsx)("br",{}),"//opset18",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002adaptor:\u2002NodeAdaptor,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002y:\u2002mlir.Type,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002x:\u2002mlir.Value,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002*args,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002keepdims=1,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002noop_with_empty_axes=0,",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002axes\u2002=\u2002None",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002if\u2002len(args)\u2002!=\u20020:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002axes\u2002=\u2002adaptor.operands[1].value.tolist()",(0,t.jsx)("br",{}),(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002if\u2002axes\u2002is\u2002None:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002axes\u2002=\u2002[]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002if\u2002noop_with_empty_axes\u2002==\u20020:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002#\u2002Reduce\u2002all\u2002axes",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002axes\u2002=\u2002list(range(mlir.ShapedType(x.type).rank))",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002else:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002#\u2002act\u2002like\u2002identity\u2002operands,\u2002here\u2002convert\u2002to\u2002reshape",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002return\u2002hbir.reshape(x,\u2002adaptor.operands[0].type.shape)",(0,t.jsx)("br",{}),(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002self.mlir_op_func(x,\u2002dims=axes,\u2002keepDim=bool(keepdims),\u2002output_type=y)"]}),(0,t.jsx)("td",{children:"hbir.reduce_max"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"input:"}),(0,t.jsx)("br",{}),"Type: int8, int16",(0,t.jsx)("br",{}),"Shape: [*]",(0,t.jsx)("br",{}),"Dim: reduce axis dim size \u2208 [1, 65535]",(0,t.jsx)("br",{}),"Element : reduce Elements size \u2208 [1, 65535]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as input, ReduceArgMax/ReduceArgMin's output can be of type int32 or int64, as long as the size of the reduced axis can be represented using an int16 number",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{children:"hbir.reshape"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"input:"}),(0,t.jsx)("br",{}),"No limits",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as input",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"Reciprocal"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset9",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002adaptor:\u2002NodeAdaptor,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002y:\u2002mlir.Type,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002x:\u2002mlir.Value,",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.reciprocal(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002x,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002output_type=y,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002)"]}),(0,t.jsx)("td",{children:"hbir.reciprocal"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"input:"}),(0,t.jsx)("br",{}),"Type: int8, int16",(0,t.jsx)("br",{}),"Shape: [*]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as input",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"Mul"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset9",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,\u2002adaptor:\u2002NodeAdaptor,\u2002y:\u2002mlir.Type,\u2002lhs:\u2002mlir.Value,\u2002rhs:\u2002mlir.Value",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.mul(lhs,\u2002rhs,\u2002output_type=y)"]}),(0,t.jsx)("td",{children:"hbir.mul"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"lhs:"}),(0,t.jsx)("br",{}),"Type: int8, int16",(0,t.jsx)("br",{}),"Shape: [*]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"rhs:"}),(0,t.jsx)("br",{}),"Same as lhs",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as lhs",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"Softplus"}),(0,t.jsx)("td",{rowSpan:"1",children:"The operator is converted into a look-up-table operator"}),(0,t.jsx)("td",{rowSpan:"1",children:"HzLut"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset\u20029",(0,t.jsx)("br",{}),"func.func\u2002@HzLut(...)\u2002{",(0,t.jsx)("br",{}),"\u2002\u2002return\u2002b30.lut(...)",(0,t.jsx)("br",{}),"}"]}),(0,t.jsx)("td",{children:"b30.lut"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"inputs:"}),(0,t.jsx)("br",{}),"Type: int8, int16",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"outputs:"}),(0,t.jsx)("br",{}),"If input is int8, output is int8",(0,t.jsx)("br",{}),"If input is int16, output is int8/int16",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"Softsign"}),(0,t.jsx)("td",{rowSpan:"1",children:"The operator is converted into a look-up-table operator"}),(0,t.jsx)("td",{rowSpan:"1",children:"HzLut"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset\u20029",(0,t.jsx)("br",{}),"func.func\u2002@HzLut(...)\u2002{",(0,t.jsx)("br",{}),"\u2002\u2002return\u2002b30.lut(...)",(0,t.jsx)("br",{}),"}"]}),(0,t.jsx)("td",{children:"b30.lut"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"inputs:"}),(0,t.jsx)("br",{}),"Type: int8, int16",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"outputs:"}),(0,t.jsx)("br",{}),"If input is int8, output is int8",(0,t.jsx)("br",{}),"If input is int16, output is int8/int16",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"Split"}),(0,t.jsx)("td",{rowSpan:"1",children:"None"}),(0,t.jsx)("td",{rowSpan:"1",children:"Split"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset9",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,\u2002adaptor:\u2002NodeAdaptor,\u2002y:\u2002mlir.Type,\u2002x:\u2002mlir.Value,\u2002*args,\u2002axis=0,\u2002split",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002ret_list\u2002=\u2002[]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002shape\u2002=\u2002adaptor.operands[0].type.shape",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002dim\u2002=\u2002len(shape)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002axis\u2002=\u2002axis\u2002if\u2002axis\u2002>=\u20020\u2002else\u2002(dim\u2002+\u2002axis)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002asum\u2002=\u20020",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002for\u2002i\u2002in\u2002range(len(split)):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002begin\u2002=\u2002np.array([0\u2002if\u2002i\u2002!=\u2002axis\u2002else\u2002asum\u2002for\u2002i\u2002in\u2002range(dim)])",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002asum\u2002+=\u2002split[i]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002end\u2002=\u2002np.array([shape[i]\u2002if\u2002i\u2002!=\u2002axis\u2002else\u2002asum\u2002for\u2002i\u2002in\u2002range(dim)])",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002step\u2002=\u2002np.ones(shape=dim,\u2002dtype=np.int64)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002output_type\u2002=\u2002y[i]\u2002if\u2002isinstance(y,\u2002list)\u2002else\u2002y",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002ret_list.append(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002hbir.slice(x,\u2002begin=begin,\u2002end=end,\u2002step=step,\u2002output_type=output_type)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002ret_list",(0,t.jsx)("br",{}),"//opset13",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,\u2002adaptor:\u2002NodeAdaptor,\u2002y:\u2002mlir.Type,\u2002x:\u2002mlir.Value,\u2002*args,\u2002axis=0",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002split\u2002=\u2002None",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002if\u2002len(args)\u2002!=\u20020:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002split\u2002=\u2002adaptor.operands[1].value.tolist()",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002#\u2002format:\u2002ele\u2002=\u2002ceil(dim\u2002/\u2002num),\u2002the\u2002last\u2002one\u2002is\u2002dim\u2002-\u2002ele\u2002*\u2002(num\u2002-1)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002#\u2002for\u2002example,\u2002num_outputs\u2002is\u20023,\u2002dim\u2002is\u2002128,\u2002get\u2002split\u2002[43,\u200243,\u200242]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002if\u2002split\u2002is\u2002None:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002split\u2002=\u2002[]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002tmp_shape\u2002=\u2002adaptor.operands[0].type.shape",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002num_outputs\u2002=\u2002len(adaptor.results)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002ele\u2002=\u2002int(math.ceil(tmp_shape[axis]\u2002/\u2002num_outputs))",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002if\u2002tmp_shape[axis]\u2002%\u2002num_outputs\u2002==\u20020:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002split\u2002=\u2002[int(tmp_shape[axis]\u2002/\u2002num_outputs)]\u2002*\u2002num_outputs",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002else:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002split\u2002=\u2002[ele]\u2002*\u2002(num_outputs\u2002-\u20021)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002split.append(tmp_shape[axis]\u2002-\u2002ele\u2002*\u2002(num_outputs\u2002-\u20021))",(0,t.jsx)("br",{}),(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002ret_list\u2002=\u2002[]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002shape\u2002=\u2002adaptor.operands[0].type.shape",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002dim\u2002=\u2002len(shape)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002asum\u2002=\u20020",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002for\u2002i\u2002in\u2002range(len(split)):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002begin\u2002=\u2002np.array([0\u2002if\u2002i\u2002!=\u2002axis\u2002else\u2002asum\u2002for\u2002i\u2002in\u2002range(dim)])",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002asum\u2002+=\u2002split[i]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002end\u2002=\u2002np.array([shape[i]\u2002if\u2002i\u2002!=\u2002axis\u2002else\u2002asum\u2002for\u2002i\u2002in\u2002range(dim)])",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002step\u2002=\u2002np.ones(dim,\u2002dtype=np.int64)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002output_type\u2002=\u2002y[i]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002ret_list.append(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002hbir.slice(x,\u2002begin=begin,\u2002end=end,\u2002step=step,\u2002output_type=output_type)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002ret_list",(0,t.jsx)("br",{}),"//opset18",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002adaptor:\u2002NodeAdaptor,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002y:\u2002mlir.Type,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002x:\u2002mlir.Value,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002*args,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002axis=0,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002num_outputs=0,",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002split\u2002=\u2002None",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002if\u2002len(args)\u2002!=\u20020:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002split\u2002=\u2002adaptor.operands[1].value.tolist()",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002#\u2002format:\u2002ele\u2002=\u2002ceil(dim\u2002/\u2002num),\u2002the\u2002last\u2002one\u2002is\u2002dim\u2002-\u2002ele\u2002*\u2002(num\u2002-1)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002#\u2002for\u2002example,\u2002num_outputs\u2002is\u20023,\u2002dim\u2002is\u2002128,\u2002get\u2002split\u2002[43,\u200243,\u200242]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002if\u2002split\u2002is\u2002None:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002split\u2002=\u2002[]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002tmp_shape\u2002=\u2002adaptor.operands[0].type.shape",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002ele\u2002=\u2002int(math.ceil(tmp_shape[axis]\u2002/\u2002num_outputs))",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002if\u2002tmp_shape[axis]\u2002%\u2002num_outputs\u2002==\u20020:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002split\u2002=\u2002[int(tmp_shape[axis]\u2002/\u2002num_outputs)]\u2002*\u2002num_outputs",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002else:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002split\u2002=\u2002[ele]\u2002*\u2002(num_outputs\u2002-\u20021)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002split.append(tmp_shape[axis]\u2002-\u2002ele\u2002*\u2002(num_outputs\u2002-\u20021))",(0,t.jsx)("br",{}),(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002ret_list\u2002=\u2002[]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002shape\u2002=\u2002adaptor.operands[0].type.shape",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002dim\u2002=\u2002len(shape)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002asum\u2002=\u20020",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002for\u2002i\u2002in\u2002range(len(split)):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002begin\u2002=\u2002np.array([0\u2002if\u2002i\u2002!=\u2002axis\u2002else\u2002asum\u2002for\u2002i\u2002in\u2002range(dim)])",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002asum\u2002+=\u2002split[i]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002end\u2002=\u2002np.array([shape[i]\u2002if\u2002i\u2002!=\u2002axis\u2002else\u2002asum\u2002for\u2002i\u2002in\u2002range(dim)])",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002step\u2002=\u2002np.ones(dim,\u2002dtype=np.int64)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002output_type\u2002=\u2002y[i]\u2002if\u2002isinstance(y,\u2002list)\u2002else\u2002y",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002ret_list.append(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002hbir.slice(x,\u2002begin=begin,\u2002end=end,\u2002step=step,\u2002output_type=output_type)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002ret_list"]}),(0,t.jsx)("td",{children:"hbir.slice"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"input:"}),(0,t.jsx)("br",{}),"Dim: all dims < 2097152 ",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as input",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"Sqrt"}),(0,t.jsx)("td",{rowSpan:"1",children:"The operator is converted into a look-up-table operator"}),(0,t.jsx)("td",{rowSpan:"1",children:"HzLut"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset\u20029",(0,t.jsx)("br",{}),"func.func\u2002@HzLut(...)\u2002{",(0,t.jsx)("br",{}),"\u2002\u2002return\u2002b30.lut(...)",(0,t.jsx)("br",{}),"}"]}),(0,t.jsx)("td",{children:"b30.lut"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"inputs:"}),(0,t.jsx)("br",{}),"Type: int8, int16",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"outputs:"}),(0,t.jsx)("br",{}),"If input is int8, output is int8",(0,t.jsx)("br",{}),"If input is int16, output is int8/int16",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"Squeeze"}),(0,t.jsx)("td",{rowSpan:"1",children:"The operator is replaced"}),(0,t.jsx)("td",{rowSpan:"1",children:"Reshape"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset9",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,\u2002adaptor:\u2002NodeAdaptor,\u2002y:\u2002mlir.Type,\u2002x:\u2002mlir.Value,\u2002shape:\u2002mlir.Value",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002out_shape\u2002=\u2002adaptor.results[0].type.shape",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.reshape(x,\u2002out_shape)",(0,t.jsx)("br",{}),"//opset18",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002adaptor:\u2002NodeAdaptor,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002y:\u2002mlir.Type,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002x:\u2002mlir.Value,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002shape:\u2002mlir.Value,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002*,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002allowzero=0,",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002input_shape\u2002=\u2002adaptor.operands[0].type.shape",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002out_shape\u2002=\u2002adaptor.results[0].type.shape",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002new_shape\u2002=\u2002np.copy(out_shape)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002if\u2002allowzero\u2002==\u20020:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002zeros_index\u2002=\u2002np.where(out_shape\u2002==\u20020)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002new_shape[zeros_index]\u2002=\u2002np.array(object=input_shape)[zeros_index]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.reshape(x,\u2002shape=new_shape)"]}),(0,t.jsx)("td",{children:"hbir.reshape"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"input:"}),(0,t.jsx)("br",{}),"No limits",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as input",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"Sub"}),(0,t.jsx)("td",{rowSpan:"1",children:"None"}),(0,t.jsx)("td",{rowSpan:"1",children:"Sub"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset9",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,\u2002adaptor:\u2002NodeAdaptor,\u2002y:\u2002mlir.Type,\u2002lhs:\u2002mlir.Value,\u2002rhs:\u2002mlir.Value",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.sub(lhs,\u2002rhs,\u2002output_type=y)"]}),(0,t.jsx)("td",{children:"hbir.sub"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"lhs:"}),(0,t.jsx)("br",{}),"Type: int8, int16",(0,t.jsx)("br",{}),"Shape: [*]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"rhs:"}),(0,t.jsx)("br",{}),"Same as lhs",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as lhs",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"Sum"}),(0,t.jsx)("td",{rowSpan:"1",children:"The operator is replaced"}),(0,t.jsx)("td",{rowSpan:"1",children:"Add"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset9",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,\u2002adaptor:\u2002NodeAdaptor,\u2002y:\u2002mlir.Type,\u2002lhs:\u2002mlir.Value,\u2002rhs:\u2002mlir.Value",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.add(lhs,\u2002rhs,\u2002output_type=y)"]}),(0,t.jsx)("td",{children:"hbir.add"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"lhs:"}),(0,t.jsx)("br",{}),"Type: int8, int16, int32, if type is int32, this hbir.add op must be fusible to a Conv op",(0,t.jsx)("br",{}),"Shape: [*]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"rhs:"}),(0,t.jsx)("br",{}),"Same as lhs",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as lhs",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"Tan"}),(0,t.jsx)("td",{rowSpan:"1",children:"The operator is converted into a look-up-table operator"}),(0,t.jsx)("td",{rowSpan:"1",children:"HzLut"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset\u20029",(0,t.jsx)("br",{}),"func.func\u2002@HzLut(...)\u2002{",(0,t.jsx)("br",{}),"\u2002\u2002return\u2002b30.lut(...)",(0,t.jsx)("br",{}),"}"]}),(0,t.jsx)("td",{children:"b30.lut"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"inputs:"}),(0,t.jsx)("br",{}),"Type: int8, int16",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"outputs:"}),(0,t.jsx)("br",{}),"If input is int8, output is int8",(0,t.jsx)("br",{}),"If input is int16, output is int8/int16",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"Tanh"}),(0,t.jsx)("td",{rowSpan:"1",children:"The operator is converted into a look-up-table operator"}),(0,t.jsx)("td",{rowSpan:"1",children:"HzLut"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset\u20029",(0,t.jsx)("br",{}),"func.func\u2002@HzLut(...)\u2002{",(0,t.jsx)("br",{}),"\u2002\u2002return\u2002b30.lut(...)",(0,t.jsx)("br",{}),"}"]}),(0,t.jsx)("td",{children:"b30.lut"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"inputs:"}),(0,t.jsx)("br",{}),"Type: int8, int16",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"outputs:"}),(0,t.jsx)("br",{}),"If input is int8, output is int8",(0,t.jsx)("br",{}),"If input is int16, output is int8/int16",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"ThresholdedRelu"}),(0,t.jsx)("td",{rowSpan:"1",children:"The operator is converted into a look-up-table operator"}),(0,t.jsx)("td",{rowSpan:"1",children:"HzLut"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset\u20029",(0,t.jsx)("br",{}),"func.func\u2002@HzLut(...)\u2002{",(0,t.jsx)("br",{}),"\u2002\u2002return\u2002b30.lut(...)",(0,t.jsx)("br",{}),"}"]}),(0,t.jsx)("td",{children:"b30.lut"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"inputs:"}),(0,t.jsx)("br",{}),"Type: int8, int16",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"outputs:"}),(0,t.jsx)("br",{}),"If input is int8, output is int8",(0,t.jsx)("br",{}),"If input is int16, output is int8/int16",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"Tile"}),(0,t.jsx)("td",{rowSpan:"1",children:"None"}),(0,t.jsx)("td",{rowSpan:"1",children:"Tile"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset9",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002adaptor:\u2002NodeAdaptor,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002y:\u2002mlir.Type,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002data:\u2002mlir.Value,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002repeats:\u2002mlir.Value,",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002repeats\u2002=\u2002adaptor.operands[1].value",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.tile(data,\u2002repeats,\u2002output_type=y)"]}),(0,t.jsx)("td",{children:"hbir.tile"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"input:"}),(0,t.jsx)("br",{}),"No limits",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as input",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"Transpose"}),(0,t.jsx)("td",{rowSpan:"1",children:"None"}),(0,t.jsx)("td",{rowSpan:"1",children:"Transpose"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset9",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(self,\u2002adaptor:\u2002NodeAdaptor,\u2002y:\u2002mlir.Type,\u2002x:\u2002mlir.Value,\u2002perm):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.transpose(x,\u2002perm,\u2002output_type=y)"]}),(0,t.jsx)("td",{children:"hbir.transpose"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"input:"}),(0,t.jsx)("br",{}),"No limits",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as input",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"Trilu"}),(0,t.jsx)("td",{rowSpan:"1",children:"None"}),(0,t.jsx)("td",{rowSpan:"1",children:"Trilu"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset13",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002adaptor:\u2002NodeAdaptor,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002y:\u2002mlir.Type,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002x:\u2002mlir.Value,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002*args,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002upper=1,",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002k\u2002=\u20020",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002if\u2002len(args)\u2002!=\u20020:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002k\u2002=\u2002adaptor.operands[1].value",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002shape\u2002=\u2002adaptor.operands[0].type.shape",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002matrix\u2002=\u2002[]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002if\u2002upper\u2002==\u20021:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002matrix\u2002=\u2002np.triu(np.ones(shape),\u2002k)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002else:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002matrix\u2002=\u2002np.tril(np.ones(shape),\u2002k)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.mul(x,\u2002matrix)"]}),(0,t.jsx)("td",{children:"hbir.mul"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"lhs:"}),(0,t.jsx)("br",{}),"Type: int8, int16",(0,t.jsx)("br",{}),"Shape: [*]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"rhs:"}),(0,t.jsx)("br",{}),"Same as lhs",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as lhs",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"Unsqueeze"}),(0,t.jsx)("td",{rowSpan:"1",children:"The operator is replaced"}),(0,t.jsx)("td",{rowSpan:"1",children:"Reshape"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset9",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,\u2002adaptor:\u2002NodeAdaptor,\u2002y:\u2002mlir.Type,\u2002x:\u2002mlir.Value,\u2002shape:\u2002mlir.Value",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002out_shape\u2002=\u2002adaptor.results[0].type.shape",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.reshape(x,\u2002out_shape)",(0,t.jsx)("br",{}),"//opset18",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002adaptor:\u2002NodeAdaptor,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002y:\u2002mlir.Type,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002x:\u2002mlir.Value,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002shape:\u2002mlir.Value,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002*,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002allowzero=0,",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002input_shape\u2002=\u2002adaptor.operands[0].type.shape",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002out_shape\u2002=\u2002adaptor.results[0].type.shape",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002new_shape\u2002=\u2002np.copy(out_shape)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002if\u2002allowzero\u2002==\u20020:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002zeros_index\u2002=\u2002np.where(out_shape\u2002==\u20020)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002new_shape[zeros_index]\u2002=\u2002np.array(object=input_shape)[zeros_index]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.reshape(x,\u2002shape=new_shape)"]}),(0,t.jsx)("td",{children:"hbir.reshape"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"input:"}),(0,t.jsx)("br",{}),"No limits",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as input",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"Upsample"}),(0,t.jsx)("td",{rowSpan:"1",children:"The operator is replaced"}),(0,t.jsx)("td",{rowSpan:"1",children:"Reshape"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset9",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,\u2002adaptor:\u2002NodeAdaptor,\u2002y:\u2002mlir.Type,\u2002x:\u2002mlir.Value,\u2002shape:\u2002mlir.Value",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002out_shape\u2002=\u2002adaptor.results[0].type.shape",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.reshape(x,\u2002out_shape)",(0,t.jsx)("br",{}),"//opset18",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002adaptor:\u2002NodeAdaptor,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002y:\u2002mlir.Type,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002x:\u2002mlir.Value,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002shape:\u2002mlir.Value,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002*,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002allowzero=0,",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002input_shape\u2002=\u2002adaptor.operands[0].type.shape",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002out_shape\u2002=\u2002adaptor.results[0].type.shape",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002new_shape\u2002=\u2002np.copy(out_shape)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002if\u2002allowzero\u2002==\u20020:",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002zeros_index\u2002=\u2002np.where(out_shape\u2002==\u20020)",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002new_shape[zeros_index]\u2002=\u2002np.array(object=input_shape)[zeros_index]",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.reshape(x,\u2002shape=new_shape)"]}),(0,t.jsx)("td",{children:"hbir.reshape"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"input:"}),(0,t.jsx)("br",{}),"No limits",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as input",(0,t.jsx)("br",{})]})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowSpan:"1",children:"Where"}),(0,t.jsx)("td",{rowSpan:"1",children:"None"}),(0,t.jsx)("td",{rowSpan:"1",children:"Where"}),(0,t.jsxs)("td",{rowSpan:"1",children:["//opset9",(0,t.jsx)("br",{}),"def\u2002emit_mlir_op(",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002self,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002adaptor:\u2002NodeAdaptor,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002y:\u2002mlir.Type,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002condition:\u2002mlir.Value,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002X:\u2002mlir.Value,",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002Y:\u2002mlir.Value,",(0,t.jsx)("br",{}),"):",(0,t.jsx)("br",{}),"\u2002\u2002\u2002\u2002return\u2002hbir.where(condition,\u2002X,\u2002Y,\u2002output_type=y)"]}),(0,t.jsx)("td",{children:"hbir.where"}),(0,t.jsxs)("td",{children:[(0,t.jsx)("b",{children:"condition:"}),(0,t.jsx)("br",{}),"Type: bool8",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"lhs:"}),(0,t.jsx)("br",{}),"Type: int8, int16",(0,t.jsx)("br",{}),"Shape: [*]",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"rhs:"}),(0,t.jsx)("br",{}),"Type: int8, int16",(0,t.jsx)("br",{}),(0,t.jsx)("b",{children:"output:"}),(0,t.jsx)("br",{}),"Same as lhs",(0,t.jsx)("br",{})]})]})]})]})})]})}function j(){let r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:s}=Object.assign({},(0,i.ah)(),r.components);return s?(0,t.jsx)(s,Object.assign({},r,{children:(0,t.jsx)(n,r)})):n(r)}s.default=j,j.__RSPRESS_PAGE_META={},j.__RSPRESS_PAGE_META["3.0.22%2Fen%2Fguide%2Fappendix%2Fsupported_op_list%2Fonnx_operator_support_list_html.mdx"]={toc:[],title:"",frontmatter:{}}},95895:function(r,s,e){e(39710);var t=e(85893),i=e(67294),x=e(45687);e(20388);let n={"zh-CN":r=>`\u{9884}\u{8BA1}\u{9605}\u{8BFB}\u{65F6}\u{95F4}: ${r.minutes>=1?`${Math.ceil(r.minutes)} \u{5206}\u{949F}`:"\u5C0F\u4E8E 1 \u5206\u949F"}`,"en-US":r=>`Estimated reading time: ${r.minutes>=1?`${Math.ceil(r.minutes)} minutes`:"less than 1 minute"}`};function j(r,s,e){let t=Object.keys(n).includes(s)?s:e;return n[t](r)}s.Z=r=>{let{defaultLocale:s="en-US"}=r,e=(0,x.Vi)().page.readingTimeData,n=(0,x.Jr)(),b=(0,x.e7)(),[a,p]=(0,i.useState)(j(e,n,s));return(0,i.useEffect)(()=>{p(j(e,n,s))},[n,e]),(0,t.jsx)("span",{"data-dark":String(b),className:"rp-reading-time",children:a})}}}]);