"use strict";(self.webpackChunkrspress_doc_template=self.webpackChunkrspress_doc_template||[]).push([["9774"],{56990:function(e,t,n){e.exports=n.p+"static/image/qat_ptq_contrast.0ec33c90.png"},99152:function(e,t,n){n.r(t);var i=n(85893),a=n(50065),r=n(95895),s=n(56990);function o(e){let t=Object.assign({h1:"h1",a:"a",p:"p",strong:"strong"},(0,a.ah)(),e.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(t.h1,{id:"ptq-and-qat-introduction",children:[(0,i.jsx)(t.a,{className:"header-anchor","aria-hidden":"true",href:"#ptq-and-qat-introduction",children:"#"}),"PTQ and QAT Introduction"]}),"\n",(0,i.jsx)(r.Z,{}),"\n",(0,i.jsx)(t.p,{children:"According to whether to adjust the parameters after quantization, we can classify the quantization methods into Quantization-aware Training (QAT) and Post-training Quantization (PTQ)."}),"\n",(0,i.jsx)(t.p,{children:"The difference in operations between these two methods is shown in the following diagram (Left: PTQ; Right: QAT)."}),"\n",(0,i.jsx)("img",{src:s,width:"860"}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.strong,{children:"PTQ"})," uses a batch of calibration data to calibrate the trained model, converting the trained FP32 model directly into a fixed-point computational model without any training of the original model.\r\nOnly a few hyperparameters are adjusted to complete the quantization process, and the process is simple and fast, no training is required, so this method has been widely used in a large number of end-side and cloud-side deployment scenarios, ",(0,i.jsx)(t.strong,{children:"we recommend trying the PTQ method first to see if it meets your deployment accuracy and performance requirements"})," ."]}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.strong,{children:"QAT"})," is to quantize the trained model and then retrain it again. Since fixed-point values cannot be used for backward gradient calculation, the actual procedure is to insert fake quantization nodes in front of some ops to obtain the truncated values of the data flowing through this op during training, which can be easily used when quantizing the nodes during the deployment of the quantization model.\r\nWe need to obtain the best quantization parameters by continuously optimizing the accuracy during the training. As model training is involved, it requires higher level of skills for the developers."]})]})}function d(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:t}=Object.assign({},(0,a.ah)(),e.components);return t?(0,i.jsx)(t,Object.assign({},e,{children:(0,i.jsx)(o,e)})):o(e)}t.default=d,d.__RSPRESS_PAGE_META={},d.__RSPRESS_PAGE_META["3.0.22%2Fen%2Fguide%2Ffaststart%2Fptq_qat_overview.mdx"]={toc:[],title:"PTQ and QAT Introduction",frontmatter:{}}},95895:function(e,t,n){n(39710);var i=n(85893),a=n(67294),r=n(45687);n(20388);let s={"zh-CN":e=>`\u{9884}\u{8BA1}\u{9605}\u{8BFB}\u{65F6}\u{95F4}: ${e.minutes>=1?`${Math.ceil(e.minutes)} \u{5206}\u{949F}`:"\u5C0F\u4E8E 1 \u5206\u949F"}`,"en-US":e=>`Estimated reading time: ${e.minutes>=1?`${Math.ceil(e.minutes)} minutes`:"less than 1 minute"}`};function o(e,t,n){let i=Object.keys(s).includes(t)?t:n;return s[i](e)}t.Z=e=>{let{defaultLocale:t="en-US"}=e,n=(0,r.Vi)().page.readingTimeData,s=(0,r.Jr)(),d=(0,r.e7)(),[c,h]=(0,a.useState)(o(n,s,t));return(0,a.useEffect)(()=>{h(o(n,s,t))},[s,n]),(0,i.jsx)("span",{"data-dark":String(d),className:"rp-reading-time",children:c})}}}]);