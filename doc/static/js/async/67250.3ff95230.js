"use strict";(self.webpackChunkrspress_doc_template=self.webpackChunkrspress_doc_template||[]).push([["67250"],{57815:function(e,t,n){e.exports=n.p+"static/image/data_distribution.8e7ea985.png"},89342:function(e,t,n){n.r(t);var i=n(85893),a=n(50065),o=n(95895),r=n(57815);function s(e){let t=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",ol:"ol",li:"li",img:"img"},(0,a.ah)(),e.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(t.h1,{id:"floating-point-model-requirements",children:[(0,i.jsx)(t.a,{className:"header-anchor","aria-hidden":"true",href:"#floating-point-model-requirements",children:"#"}),"Floating-point Model Requirements"]}),"\n",(0,i.jsx)(o.Z,{}),"\n",(0,i.jsxs)(t.h2,{id:"symbolic_trace",children:[(0,i.jsx)(t.a,{className:"header-anchor","aria-hidden":"true",href:"#symbolic_trace",children:"#"}),"symbolic_trace"]}),"\n",(0,i.jsx)(t.p,{children:"Similar to PyTorch's quantized awareness training, our horizon_plugin_pytorch is designed and developed based on fx, and as such, requires that the floating-point model be one that can correctly complete the symbolic_trace."}),"\n",(0,i.jsxs)(t.h2,{id:"only-partial-operators-are-supported",children:[(0,i.jsx)(t.a,{className:"header-anchor","aria-hidden":"true",href:"#only-partial-operators-are-supported",children:"#"}),"Only Partial Operators are Supported"]}),"\n",(0,i.jsx)(t.p,{children:"Since the BPU only supports partial operators, horizon_plugin_pytorch only supports operators in the operator list and special operators that are specifically defined internally based on BPU limitations."}),"\n",(0,i.jsxs)(t.h2,{id:"build-quantization-friendly-model",children:[(0,i.jsx)(t.a,{className:"header-anchor","aria-hidden":"true",href:"#build-quantization-friendly-model",children:"#"}),"Build Quantization Friendly Model"]}),"\n",(0,i.jsx)(t.p,{children:"The process of changing a floating-point model into a fixed-point model has a certain accuracy error. The more quantization-friendly the floating-point model is, the easier it is to improve the qat accuracy, and the higher the accuracy after quantization.\nIn general, there are several situations that can cause a model to become quantization-unfriendly:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"Use operators with accuracy risk. For example: softmax, layernorm, etc. (see op document), these operators are usually realized by table lookup or by multiple op splicing at the bottom, and are prone to dropout problems."}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"Call the same operator multiple times in a forward. If the same operator is called multiple times, the corresponding output distribution is different, but only a set of quantization parameters will be counted, when the output distribution of multiple calls is too different, the quantization error will become larger."}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"There are too many differences in the inputs of add, cat and other multi-input operators, which may cause large errors."}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"The data distribution is not reasonable. plugin adopts uniform symmetric quantization, so the uniform distribution of 0 mean is the best,\nand long tail and outliers should be avoided as much as possible. At the same time, the value range needs to match the quantization bit,\nif you use int8 to quantize the data distributed uniformly as [-1000, 1000], then the accuracy is obviously not enough.\nFor example, the following three distributions, from left to right, the friendliness of quantization decreases, the distribution of most of the values in the model should be the middle of this distribution.\nIn practice, you can use the debug tool to see if the distributions of the model weight and feature map are quantization-friendly.\nBecause of the redundancy of the model, some ops that seem to have very quantization-unfriendly distributions will not significantly reduce the final accuracy of the model,\nand need to be considered in conjunction with the actual difficulty of qat training and the final quantization accuracy achieved."}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"data_distribution",src:r})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"So how can we make the model more quantization-friendly? Specifically:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"Minimize the use of operators with excessive precision risk, see the op documentation for details."}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"Ensure that the output distribution of multiple calls to the shared operator does not vary too much, or split the shared operator to use separately."}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"Avoid large differences in the range of values of different inputs of the multi-input operator."}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"Use int16 to quantize ops with very large value ranges and errors. You can find such ops with the debug tool."}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"Prevent the model from overfitting by increasing the weight decay and adding data enhancement. Overfitting models are prone to large values and are very sensitive to inputs, so a small error can cause the output to be completely wrong."}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"Use BN."}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"Normalize the model inputs with respect to zero symmetry."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Note that qat itself has some adjustment ability, quantization unfriendly doesn't mean it can't be quantized, in many cases, even if the above unsuitable quantization phenomenon occurs, it can still be quantized well.\nSince the above suggestions may also lead to a degradation of the floating-point model accuracy, they should be attempted when the qat accuracy is not achievable, especially suggestions 1 - 5,\nand in the end you should find a balance between the floating-point model accuracy and the quantized model accuracy."})]})}function l(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:t}=Object.assign({},(0,a.ah)(),e.components);return t?(0,i.jsx)(t,Object.assign({},e,{children:(0,i.jsx)(s,e)})):s(e)}t.default=l,l.__RSPRESS_PAGE_META={},l.__RSPRESS_PAGE_META["3.0.22%2Fen%2Fguide%2Fplugin%2Fuser_guide%2Ffloat_model_requirements.mdx"]={toc:[{id:"symbolic_trace",text:"symbolic_trace",depth:2},{id:"only-partial-operators-are-supported",text:"Only Partial Operators are Supported",depth:2},{id:"build-quantization-friendly-model",text:"Build Quantization Friendly Model",depth:2}],title:"Floating-point Model Requirements",frontmatter:{}}},95895:function(e,t,n){n(39710);var i=n(85893),a=n(67294),o=n(45687);n(20388);let r={"zh-CN":e=>`\u{9884}\u{8BA1}\u{9605}\u{8BFB}\u{65F6}\u{95F4}: ${e.minutes>=1?`${Math.ceil(e.minutes)} \u{5206}\u{949F}`:"\u5C0F\u4E8E 1 \u5206\u949F"}`,"en-US":e=>`Estimated reading time: ${e.minutes>=1?`${Math.ceil(e.minutes)} minutes`:"less than 1 minute"}`};function s(e,t,n){let i=Object.keys(r).includes(t)?t:n;return r[i](e)}t.Z=e=>{let{defaultLocale:t="en-US"}=e,n=(0,o.Vi)().page.readingTimeData,r=(0,o.Jr)(),l=(0,o.e7)(),[d,h]=(0,a.useState)(s(n,r,t));return(0,a.useEffect)(()=>{h(s(n,r,t))},[r,n]),(0,i.jsx)("span",{"data-dark":String(l),className:"rp-reading-time",children:d})}}}]);