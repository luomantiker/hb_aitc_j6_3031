"use strict";(self.webpackChunkrspress_doc_template=self.webpackChunkrspress_doc_template||[]).push([["89631"],{76127:function(e,n,t){t.r(n);var i=t(85893),s=t(50065),r=t(95895);function o(e){let n=Object.assign({h1:"h1",a:"a",p:"p",strong:"strong",ul:"ul",li:"li",em:"em",pre:"pre",code:"code"},(0,s.ah)(),e.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.h1,{id:"onnx",children:[(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#onnx",children:"#"}),"ONNX"]}),"\n",(0,i.jsx)(r.Z,{}),"\n",(0,i.jsx)(n.p,{}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"horizon_plugin_pytorch.utils.onnx_helper.export_to_onnx (model, args, f, export_params=True, verbose=False, training=<TrainingMode.EVAL: 0>, input_names=None, output_names=None, operator_export_type=<OperatorExportTypes.ONNX_FALLTHROUGH: 3>, opset_version=11, do_constant_folding=True, dynamic_axes=None, keep_initializers_as_inputs=None, custom_opsets=None)"})}),"\n",(0,i.jsx)(n.p,{children:"Export a (float or qat)model into ONNX format."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"model"})," ( ",(0,i.jsx)(n.em,{children:"torch.nn.Module/torch.jit.ScriptModule/ScriptFunction"}),") \u2013 the model to be exported."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"args"})," ( ",(0,i.jsx)(n.em,{children:"tuple"})," ",(0,i.jsx)(n.em,{children:"or"}),"  ",(0,i.jsx)(n.em,{children:"torch.Tensor"}),") \u2013"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{meta:"",children:"args can be structured either as:\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{meta:"",children:"1. ONLY A TUPLE OF ARGUMENTS:\n   ```text\n   args = (x, y, z)\n   ```\n\nThe tuple should contain model inputs such that `model(*args)`\nis a valid invocation of the model. Any non-Tensor arguments will\nbe hard-coded into the exported model; any Tensor arguments will\nbecome inputs of the exported model, in the order they occur in\nthe tuple.\n1. A TENSOR:\n   ```text\n   args = torch.Tensor([1])\n   ```\n\nThis is equivalent to a 1-ary tuple of that Tensor.\n\n3. A TUPLE OF ARGUMENTS ENDING WITH A DICTIONARY OF NAMED\nARGUMENTS:\n```text\nargs = (x,\n        {'y': input_y,\n         'z': input_z})\n```\n\nAll but the last element of the tuple will be passed as non-keyword\narguments, and named arguments will be set from the last element.\nIf a named argument is not present in the dictionary , it is\nassigned the default value, or None if a default value is not\nprovided.\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"f"})," \u2013 a file-like object or a string containing a file name.  A binary\nprotocol buffer will be written to this file."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"export_params"})," ( ",(0,i.jsx)(n.em,{children:"bool"})," ",(0,i.jsx)(n.em,{children:","}),"  ",(0,i.jsx)(n.em,{children:"default True"}),") \u2013 if True, all parameters will\nbe exported."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"verbose"})," ( ",(0,i.jsx)(n.em,{children:"bool"})," ",(0,i.jsx)(n.em,{children:","}),"  ",(0,i.jsx)(n.em,{children:"default False"}),") \u2013 if True, prints a description of the\nmodel being exported to stdout, doc_string will be added to graph.\ndoc_string may contaion mapping of module scope to node name in\nfuture torch onnx."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"training"})," ( ",(0,i.jsx)(n.em,{children:"enum"})," ",(0,i.jsx)(n.em,{children:","}),"  ",(0,i.jsx)(n.em,{children:"default TrainingMode.EVAL"}),") \u2013"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{meta:"",children:"if model.training is False and in training mode if model.training\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{meta:"",children:"is True.\n* `TrainingMode.EVAL`: export the model in inference mode.\n* `TrainingMode.PRESERVE`: export the model in inference mode\n* `TrainingMode.TRAINING`: export the model in training mode.\n  Disables optimizations which might interfere with training.\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"input_names"})," ( ",(0,i.jsx)(n.em,{children:"list"})," ",(0,i.jsx)(n.em,{children:"of"}),"  ",(0,i.jsx)(n.em,{children:"str"})," ",(0,i.jsx)(n.em,{children:","}),"  ",(0,i.jsx)(n.em,{children:"default empty list"}),") \u2013 names to assign to the\ninput nodes of the graph, in order."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"output_names"})," ( ",(0,i.jsx)(n.em,{children:"list"})," ",(0,i.jsx)(n.em,{children:"of"}),"  ",(0,i.jsx)(n.em,{children:"str"})," ",(0,i.jsx)(n.em,{children:","}),"  ",(0,i.jsx)(n.em,{children:"default empty list"}),") \u2013 names to assign to the\noutput nodes of the graph, in order."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"operator_export_type"})," ( ",(0,i.jsx)(n.em,{children:"enum"})," ",(0,i.jsx)(n.em,{children:","}),"  ",(0,i.jsx)(n.em,{children:"default ONNX_FALLTHROUGH"}),") \u2013\n* ",(0,i.jsx)(n.code,{children:"OperatorExportTypes.ONNX"}),": Export all ops as regular ONNX ops\n(in the default opset domain).\n* ",(0,i.jsx)(n.code,{children:"OperatorExportTypes.ONNX_FALLTHROUGH"}),": Try to convert all ops\nto standard ONNX ops in the default opset domain.\n* ",(0,i.jsx)(n.code,{children:"OperatorExportTypes.ONNX_ATEN"}),": All ATen ops (in the\nTorchScript namespace \u201Caten\u201D) are exported as ATen ops.\n* ",(0,i.jsx)(n.code,{children:"OperatorExportTypes.ONNX_ATEN_FALLBACK"}),": Try to export each\nATen op (in the TorchScript namespace \u201Caten\u201D) as a regular ONNX\nop. If we are unable to do so,fall back to exporting an ATen op."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"opset_version"})," ( ",(0,i.jsx)(n.em,{children:"int"})," ",(0,i.jsx)(n.em,{children:","}),"  ",(0,i.jsx)(n.em,{children:"default 11"}),") \u2013 by default we export the model to the\nopset version of the onnx submodule."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"do_constant_folding"})," ( ",(0,i.jsx)(n.em,{children:"bool"})," ",(0,i.jsx)(n.em,{children:","}),"  ",(0,i.jsx)(n.em,{children:"default False"}),") \u2013 Apply the constant-folding\noptimization. Constant-folding will replace some of the ops that\nhave all constant inputs with pre-computed constant nodes."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"dynamic_axes"})," ( ",(0,i.jsx)(n.em,{children:"dict<str"})," ",(0,i.jsx)(n.em,{children:","}),"  ",(0,i.jsx)(n.em,{children:"list"})," ",(0,i.jsx)(n.em,{children:"("})," ",(0,i.jsx)(n.em,{children:"int"})," ",(0,i.jsx)(n.em,{children:")"})," ",(0,i.jsx)(n.em,{children:"/dict<int"})," ",(0,i.jsx)(n.em,{children:","}),"  ",(0,i.jsx)(n.em,{children:"str>>"})," ",(0,i.jsx)(n.em,{children:","}),"  ",(0,i.jsx)(n.em,{children:"default empty dict"}),") \u2013"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{meta:"",children:"By default the exported model will have the shapes of all input\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{meta:"",children:"and output tensors set to exactly match those given in `args`\n(and `example_outputs` when that arg is required). To specify\naxes of tensors as dynamic (i.e. known only at run-time), set\n`dynamic_axes` to a dict with schema:\n* KEY (str): an input or output name. Each name must also be\n  provided in `input_names` or `output_names`.\n* VALUE (dict or list): If a dict, keys are axis indices and\n  values are axis names. If a list, each element is an axis index.\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"keep_initializers_as_inputs"})," ( ",(0,i.jsx)(n.em,{children:"bool"})," ",(0,i.jsx)(n.em,{children:","}),"  ",(0,i.jsx)(n.em,{children:"default None"}),") \u2013 If True, all the\ninitializers (typically corresponding to parameters) in the\nexported graph will also be added as inputs to the graph. If False,\nthen initializers are not added as inputs to the graph, and only\nthe non-parameter inputs are added as inputs.\nThis may allow for better optimizations (e.g. constant folding) by\nbackends/runtimes."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"custom_opsets"})," ( ",(0,i.jsx)(n.em,{children:"dict<str"})," ",(0,i.jsx)(n.em,{children:","}),"  ",(0,i.jsx)(n.em,{children:"int>"})," ",(0,i.jsx)(n.em,{children:","}),"  ",(0,i.jsx)(n.em,{children:"default empty dict"}),") \u2013"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{meta:"",children:"A dict with schema:\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{meta:"",children:"* KEY (str): opset domain name\n* VALUE (int): opset version\n\nIf a custom opset is referenced by `model` but not mentioned in\nthis dictionary, the opset version is set to 1.\n"})})]})}function l(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,i.jsx)(n,Object.assign({},e,{children:(0,i.jsx)(o,e)})):o(e)}n.default=l,l.__RSPRESS_PAGE_META={},l.__RSPRESS_PAGE_META["3.0.22%2Fzh%2Fguide%2Fplugin%2Fplugin_api_reference%2Fonnx.md"]={toc:[],title:"ONNX",frontmatter:{}}},95895:function(e,n,t){t(39710);var i=t(85893),s=t(67294),r=t(45687);t(20388);let o={"zh-CN":e=>`\u{9884}\u{8BA1}\u{9605}\u{8BFB}\u{65F6}\u{95F4}: ${e.minutes>=1?`${Math.ceil(e.minutes)} \u{5206}\u{949F}`:"\u5C0F\u4E8E 1 \u5206\u949F"}`,"en-US":e=>`Estimated reading time: ${e.minutes>=1?`${Math.ceil(e.minutes)} minutes`:"less than 1 minute"}`};function l(e,n,t){let i=Object.keys(o).includes(n)?n:t;return o[i](e)}n.Z=e=>{let{defaultLocale:n="en-US"}=e,t=(0,r.Vi)().page.readingTimeData,o=(0,r.Jr)(),a=(0,r.e7)(),[d,c]=(0,s.useState)(l(t,o,n));return(0,s.useEffect)(()=>{c(l(t,o,n))},[o,t]),(0,i.jsx)("span",{"data-dark":String(a),className:"rp-reading-time",children:d})}}}]);