"use strict";(self.webpackChunkrspress_doc_template=self.webpackChunkrspress_doc_template||[]).push([["65170"],{25577:function(e,n,i){e.exports=i.p+"static/image/engine.59eadeff.png"},80400:function(e,n,i){e.exports=i.p+"static/image/loop.30012061.png"},55425:function(e,n,i){i.r(n);var s=i(85893),r=i(50065),t=i(95895),o=i(80400),a=i(25577);function c(e){let n=Object.assign({h1:"h1",a:"a",p:"p",strong:"strong",code:"code",h2:"h2",ul:"ul",li:"li"},(0,r.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"execution-engine",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#execution-engine",children:"#"}),"Execution Engine"]}),"\n",(0,s.jsx)(t.Z,{}),"\n",(0,s.jsxs)(n.p,{children:["As described in the previous section introducing the framework, all the ",(0,s.jsx)(n.strong,{children:"Data"}),", ",(0,s.jsx)(n.strong,{children:"Model"}),", ",(0,s.jsx)(n.strong,{children:"Callback"})," and other sub-modules will eventually be put into the ",(0,s.jsx)(n.strong,{children:"Engine"})," for execution after being built. As the execution engine of the whole HAT, the Engine has great importance."]}),"\n",(0,s.jsxs)(n.p,{children:["In HAT, Engine defines the entire ",(0,s.jsx)(n.code,{children:"Pipeline"})," for the training and prediction. For any deep-learning project, it is necessary to complete the training and prediction tasks for a given model. Therefore, this section focuses on the implementation of the Engine module in HAT."]}),"\n",(0,s.jsxs)(n.h2,{id:"engines-execution-workflow",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#engines-execution-workflow",children:"#"}),"Engine's Execution Workflow"]}),"\n",(0,s.jsx)("img",{src:o,alt:"Engine Workflow",height:"700",width:"700"}),"\n",(0,s.jsxs)(n.p,{children:["The most basic ",(0,s.jsx)(n.code,{children:"PipeBase"})," of the entire HAT Engine defines all the ",(0,s.jsx)(n.code,{children:"Callbacks"})," operable running phases, while ",(0,s.jsx)(n.code,{children:"LoopBase"})," defines the basic execution flow of all Engines. As shown in the figure above, the entire Engine execution flow is composed of these parts: a variety of ",(0,s.jsx)(n.code,{children:"Callbacks"})," and the processing operations of the ",(0,s.jsx)(n.code,{children:"Processor"})," associated with the model."]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"Callbacks"})," operable running phases include eight phases: ",(0,s.jsx)(n.code,{children:"on_loop_begin"}),", ",(0,s.jsx)(n.code,{children:"on_epoch_begin"}),", ",(0,s.jsx)(n.code,{children:"on_step_begin"}),", ",(0,s.jsx)(n.code,{children:"on_batch_begin"}),", ",(0,s.jsx)(n.code,{children:"on_batch_end"}),", ",(0,s.jsx)(n.code,{children:"on_step_end"}),", ",(0,s.jsx)(n.code,{children:"on_epoch _end"}),", and ",(0,s.jsx)(n.code,{children:"on_loop_end"}),". The execution order is shown in the above figure, and you can use different Callbacks at different stages or use the same Callback at different stages as per their needs. For example, the common ",(0,s.jsx)(n.code,{children:"LrUpdater"})," can be used in both ",(0,s.jsx)(n.code,{children:"on_epoch_begin"})," and ",(0,s.jsx)(n.code,{children:"on_step_begin"})," phases, and similarly, the scope of other parts of the Callback is shown in the figure."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"BatchProcessor"})," is responsible for how data and models in the current ",(0,s.jsx)(n.code,{children:"Batch"})," are run, including basic operations commonly seen in model processing such as ",(0,s.jsx)(n.code,{children:"forward"})," and ",(0,s.jsx)(n.code,{children:"backward"}),". In addition, some of the ",(0,s.jsx)(n.code,{children:"grad"})," update operations are also defined here. Note that some complex training tasks also require ",(0,s.jsx)(n.code,{children:"BatchProcessor"})," to complete more iterations and richer ",(0,s.jsx)(n.code,{children:"grad"})," operations."]}),"\n",(0,s.jsxs)(n.h2,{id:"engine-structure",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#engine-structure",children:"#"}),"Engine Structure"]}),"\n",(0,s.jsx)("img",{src:a,alt:"Engine Inheritance",width:"800"}),"\n",(0,s.jsxs)(n.p,{children:["Based on ",(0,s.jsx)(n.code,{children:"LoopBase"}),", a rich set of execution engines can be derived, as shown in the Engine relationship diagram above."]}),"\n",(0,s.jsxs)(n.p,{children:["From the functional point of view, ",(0,s.jsx)(n.code,{children:"Trainer"})," that focuses on training and ",(0,s.jsx)(n.code,{children:"Predictor"})," that focuses on prediction can be derived from ",(0,s.jsx)(n.code,{children:"LoopBase"}),"."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Trainer: Responsible for all the training-related processes, which are generally needed by deep-learning related training tasks."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Predictor: Responsible for prediction related processes, and is commonly used in scenarios such as ",(0,s.jsx)(n.code,{children:"Validation"}),"."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Depending on the execution method, different training methods can generate different ",(0,s.jsx)(n.code,{children:"Trainer"}),"s, such as ",(0,s.jsx)(n.code,{children:"DistibutedDataParallelTrainer"})," based on ",(0,s.jsx)(n.code,{children:"torch.nn.parallel.DistributedDataParallel"})," and ",(0,s.jsx)(n.code,{children:"DataParallelTrainer"})," based on ",(0,s.jsx)(n.code,{children:"torch.nn.DataParallel"}),", etc. Meanwhile, different execution methods require different launching methods. For related details,  refer to ",(0,s.jsx)(n.code,{children:"launcher"})," in different ",(0,s.jsx)(n.code,{children:"Trainer"}),"s."]})]})}function d(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,r.ah)(),e.components);return n?(0,s.jsx)(n,Object.assign({},e,{children:(0,s.jsx)(c,e)})):c(e)}n.default=d,d.__RSPRESS_PAGE_META={},d.__RSPRESS_PAGE_META["3.0.22%2Fen%2Fguide%2Fadvanced_content%2Fhat%2Fframework%2Fengine.mdx"]={toc:[{id:"engines-execution-workflow",text:"Engine's Execution Workflow",depth:2},{id:"engine-structure",text:"Engine Structure",depth:2}],title:"Execution Engine",frontmatter:{}}},95895:function(e,n,i){i(39710);var s=i(85893),r=i(67294),t=i(45687);i(20388);let o={"zh-CN":e=>`\u{9884}\u{8BA1}\u{9605}\u{8BFB}\u{65F6}\u{95F4}: ${e.minutes>=1?`${Math.ceil(e.minutes)} \u{5206}\u{949F}`:"\u5C0F\u4E8E 1 \u5206\u949F"}`,"en-US":e=>`Estimated reading time: ${e.minutes>=1?`${Math.ceil(e.minutes)} minutes`:"less than 1 minute"}`};function a(e,n,i){let s=Object.keys(o).includes(n)?n:i;return o[s](e)}n.Z=e=>{let{defaultLocale:n="en-US"}=e,i=(0,t.Vi)().page.readingTimeData,o=(0,t.Jr)(),c=(0,t.e7)(),[d,l]=(0,r.useState)(a(i,o,n));return(0,r.useEffect)(()=>{l(a(i,o,n))},[o,i]),(0,s.jsx)("span",{"data-dark":String(c),className:"rp-reading-time",children:d})}}}]);