
# Autogenerated by mlir-tblgen; don't manually edit.
from .._mlir_libs import _hbdk
from ..dialects import b25 as _ods_ext
from .common import get_value_or_create_const
from .common import get_loc_or_create_from_frames
from .common import get_type_or_create_unranked_type
from .common import create_array_attr
from .common import create_attr
from .common import parse_enum
from .common import create_elements_attr


def binary_eltwise(lhs, rhs, mode, roundMode="ROUND", saturate=True, perTensorQuant=False, *, quant_info=None, output_type=None, loc=None):
    """
Binary Element-wise ops for B25

    """
    lhs = get_value_or_create_const(lhs)
    rhs = get_value_or_create_const(rhs)
    quant_info = get_value_or_create_const(quant_info)
    roundMode = parse_enum(roundMode, 'roundMode')
    saturate = create_attr(saturate)
    perTensorQuant = create_attr(perTensorQuant)
    output_type = get_type_or_create_unranked_type(output_type)
    loc = get_loc_or_create_from_frames(loc)
    op = _ods_ext.BinaryEltwiseOp(output_type, lhs, rhs, mode, roundMode=roundMode, saturate=saturate, perTensorQuant=perTensorQuant, quant_info=quant_info, loc=loc)
    _hbdk.infer_type_if_failed_infer_shape(op)
    return op.results[0]


def conv2d(input, weight, quantInfo, kernel, stride=(1, 1), pad=(0, 0, 0, 0), dilation=(1, 1), padValue=0, relu=False, instanceId=-1, processDone="None", *, sumin=None, lutTable=None, groupSize=None, output_type=None, loc=None):
    """
2-D convolution for B25

    """
    input = get_value_or_create_const(input)
    weight = get_value_or_create_const(weight)
    quantInfo = get_value_or_create_const(quantInfo)
    sumin = get_value_or_create_const(sumin)
    lutTable = get_value_or_create_const(lutTable)
    groupSize = create_array_attr(groupSize)
    kernel = create_array_attr(kernel)
    stride = create_array_attr(stride)
    pad = create_array_attr(pad)
    dilation = create_array_attr(dilation)
    padValue = create_attr(padValue)
    relu = create_attr(relu)
    instanceId = create_attr(instanceId)
    output_type = get_type_or_create_unranked_type(output_type)
    loc = get_loc_or_create_from_frames(loc)
    op = _ods_ext.Conv2dOp(output_type, input, weight, quantInfo, kernel, stride=stride, pad=pad, dilation=dilation, padValue=padValue, relu=relu, instanceId=instanceId, processDone=processDone, sumin=sumin, lutTable=lutTable, groupSize=groupSize, loc=loc)
    _hbdk.infer_type_if_failed_infer_shape(op)
    return op.results[0]


def filter(data, score, mergeAxisExceptC, threshold, startCoord=(0, 0), *, partialCount=None, partialData=None, filterData_type=None, loc=None):
    """
Data filter op for b25
Filter data by comparing its correspond score and given threshold
    """
    data = get_value_or_create_const(data)
    score = get_value_or_create_const(score)
    partialCount = get_value_or_create_const(partialCount)
    partialData = get_value_or_create_const(partialData)
    mergeAxisExceptC = create_attr(mergeAxisExceptC)
    threshold = create_attr(threshold)
    startCoord = create_array_attr(startCoord)
    filterData_type = get_type_or_create_unranked_type(filterData_type)
    loc = get_loc_or_create_from_frames(loc)
    op = _ods_ext.FilterOp(filterData_type, data, score, mergeAxisExceptC, threshold, startCoord=startCoord, partialCount=partialCount, partialData=partialData, loc=loc)
    _hbdk.infer_type_if_failed_infer_shape(op)
    return op.results[0]


def gen_quant_info(bias, finType, weightType, foutType, *, weight=None, suminType=None, encode_type=None, loc=None):
    """
generate conv quant info from uniform quantized attrs

    """
    bias = get_value_or_create_const(bias)
    weight = get_value_or_create_const(weight)
    encode_type = get_type_or_create_unranked_type(encode_type)
    loc = get_loc_or_create_from_frames(loc)
    op = _ods_ext.GenQuantInfoOp(encode_type, bias, finType, weightType, foutType, weight=weight, suminType=suminType, loc=loc)
    _hbdk.infer_type_if_failed_infer_shape(op)
    return op.results[0]


def linear(input, weight, quantInfo, *, output_type=None, loc=None):
    """
B25 Linear.
"B25 Linear Operation"
    """
    input = get_value_or_create_const(input)
    weight = get_value_or_create_const(weight)
    quantInfo = get_value_or_create_const(quantInfo)
    output_type = get_type_or_create_unranked_type(output_type)
    loc = get_loc_or_create_from_frames(loc)
    op = _ods_ext.LinearOp(output_type, input, weight, quantInfo, loc=loc)
    _hbdk.infer_type_if_failed_infer_shape(op)
    return op.results[0]


def lut(input, config, symmetricMode="ASYM", roundMode="ROUND", saturate=True, mode="NONE", *, output_type=None, loc=None):
    """
lut for B25

    """
    input = get_value_or_create_const(input)
    config = get_value_or_create_const(config)
    symmetricMode = parse_enum(symmetricMode, 'symmetricMode')
    roundMode = parse_enum(roundMode, 'roundMode')
    saturate = create_attr(saturate)
    mode = parse_enum(mode, 'mode')
    output_type = get_type_or_create_unranked_type(output_type)
    loc = get_loc_or_create_from_frames(loc)
    op = _ods_ext.LutOp(output_type, input, config, symmetricMode=symmetricMode, roundMode=roundMode, saturate=saturate, mode=mode, loc=loc)
    _hbdk.infer_type_if_failed_infer_shape(op)
    return op.results[0]


def matmul(lhs, rhs, quantInfo, *, output_type=None, loc=None):
    """
B25 Matrix Multiplication.

    """
    lhs = get_value_or_create_const(lhs)
    rhs = get_value_or_create_const(rhs)
    quantInfo = get_value_or_create_const(quantInfo)
    output_type = get_type_or_create_unranked_type(output_type)
    loc = get_loc_or_create_from_frames(loc)
    op = _ods_ext.MatMulOp(output_type, lhs, rhs, quantInfo, loc=loc)
    _hbdk.infer_type_if_failed_infer_shape(op)
    return op.results[0]


def move_half(input, *, output_type=None, loc=None):
    """
Drop the second half of each layout block, real data movement occurs.
"Drop the second half of each layout block, real data movement occurs."
    """
    input = get_value_or_create_const(input)
    output_type = get_type_or_create_unranked_type(output_type)
    loc = get_loc_or_create_from_frames(loc)
    op = _ods_ext.MoveHalfOp(output_type, input, loc=loc)
    _hbdk.infer_type_if_failed_infer_shape(op)
    return op.results[0]


def packet(input, mode, maskedValue=0, laneOffset=0, *, offsets=None, sizes=None, strides=None, output_type=None, loc=None):
    """
Compress mode load/store
Load compressed data and Store data in compressed form
    """
    input = get_value_or_create_const(input)
    maskedValue = create_attr(maskedValue)
    laneOffset = create_attr(laneOffset)
    offsets = create_array_attr(offsets)
    sizes = create_array_attr(sizes)
    strides = create_array_attr(strides)
    output_type = get_type_or_create_unranked_type(output_type)
    loc = get_loc_or_create_from_frames(loc)
    op = _ods_ext.PacketOp(output_type, input, mode, maskedValue=maskedValue, laneOffset=laneOffset, offsets=offsets, sizes=sizes, strides=strides, loc=loc)
    _hbdk.infer_type_if_failed_infer_shape(op)
    return op.results[0]


def pool2d(input, kernel, mode, stride=(1, 1), pad=(0, 0, 0, 0), qppActionTypes=(), qppActionParams=(), *, buffer1=None, buffer2=None, output_type=None, loc=None):
    """
2-D pooling for B25

    """
    input = get_value_or_create_const(input)
    buffer1 = get_value_or_create_const(buffer1)
    buffer2 = get_value_or_create_const(buffer2)
    kernel = create_array_attr(kernel)
    stride = create_array_attr(stride)
    pad = create_array_attr(pad)
    qppActionTypes = create_array_attr(qppActionTypes)
    qppActionParams = create_array_attr(qppActionParams)
    output_type = get_type_or_create_unranked_type(output_type)
    loc = get_loc_or_create_from_frames(loc)
    op = _ods_ext.Pool2dOp(output_type, input, kernel, mode, stride=stride, pad=pad, qppActionTypes=qppActionTypes, qppActionParams=qppActionParams, buffer1=buffer1, buffer2=buffer2, loc=loc)
    _hbdk.infer_type_if_failed_infer_shape(op)
    return op.results[0]


def reduce(input, mode, dims, keepDim, qppActionTypes=(), qppActionParams=(), offsetOnReducedAxis=0, *, partialSum=None, output_type=None, loc=None):
    """
reduce ops for B25

    """
    input = get_value_or_create_const(input)
    partialSum = get_value_or_create_const(partialSum)
    dims = create_array_attr(dims)
    keepDim = create_attr(keepDim)
    qppActionTypes = create_array_attr(qppActionTypes)
    qppActionParams = create_array_attr(qppActionParams)
    offsetOnReducedAxis = create_attr(offsetOnReducedAxis)
    output_type = get_type_or_create_unranked_type(output_type)
    loc = get_loc_or_create_from_frames(loc)
    op = _ods_ext.ReduceOp(output_type, input, mode, dims, keepDim, qppActionTypes=qppActionTypes, qppActionParams=qppActionParams, offsetOnReducedAxis=offsetOnReducedAxis, partialSum=partialSum, loc=loc)
    _hbdk.infer_type_if_failed_infer_shape(op)
    return op.results[0]


def resize2d(input, step, initialOffset=(0, 0), mode="bilinear", expansionMode="constant", roundMode="ROUND", *, padValue=None, output_type=None, loc=None):
    """
B25 2-D resizing.
"B25 2-D resizing"
    """
    input = get_value_or_create_const(input)
    step = create_array_attr(step)
    initialOffset = create_array_attr(initialOffset)
    mode = parse_enum(mode, 'mode')
    expansionMode = parse_enum(expansionMode, 'expansionMode')
    roundMode = parse_enum(roundMode, 'roundMode')
    padValue = create_attr(padValue)
    output_type = get_type_or_create_unranked_type(output_type)
    loc = get_loc_or_create_from_frames(loc)
    op = _ods_ext.Resize2dOp(output_type, input, step, initialOffset=initialOffset, mode=mode, expansionMode=expansionMode, roundMode=roundMode, padValue=padValue, loc=loc)
    _hbdk.infer_type_if_failed_infer_shape(op)
    return op.results[0]


def rle(input, *, encodeCount_type=None, encodeData_type=None, loc=None):
    """
Run length encode op for B25
Run length encode along with writing data from L1M to Ddr.
    """
    input = get_value_or_create_const(input)
    encodeCount_type = get_type_or_create_unranked_type(encodeCount_type)
    encodeData_type = get_type_or_create_unranked_type(encodeData_type)
    loc = get_loc_or_create_from_frames(loc)
    op = _ods_ext.RleOp(encodeCount_type, encodeData_type, input, loc=loc)
    _hbdk.infer_type_if_failed_infer_shape(op)
    return op.results[0], op.results[1]


def share_feat_double_conv2d(input, weight0, weight1, quantInfo0, quantInfo1, kernel, stride=(1, 1), pad=(0, 0, 0, 0), padValue=0, relu=False, processDone="None", *, sumin0=None, sumin1=None, lutTable=None, groupSize=None, output0_type=None, output1_type=None, loc=None):
    """
2-D convolution for B25 double conv modules working as share feature mode

    """
    input = get_value_or_create_const(input)
    weight0 = get_value_or_create_const(weight0)
    weight1 = get_value_or_create_const(weight1)
    quantInfo0 = get_value_or_create_const(quantInfo0)
    quantInfo1 = get_value_or_create_const(quantInfo1)
    sumin0 = get_value_or_create_const(sumin0)
    sumin1 = get_value_or_create_const(sumin1)
    lutTable = get_value_or_create_const(lutTable)
    groupSize = create_array_attr(groupSize)
    kernel = create_array_attr(kernel)
    stride = create_array_attr(stride)
    pad = create_array_attr(pad)
    padValue = create_attr(padValue)
    relu = create_attr(relu)
    output0_type = get_type_or_create_unranked_type(output0_type)
    output1_type = get_type_or_create_unranked_type(output1_type)
    loc = get_loc_or_create_from_frames(loc)
    op = _ods_ext.ShareFeatDoubleConv2dOp(output0_type, output1_type, input, weight0, weight1, quantInfo0, quantInfo1, kernel, stride=stride, pad=pad, padValue=padValue, relu=relu, processDone=processDone, sumin0=sumin0, sumin1=sumin1, lutTable=lutTable, groupSize=groupSize, loc=loc)
    _hbdk.infer_type_if_failed_infer_shape(op)
    return op.results[0], op.results[1]


def share_weight_double_conv2d(input0, input1, weight, quantInfo, kernel, stride=(1, 1), pad=(0, 0, 0, 0), padValue=0, relu=False, processDone="None", *, sumin0=None, sumin1=None, lutTable=None, groupSize=None, output0_type=None, output1_type=None, loc=None):
    """
2-D convolution for B25 double conv modules working as share weight mode

    """
    input0 = get_value_or_create_const(input0)
    input1 = get_value_or_create_const(input1)
    weight = get_value_or_create_const(weight)
    quantInfo = get_value_or_create_const(quantInfo)
    sumin0 = get_value_or_create_const(sumin0)
    sumin1 = get_value_or_create_const(sumin1)
    lutTable = get_value_or_create_const(lutTable)
    groupSize = create_array_attr(groupSize)
    kernel = create_array_attr(kernel)
    stride = create_array_attr(stride)
    pad = create_array_attr(pad)
    padValue = create_attr(padValue)
    relu = create_attr(relu)
    output0_type = get_type_or_create_unranked_type(output0_type)
    output1_type = get_type_or_create_unranked_type(output1_type)
    loc = get_loc_or_create_from_frames(loc)
    op = _ods_ext.ShareWeightDoubleConv2dOp(output0_type, output1_type, input0, input1, weight, quantInfo, kernel, stride=stride, pad=pad, padValue=padValue, relu=relu, processDone=processDone, sumin0=sumin0, sumin1=sumin1, lutTable=lutTable, groupSize=groupSize, loc=loc)
    _hbdk.infer_type_if_failed_infer_shape(op)
    return op.results[0], op.results[1]


def ternary_eltwise(lhs, rhs, condition, mode, *, output_type=None, loc=None):
    """
Ternary Element-wise ops for B25, if condition is true, select value in lhs, otherwise select rhs

    """
    lhs = get_value_or_create_const(lhs)
    rhs = get_value_or_create_const(rhs)
    condition = get_value_or_create_const(condition)
    output_type = get_type_or_create_unranked_type(output_type)
    loc = get_loc_or_create_from_frames(loc)
    op = _ods_ext.TernaryEltwiseOp(output_type, lhs, rhs, condition, mode, loc=loc)
    _hbdk.infer_type_if_failed_infer_shape(op)
    return op.results[0]


def trans_layout(input, mode, *, output_type=None, loc=None):
    """
b25 transform layout op.

    """
    input = get_value_or_create_const(input)
    output_type = get_type_or_create_unranked_type(output_type)
    loc = get_loc_or_create_from_frames(loc)
    op = _ods_ext.TransLayoutOp(output_type, input, mode, loc=loc)
    _hbdk.infer_type_if_failed_infer_shape(op)
    return op.results[0]


def unary_eltwise(input, mode, roundMode="ROUND", saturate=True, perTensorQuant=False, *, quant_info=None, output_type=None, loc=None):
    """
Unary Element-wise ops for B25

    """
    input = get_value_or_create_const(input)
    quant_info = get_value_or_create_const(quant_info)
    roundMode = parse_enum(roundMode, 'roundMode')
    saturate = create_attr(saturate)
    perTensorQuant = create_attr(perTensorQuant)
    output_type = get_type_or_create_unranked_type(output_type)
    loc = get_loc_or_create_from_frames(loc)
    op = _ods_ext.UnaryEltwiseOp(output_type, input, mode, roundMode=roundMode, saturate=saturate, perTensorQuant=perTensorQuant, quant_info=quant_info, loc=loc)
    _hbdk.infer_type_if_failed_infer_shape(op)
    return op.results[0]


def warp(input, mv, initialOffset=(0, 0), mode="bilinear", expansionMode="constant", roundMode="ROUND", mvYX=False, mvMode="RelativeCoordinate", shiftBits=0, *, padValue=None, output_type=None, loc=None):
    """
b25 warp.
"From the input, sample (bi-linear interpolation) pixels specified by grid."
    """
    input = get_value_or_create_const(input)
    mv = get_value_or_create_const(mv)
    initialOffset = create_array_attr(initialOffset)
    mode = parse_enum(mode, 'mode')
    expansionMode = parse_enum(expansionMode, 'expansionMode')
    roundMode = parse_enum(roundMode, 'roundMode')
    mvYX = create_attr(mvYX)
    shiftBits = create_attr(shiftBits)
    padValue = create_attr(padValue)
    output_type = get_type_or_create_unranked_type(output_type)
    loc = get_loc_or_create_from_frames(loc)
    op = _ods_ext.WarpOp(output_type, input, mv, initialOffset=initialOffset, mode=mode, expansionMode=expansionMode, roundMode=roundMode, mvYX=mvYX, mvMode=mvMode, shiftBits=shiftBits, padValue=padValue, loc=loc)
    _hbdk.infer_type_if_failed_infer_shape(op)
    return op.results[0]


