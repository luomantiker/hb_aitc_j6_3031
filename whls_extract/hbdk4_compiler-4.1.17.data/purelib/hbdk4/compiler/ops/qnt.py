
# Autogenerated by mlir-tblgen; don't manually edit.
from .._mlir_libs import _hbdk
from ..dialects import qnt as _ods_ext
from .common import get_value_or_create_const
from .common import get_loc_or_create_from_frames
from .common import get_type_or_create_unranked_type
from .common import create_array_attr
from .common import create_attr
from .common import parse_enum
from .common import create_elements_attr


def barrier(input, *, output_type=None, loc=None):
    """
Prevent quant type optimizations

    """
    input = get_value_or_create_const(input)
    output_type = get_type_or_create_unranked_type(output_type)
    loc = get_loc_or_create_from_frames(loc)
    op = _ods_ext.BarrierOp(output_type, input, loc=loc)
    _hbdk.infer_type_if_failed_infer_shape(op)
    return op.results[0]


def const_fake_quant(input, min, max, bits, narrowRange=False, illegal=True, *, axis=None, output_type=None, loc=None):
    """
Simulates the effect of per axis uniform quantization with const range.

    Given a const min, max, num_bits and narrow_range attribute, applies the
    same per axis uniform quantization simulation as is done by the TensorFlow
    fake_quant_with_min_max_vars_per_channel op. See the fakeQuantAttrsToType()
    utility method and the quant-convert-simulated-quantization pass for further
    details.
  
    """
    input = get_value_or_create_const(input)
    min = create_array_attr(min)
    max = create_array_attr(max)
    bits = create_attr(bits)
    narrowRange = create_attr(narrowRange)
    illegal = create_attr(illegal)
    axis = create_attr(axis)
    output_type = get_type_or_create_unranked_type(output_type)
    loc = get_loc_or_create_from_frames(loc)
    op = _ods_ext.ConstFakeQuantOp(output_type, input, min, max, bits, narrowRange=narrowRange, illegal=illegal, axis=axis, loc=loc)
    _hbdk.infer_type_if_failed_infer_shape(op)
    return op.results[0]


def dcast(input, *, output_type=None, loc=None):
    """
Dequantze barrier that converts quantized types to float types.

    A DequantizeCast(dcast) repreresents a element type shift from quantized types to float types
            .

        e.g.from tensor < 4x !qnt.uniform < si8: f32,
    0.1 >> to tensor<4xf32>

               The expressed type(f32 in the example) of operand qnt.uniform type must identical to result float type
                   .The storage type(si8) in the example of operand qnt.uniform type must be signed integral.
  
    """
    input = get_value_or_create_const(input)
    output_type = get_type_or_create_unranked_type(output_type)
    loc = get_loc_or_create_from_frames(loc)
    op = _ods_ext.DequantizeCastOp(output_type, input, loc=loc)
    _hbdk.infer_type_if_failed_infer_shape(op)
    return op.results[0]


def dequantize(input, scales, zeros, *, axis=None, output_type=None, loc=None):
    """
Quantize op that converts float types to int types.
Performs quantization from floats to signed integers.
    """
    input = get_value_or_create_const(input)
    scales = create_array_attr(scales)
    zeros = create_array_attr(zeros)
    axis = create_attr(axis)
    output_type = get_type_or_create_unranked_type(output_type)
    loc = get_loc_or_create_from_frames(loc)
    op = _ods_ext.DequantizeOp(output_type, input, scales, zeros, axis=axis, loc=loc)
    _hbdk.infer_type_if_failed_infer_shape(op)
    return op.results[0]


def dynamic_dequantize(input, scales, symmetric=True, *, axis=None, output_type=None, loc=None):
    """
Quantize op that converts float types to int types.
Performs quantization from floats to signed integers.
    """
    input = get_value_or_create_const(input)
    scales = get_value_or_create_const(scales)
    symmetric = create_attr(symmetric)
    axis = create_attr(axis)
    output_type = get_type_or_create_unranked_type(output_type)
    loc = get_loc_or_create_from_frames(loc)
    op = _ods_ext.DynamicDequantizeOp(output_type, input, scales, symmetric=symmetric, axis=axis, loc=loc)
    _hbdk.infer_type_if_failed_infer_shape(op)
    return op.results[0]


def dynamic_quantize(input, bitwidth=8, symmetric=True, *, axis=None, blockSize=None, output_type=None, scales_type=None, loc=None):
    """
Dynamic quantize op that converts float types to int types.
Performs dynamic quantization from floats to signed integers.
    """
    input = get_value_or_create_const(input)
    bitwidth = create_attr(bitwidth)
    symmetric = create_attr(symmetric)
    axis = create_attr(axis)
    blockSize = create_attr(blockSize)
    output_type = get_type_or_create_unranked_type(output_type)
    scales_type = get_type_or_create_unranked_type(scales_type)
    loc = get_loc_or_create_from_frames(loc)
    op = _ods_ext.DynamicQuantizeOp(output_type, scales_type, input, bitwidth=bitwidth, symmetric=symmetric, axis=axis, blockSize=blockSize, loc=loc)
    _hbdk.infer_type_if_failed_infer_shape(op)
    return op.results[0], op.results[1]


def fused_dynamic_dequantize(quantInput, inputScale, weightScale, *, output_type=None, loc=None):
    """
Fuse dynamic dequantize op that converts int types to float types.
Performs dequantization from int to float.
    """
    quantInput = get_value_or_create_const(quantInput)
    inputScale = get_value_or_create_const(inputScale)
    weightScale = get_value_or_create_const(weightScale)
    output_type = get_type_or_create_unranked_type(output_type)
    loc = get_loc_or_create_from_frames(loc)
    op = _ods_ext.FuseDynamicDequantizeOp(output_type, quantInput, inputScale, weightScale, loc=loc)
    _hbdk.infer_type_if_failed_infer_shape(op)
    return op.results[0]


def qcast(input, *, output_type=None, loc=None):
    """
Quantize barrier that converts float types to quantized types.

    A QuantizeCast(qcast)
            represents a element type shift from float types to quantized types.e.g.from tensor<4xf32> to tensor <
        4x !qnt.uniform < si8: f32,
    0.1 >>

        The expressed type(f32 in the example) of result qnt.uniform type must identical to
            operand float type.The storage type(si8) in the example of result qnt.uniform type must be signed integral.
  
    """
    input = get_value_or_create_const(input)
    output_type = get_type_or_create_unranked_type(output_type)
    loc = get_loc_or_create_from_frames(loc)
    op = _ods_ext.QuantizeCastOp(output_type, input, loc=loc)
    _hbdk.infer_type_if_failed_infer_shape(op)
    return op.results[0]


def quantize(input, scales, zeros, narrowRange=False, *, axis=None, output_type=None, loc=None):
    """
Quantize op that converts float types to int types.
Performs quantization from floats to signed integers.
    """
    input = get_value_or_create_const(input)
    scales = create_array_attr(scales)
    zeros = create_array_attr(zeros)
    narrowRange = create_attr(narrowRange)
    axis = create_attr(axis)
    output_type = get_type_or_create_unranked_type(output_type)
    loc = get_loc_or_create_from_frames(loc)
    op = _ods_ext.QuantizeOp(output_type, input, scales, zeros, narrowRange=narrowRange, axis=axis, loc=loc)
    _hbdk.infer_type_if_failed_infer_shape(op)
    return op.results[0]


def rcast(input, *, output_type=None, loc=None):
    """
Requantize barrier that converts between different quantized types.

    A RequantizeCast(rcast) repreresents a element type conversion between different quantized types
            .

        e.g.from tensor < 4x !qnt.uniform < si8: f32,
    0.1 >> to tensor < 4x !qnt.uniform <
    si16: f32,
    0.003 >>

        The expressed type(f32) of qnt.uniform types must be identical.
  
    """
    input = get_value_or_create_const(input)
    output_type = get_type_or_create_unranked_type(output_type)
    loc = get_loc_or_create_from_frames(loc)
    op = _ods_ext.RequantizeCastOp(output_type, input, loc=loc)
    _hbdk.infer_type_if_failed_infer_shape(op)
    return op.results[0]


def scast(input, *, output_type=None, loc=None):
    """
Storage barrier that converts integral types from / to quantized types.

    A StorageCast(scast) repreresents a element type conversion between quantized types and interal types
            .

        e.g.from tensor < 4x !qnt.uniform < si8: f32,
    0.1 >> to tensor<4xsi8> from tensor<4xsi8> to tensor < 4x !qnt.uniform <
    si8: f32,
    0.1 >>

        The storage type(si8) of qnt.uniform type must be identical to interal type.
  
    """
    input = get_value_or_create_const(input)
    output_type = get_type_or_create_unranked_type(output_type)
    loc = get_loc_or_create_from_frames(loc)
    op = _ods_ext.StorageCastOp(output_type, input, loc=loc)
    _hbdk.infer_type_if_failed_infer_shape(op)
    return op.results[0]


