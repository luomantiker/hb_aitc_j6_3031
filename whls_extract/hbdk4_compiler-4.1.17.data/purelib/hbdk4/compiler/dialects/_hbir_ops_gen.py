
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import (
    equally_sized_accessor as _ods_equally_sized_accessor,
    get_default_loc_context as _ods_get_default_loc_context,
    get_op_result_or_op_results as _get_op_result_or_op_results,
    get_op_result_or_value as _get_op_result_or_value,
    get_op_results_or_values as _get_op_results_or_values,
    segmented_accessor as _ods_segmented_accessor,
)
_ods_ir = _ods_cext.ir

import builtins
from typing import Sequence as _Sequence, Union as _Union


@_ods_cext.register_dialect
class _Dialect(_ods_ir.Dialect):
  DIALECT_NAMESPACE = "hbir"

@_ods_cext.register_operation(_Dialect)
class AbsOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.abs"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def abs(output, input, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(AbsOp(output=output, input=input, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class AcosOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.acos"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def acos(output, input, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(AcosOp(output=output, input=input, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class AcoshOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.acosh"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def acosh(output, input, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(AcoshOp(output=output, input=input, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class AddOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.add"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, lhs, rhs, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def add(output, lhs, rhs, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(AddOp(output=output, lhs=lhs, rhs=rhs, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class AsinOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.asin"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def asin(output, input, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(AsinOp(output=output, input=input, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class AsinhOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.asinh"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def asinh(output, input, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(AsinhOp(output=output, input=input, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class AtanOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.atan"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def atan(output, input, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(AtanOp(output=output, input=input, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class AtanhOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.atanh"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def atanh(output, input, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(AtanhOp(output=output, input=input, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class AvgPoolOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.avg_pool"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, kernel, *, stride=None, pad=None, dilation=None, ceilMode=None, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["kernel"] = (kernel if (
    isinstance(kernel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(kernel, context=_ods_context))
    if stride is not None: attributes["stride"] = (stride if (
        isinstance(stride, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(stride, context=_ods_context))
    if pad is not None: attributes["pad"] = (pad if (
        isinstance(pad, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(pad, context=_ods_context))
    if dilation is not None: attributes["dilation"] = (dilation if (
        isinstance(dilation, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(dilation, context=_ods_context))
    if ceilMode is not None: attributes["ceilMode"] = (ceilMode if (
        isinstance(ceilMode, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(ceilMode, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def kernel(self):
    return self.operation.attributes["kernel"]

  @kernel.setter
  def kernel(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["kernel"] = value

  @builtins.property
  def stride(self):
    return self.operation.attributes["stride"]

  @stride.setter
  def stride(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["stride"] = value

  @builtins.property
  def pad(self):
    return self.operation.attributes["pad"]

  @pad.setter
  def pad(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["pad"] = value

  @builtins.property
  def dilation(self):
    return self.operation.attributes["dilation"]

  @dilation.setter
  def dilation(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dilation"] = value

  @builtins.property
  def ceilMode(self):
    return self.operation.attributes["ceilMode"]

  @ceilMode.setter
  def ceilMode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["ceilMode"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

def avg_pool(output, input, kernel, *, stride=None, pad=None, dilation=None, ceil_mode=None, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(AvgPoolOp(output=output, input=input, kernel=kernel, stride=stride, pad=pad, dilation=dilation, ceilMode=ceil_mode, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class BatchNormOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.batchnorm"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, mean, var, eps, *, weight=None, bias=None, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(mean))
    operands.append(_get_op_result_or_value(var))
    if weight is not None: operands.append(_get_op_result_or_value(weight))
    if bias is not None: operands.append(_get_op_result_or_value(bias))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["eps"] = (eps if (
    isinstance(eps, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(eps, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 3, 2, 0, 0)
    return self.operation.operands[start]

  @builtins.property
  def mean(self):
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 3, 2, 1, 0)
    return self.operation.operands[start]

  @builtins.property
  def var(self):
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 3, 2, 2, 0)
    return self.operation.operands[start]

  @builtins.property
  def weight(self):
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 3, 2, 3, 0)
    return self.operation.operands[start:start + elements_per_group]

  @builtins.property
  def bias(self):
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 3, 2, 3, 1)
    return self.operation.operands[start:start + elements_per_group]

  @builtins.property
  def eps(self):
    return self.operation.attributes["eps"]

  @eps.setter
  def eps(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["eps"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

def batchnorm(output, input, mean, var, eps, *, weight=None, bias=None, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(BatchNormOp(output=output, input=input, mean=mean, var=var, eps=eps, weight=weight, bias=bias, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class BevPoolV2Op(_ods_ir.OpView):
  OPERATION_NAME = "hbir.bev_pool_v2"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, depth, feat, ranks_depth, ranks_feat, ranks_bev, interval_starts, interval_lengths, bev_feat_shape, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(depth))
    operands.append(_get_op_result_or_value(feat))
    operands.append(_get_op_result_or_value(ranks_depth))
    operands.append(_get_op_result_or_value(ranks_feat))
    operands.append(_get_op_result_or_value(ranks_bev))
    operands.append(_get_op_result_or_value(interval_starts))
    operands.append(_get_op_result_or_value(interval_lengths))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["bev_feat_shape"] = (bev_feat_shape if (
    isinstance(bev_feat_shape, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(bev_feat_shape, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def depth(self):
    return self.operation.operands[0]

  @builtins.property
  def feat(self):
    return self.operation.operands[1]

  @builtins.property
  def ranks_depth(self):
    return self.operation.operands[2]

  @builtins.property
  def ranks_feat(self):
    return self.operation.operands[3]

  @builtins.property
  def ranks_bev(self):
    return self.operation.operands[4]

  @builtins.property
  def interval_starts(self):
    return self.operation.operands[5]

  @builtins.property
  def interval_lengths(self):
    return self.operation.operands[6]

  @builtins.property
  def bev_feat_shape(self):
    return self.operation.attributes["bev_feat_shape"]

  @bev_feat_shape.setter
  def bev_feat_shape(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["bev_feat_shape"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

def bev_pool_v2(output, depth, feat, ranks_depth, ranks_feat, ranks_bev, interval_starts, interval_lengths, bev_feat_shape, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(BevPoolV2Op(output=output, depth=depth, feat=feat, ranks_depth=ranks_depth, ranks_feat=ranks_feat, ranks_bev=ranks_bev, interval_starts=interval_starts, interval_lengths=interval_lengths, bev_feat_shape=bev_feat_shape, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class BitShiftOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.bitshift"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, rshift, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(rshift))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def rshift(self):
    return self.operation.operands[1]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def bitshift(output, input, rshift, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(BitShiftOp(output=output, input=input, rshift=rshift, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class BitwiseAndOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.bitwise_and"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, lhs, rhs, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def bitwise_and(output, lhs, rhs, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(BitwiseAndOp(output=output, lhs=lhs, rhs=rhs, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class BitwiseNotOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.bitwise_not"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def bitwise_not(output, input, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(BitwiseNotOp(output=output, input=input, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class BitwiseOrOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.bitwise_or"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, lhs, rhs, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def bitwise_or(output, lhs, rhs, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(BitwiseOrOp(output=output, lhs=lhs, rhs=rhs, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class BitwiseXorOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.bitwise_xor"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, lhs, rhs, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def bitwise_xor(output, lhs, rhs, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(BitwiseXorOp(output=output, lhs=lhs, rhs=rhs, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class CastTypeOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.cast_type"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, forceSaturate=None, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    if forceSaturate is not None: attributes["forceSaturate"] = (forceSaturate if (
        isinstance(forceSaturate, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(forceSaturate, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def forceSaturate(self):
    if "forceSaturate" not in self.operation.attributes:
      return None
    return self.operation.attributes["forceSaturate"]

  @forceSaturate.setter
  def forceSaturate(self, value):
    if value is not None:
      self.operation.attributes["forceSaturate"] = value
    elif "forceSaturate" in self.operation.attributes:
      del self.operation.attributes["forceSaturate"]

  @forceSaturate.deleter
  def forceSaturate(self):
    del self.operation.attributes["forceSaturate"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def cast_type(output, input, *, force_saturate=None, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(CastTypeOp(output=output, input=input, forceSaturate=force_saturate, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class CeilOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.ceil"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def ceil(output, input, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(CeilOp(output=output, input=input, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class ClipOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.clip"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, min, max, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["min"] = (min if (
    isinstance(min, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_984')) else
      _ods_ir.AttrBuilder.get('anonymous_984')(min, context=_ods_context))
    attributes["max"] = (max if (
    isinstance(max, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_984')) else
      _ods_ir.AttrBuilder.get('anonymous_984')(max, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def min(self):
    return self.operation.attributes["min"]

  @min.setter
  def min(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["min"] = value

  @builtins.property
  def max(self):
    return self.operation.attributes["max"]

  @max.setter
  def max(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["max"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

def clip(output, input, min, max, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(ClipOp(output=output, input=input, min=min, max=max, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class ConcatOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.concat"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, inputs, dim, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dim"] = (dim if (
    isinstance(dim, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(dim, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def dim(self):
    return self.operation.attributes["dim"]

  @dim.setter
  def dim(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dim"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

def concat(output, inputs, dim, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(ConcatOp(output=output, inputs=inputs, dim=dim, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class ConstantOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.constant"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, values, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["values"] = (values if (
    isinstance(values, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ElementsAttr')) else
      _ods_ir.AttrBuilder.get('ElementsAttr')(values, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def values(self):
    return self.operation.attributes["values"]

  @values.setter
  def values(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["values"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

def constant(output, values, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(ConstantOp(output=output, values=values, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class Conv2dOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.conv2d"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, weight, *, bias=None, stride=None, pad=None, dilation=None, groupNum=None, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(weight))
    if bias is not None: operands.append(_get_op_result_or_value(bias))
    _ods_context = _ods_get_default_loc_context(loc)
    if stride is not None: attributes["stride"] = (stride if (
        isinstance(stride, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(stride, context=_ods_context))
    if pad is not None: attributes["pad"] = (pad if (
        isinstance(pad, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(pad, context=_ods_context))
    if dilation is not None: attributes["dilation"] = (dilation if (
        isinstance(dilation, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(dilation, context=_ods_context))
    if groupNum is not None: attributes["groupNum"] = (groupNum if (
        isinstance(groupNum, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(groupNum, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def weight(self):
    return self.operation.operands[1]

  @builtins.property
  def bias(self):
    return None if len(self.operation.operands) < 3 else self.operation.operands[2]

  @builtins.property
  def stride(self):
    return self.operation.attributes["stride"]

  @stride.setter
  def stride(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["stride"] = value

  @builtins.property
  def pad(self):
    return self.operation.attributes["pad"]

  @pad.setter
  def pad(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["pad"] = value

  @builtins.property
  def dilation(self):
    return self.operation.attributes["dilation"]

  @dilation.setter
  def dilation(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dilation"] = value

  @builtins.property
  def groupNum(self):
    return self.operation.attributes["groupNum"]

  @groupNum.setter
  def groupNum(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["groupNum"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

def conv2d(output, input, weight, *, bias=None, stride=None, pad=None, dilation=None, group_num=None, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(Conv2dOp(output=output, input=input, weight=weight, bias=bias, stride=stride, pad=pad, dilation=dilation, groupNum=group_num, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class Conv3dOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.conv3d"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, weight, *, bias=None, stride=None, pad=None, dilation=None, groupNum=None, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(weight))
    if bias is not None: operands.append(_get_op_result_or_value(bias))
    _ods_context = _ods_get_default_loc_context(loc)
    if stride is not None: attributes["stride"] = (stride if (
        isinstance(stride, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(stride, context=_ods_context))
    if pad is not None: attributes["pad"] = (pad if (
        isinstance(pad, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(pad, context=_ods_context))
    if dilation is not None: attributes["dilation"] = (dilation if (
        isinstance(dilation, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(dilation, context=_ods_context))
    if groupNum is not None: attributes["groupNum"] = (groupNum if (
        isinstance(groupNum, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(groupNum, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def weight(self):
    return self.operation.operands[1]

  @builtins.property
  def bias(self):
    return None if len(self.operation.operands) < 3 else self.operation.operands[2]

  @builtins.property
  def stride(self):
    return self.operation.attributes["stride"]

  @stride.setter
  def stride(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["stride"] = value

  @builtins.property
  def pad(self):
    return self.operation.attributes["pad"]

  @pad.setter
  def pad(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["pad"] = value

  @builtins.property
  def dilation(self):
    return self.operation.attributes["dilation"]

  @dilation.setter
  def dilation(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dilation"] = value

  @builtins.property
  def groupNum(self):
    return self.operation.attributes["groupNum"]

  @groupNum.setter
  def groupNum(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["groupNum"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

def conv3d(output, input, weight, *, bias=None, stride=None, pad=None, dilation=None, group_num=None, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(Conv3dOp(output=output, input=input, weight=weight, bias=bias, stride=stride, pad=pad, dilation=dilation, groupNum=group_num, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class ConvOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.conv"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, weight, *, bias=None, stride=None, pad=None, dilation=None, groupNum=None, channelLast=None, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(weight))
    if bias is not None: operands.append(_get_op_result_or_value(bias))
    _ods_context = _ods_get_default_loc_context(loc)
    if stride is not None: attributes["stride"] = (stride if (
        isinstance(stride, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(stride, context=_ods_context))
    if pad is not None: attributes["pad"] = (pad if (
        isinstance(pad, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(pad, context=_ods_context))
    if dilation is not None: attributes["dilation"] = (dilation if (
        isinstance(dilation, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(dilation, context=_ods_context))
    if groupNum is not None: attributes["groupNum"] = (groupNum if (
        isinstance(groupNum, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(groupNum, context=_ods_context))
    if channelLast is not None: attributes["channelLast"] = (channelLast if (
        isinstance(channelLast, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(channelLast, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def weight(self):
    return self.operation.operands[1]

  @builtins.property
  def bias(self):
    return None if len(self.operation.operands) < 3 else self.operation.operands[2]

  @builtins.property
  def stride(self):
    return self.operation.attributes["stride"]

  @stride.setter
  def stride(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["stride"] = value

  @builtins.property
  def pad(self):
    return self.operation.attributes["pad"]

  @pad.setter
  def pad(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["pad"] = value

  @builtins.property
  def dilation(self):
    return self.operation.attributes["dilation"]

  @dilation.setter
  def dilation(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dilation"] = value

  @builtins.property
  def groupNum(self):
    return self.operation.attributes["groupNum"]

  @groupNum.setter
  def groupNum(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["groupNum"] = value

  @builtins.property
  def channelLast(self):
    return self.operation.attributes["channelLast"]

  @channelLast.setter
  def channelLast(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["channelLast"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

def conv(output, input, weight, *, bias=None, stride=None, pad=None, dilation=None, group_num=None, channel_last=None, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(ConvOp(output=output, input=input, weight=weight, bias=bias, stride=stride, pad=pad, dilation=dilation, groupNum=group_num, channelLast=channel_last, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class ConvTransposeOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.convtranspose"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, weight, *, bias=None, stride=None, pad=None, dilation=None, groupNum=None, illegalWeight=None, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(weight))
    if bias is not None: operands.append(_get_op_result_or_value(bias))
    _ods_context = _ods_get_default_loc_context(loc)
    if stride is not None: attributes["stride"] = (stride if (
        isinstance(stride, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(stride, context=_ods_context))
    if pad is not None: attributes["pad"] = (pad if (
        isinstance(pad, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(pad, context=_ods_context))
    if dilation is not None: attributes["dilation"] = (dilation if (
        isinstance(dilation, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(dilation, context=_ods_context))
    if groupNum is not None: attributes["groupNum"] = (groupNum if (
        isinstance(groupNum, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(groupNum, context=_ods_context))
    if illegalWeight is not None: attributes["illegalWeight"] = (illegalWeight if (
        isinstance(illegalWeight, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(illegalWeight, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def weight(self):
    return self.operation.operands[1]

  @builtins.property
  def bias(self):
    return None if len(self.operation.operands) < 3 else self.operation.operands[2]

  @builtins.property
  def stride(self):
    return self.operation.attributes["stride"]

  @stride.setter
  def stride(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["stride"] = value

  @builtins.property
  def pad(self):
    return self.operation.attributes["pad"]

  @pad.setter
  def pad(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["pad"] = value

  @builtins.property
  def dilation(self):
    return self.operation.attributes["dilation"]

  @dilation.setter
  def dilation(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dilation"] = value

  @builtins.property
  def groupNum(self):
    return self.operation.attributes["groupNum"]

  @groupNum.setter
  def groupNum(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["groupNum"] = value

  @builtins.property
  def illegalWeight(self):
    return self.operation.attributes["illegalWeight"]

  @illegalWeight.setter
  def illegalWeight(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["illegalWeight"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

def convtranspose(output, input, weight, *, bias=None, stride=None, pad=None, dilation=None, group_num=None, illegal_weight=None, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(ConvTransposeOp(output=output, input=input, weight=weight, bias=bias, stride=stride, pad=pad, dilation=dilation, groupNum=group_num, illegalWeight=illegal_weight, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class CorrelationOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.correlation"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, lhs, rhs, *, kernel=None, max_d=None, stride1=None, stride2=None, pad=None, mode=None, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    if kernel is not None: attributes["kernel"] = (kernel if (
        isinstance(kernel, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(kernel, context=_ods_context))
    if max_d is not None: attributes["max_d"] = (max_d if (
        isinstance(max_d, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(max_d, context=_ods_context))
    if stride1 is not None: attributes["stride1"] = (stride1 if (
        isinstance(stride1, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(stride1, context=_ods_context))
    if stride2 is not None: attributes["stride2"] = (stride2 if (
        isinstance(stride2, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(stride2, context=_ods_context))
    if pad is not None: attributes["pad"] = (pad if (
        isinstance(pad, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(pad, context=_ods_context))
    if mode is not None: attributes["mode"] = (mode if (
        isinstance(mode, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('CorrelationModeAttr')) else
          _ods_ir.AttrBuilder.get('CorrelationModeAttr')(mode, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def kernel(self):
    return self.operation.attributes["kernel"]

  @kernel.setter
  def kernel(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["kernel"] = value

  @builtins.property
  def max_d(self):
    return self.operation.attributes["max_d"]

  @max_d.setter
  def max_d(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["max_d"] = value

  @builtins.property
  def stride1(self):
    return self.operation.attributes["stride1"]

  @stride1.setter
  def stride1(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["stride1"] = value

  @builtins.property
  def stride2(self):
    return self.operation.attributes["stride2"]

  @stride2.setter
  def stride2(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["stride2"] = value

  @builtins.property
  def pad(self):
    return self.operation.attributes["pad"]

  @pad.setter
  def pad(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["pad"] = value

  @builtins.property
  def mode(self):
    return self.operation.attributes["mode"]

  @mode.setter
  def mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mode"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

def correlation(output, lhs, rhs, *, kernel=None, max_d=None, stride1=None, stride2=None, pad=None, mode=None, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(CorrelationOp(output=output, lhs=lhs, rhs=rhs, kernel=kernel, max_d=max_d, stride1=stride1, stride2=stride2, pad=pad, mode=mode, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class CosOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.cos"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def cos(output, input, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(CosOp(output=output, input=input, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class CoshOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.cosh"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def cosh(output, input, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(CoshOp(output=output, input=input, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class CumSumOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.cumsum"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, axis, *, exclusive=None, reverse=None, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["axis"] = (axis if (
    isinstance(axis, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(axis, context=_ods_context))
    if exclusive is not None: attributes["exclusive"] = (exclusive if (
        isinstance(exclusive, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(exclusive, context=_ods_context))
    if reverse is not None: attributes["reverse"] = (reverse if (
        isinstance(reverse, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(reverse, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def axis(self):
    return self.operation.attributes["axis"]

  @axis.setter
  def axis(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axis"] = value

  @builtins.property
  def exclusive(self):
    return self.operation.attributes["exclusive"]

  @exclusive.setter
  def exclusive(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["exclusive"] = value

  @builtins.property
  def reverse(self):
    return self.operation.attributes["reverse"]

  @reverse.setter
  def reverse(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["reverse"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

def cumsum(output, input, axis, *, exclusive=None, reverse=None, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(CumSumOp(output=output, input=input, axis=axis, exclusive=exclusive, reverse=reverse, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class CustomOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.custom"

  _ODS_REGIONS = (0, True)

  def __init__(self, outputs, inputs, srcPath, entryFuncName, *, includeDirs=None, libraryDirs=None, extraCompileArgs=None, extraLinkArgs=None, runtimeLibraryDirs=None, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["srcPath"] = (srcPath if (
    isinstance(srcPath, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(srcPath, context=_ods_context))
    attributes["entryFuncName"] = (entryFuncName if (
    isinstance(entryFuncName, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(entryFuncName, context=_ods_context))
    if includeDirs is not None: attributes["includeDirs"] = (includeDirs if (
        isinstance(includeDirs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(includeDirs, context=_ods_context))
    if libraryDirs is not None: attributes["libraryDirs"] = (libraryDirs if (
        isinstance(libraryDirs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(libraryDirs, context=_ods_context))
    if extraCompileArgs is not None: attributes["extraCompileArgs"] = (extraCompileArgs if (
        isinstance(extraCompileArgs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(extraCompileArgs, context=_ods_context))
    if extraLinkArgs is not None: attributes["extraLinkArgs"] = (extraLinkArgs if (
        isinstance(extraLinkArgs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(extraLinkArgs, context=_ods_context))
    if runtimeLibraryDirs is not None: attributes["runtimeLibraryDirs"] = (runtimeLibraryDirs if (
        isinstance(runtimeLibraryDirs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(runtimeLibraryDirs, context=_ods_context))
    results.extend(outputs)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def srcPath(self):
    return self.operation.attributes["srcPath"]

  @srcPath.setter
  def srcPath(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["srcPath"] = value

  @builtins.property
  def entryFuncName(self):
    return self.operation.attributes["entryFuncName"]

  @entryFuncName.setter
  def entryFuncName(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["entryFuncName"] = value

  @builtins.property
  def includeDirs(self):
    if "includeDirs" not in self.operation.attributes:
      return None
    return self.operation.attributes["includeDirs"]

  @includeDirs.setter
  def includeDirs(self, value):
    if value is not None:
      self.operation.attributes["includeDirs"] = value
    elif "includeDirs" in self.operation.attributes:
      del self.operation.attributes["includeDirs"]

  @includeDirs.deleter
  def includeDirs(self):
    del self.operation.attributes["includeDirs"]

  @builtins.property
  def libraryDirs(self):
    if "libraryDirs" not in self.operation.attributes:
      return None
    return self.operation.attributes["libraryDirs"]

  @libraryDirs.setter
  def libraryDirs(self, value):
    if value is not None:
      self.operation.attributes["libraryDirs"] = value
    elif "libraryDirs" in self.operation.attributes:
      del self.operation.attributes["libraryDirs"]

  @libraryDirs.deleter
  def libraryDirs(self):
    del self.operation.attributes["libraryDirs"]

  @builtins.property
  def extraCompileArgs(self):
    if "extraCompileArgs" not in self.operation.attributes:
      return None
    return self.operation.attributes["extraCompileArgs"]

  @extraCompileArgs.setter
  def extraCompileArgs(self, value):
    if value is not None:
      self.operation.attributes["extraCompileArgs"] = value
    elif "extraCompileArgs" in self.operation.attributes:
      del self.operation.attributes["extraCompileArgs"]

  @extraCompileArgs.deleter
  def extraCompileArgs(self):
    del self.operation.attributes["extraCompileArgs"]

  @builtins.property
  def extraLinkArgs(self):
    if "extraLinkArgs" not in self.operation.attributes:
      return None
    return self.operation.attributes["extraLinkArgs"]

  @extraLinkArgs.setter
  def extraLinkArgs(self, value):
    if value is not None:
      self.operation.attributes["extraLinkArgs"] = value
    elif "extraLinkArgs" in self.operation.attributes:
      del self.operation.attributes["extraLinkArgs"]

  @extraLinkArgs.deleter
  def extraLinkArgs(self):
    del self.operation.attributes["extraLinkArgs"]

  @builtins.property
  def runtimeLibraryDirs(self):
    if "runtimeLibraryDirs" not in self.operation.attributes:
      return None
    return self.operation.attributes["runtimeLibraryDirs"]

  @runtimeLibraryDirs.setter
  def runtimeLibraryDirs(self, value):
    if value is not None:
      self.operation.attributes["runtimeLibraryDirs"] = value
    elif "runtimeLibraryDirs" in self.operation.attributes:
      del self.operation.attributes["runtimeLibraryDirs"]

  @runtimeLibraryDirs.deleter
  def runtimeLibraryDirs(self):
    del self.operation.attributes["runtimeLibraryDirs"]

  @builtins.property
  def outputs(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def custom(outputs, inputs, src_path, entry_func_name, *, include_dirs=None, library_dirs=None, extra_compile_args=None, extra_link_args=None, runtime_library_dirs=None, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(CustomOp(outputs=outputs, inputs=inputs, srcPath=src_path, entryFuncName=entry_func_name, includeDirs=include_dirs, libraryDirs=library_dirs, extraCompileArgs=extra_compile_args, extraLinkArgs=extra_link_args, runtimeLibraryDirs=runtime_library_dirs, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class DeformConv2dOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.deform_conv2d"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, weight, offset, mask, *, bias=None, stride=None, pad=None, dilation=None, groupNum=None, offsetGroupNum=None, useMask=None, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(weight))
    operands.append(_get_op_result_or_value(offset))
    operands.append(_get_op_result_or_value(mask))
    if bias is not None: operands.append(_get_op_result_or_value(bias))
    _ods_context = _ods_get_default_loc_context(loc)
    if stride is not None: attributes["stride"] = (stride if (
        isinstance(stride, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(stride, context=_ods_context))
    if pad is not None: attributes["pad"] = (pad if (
        isinstance(pad, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(pad, context=_ods_context))
    if dilation is not None: attributes["dilation"] = (dilation if (
        isinstance(dilation, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(dilation, context=_ods_context))
    if groupNum is not None: attributes["groupNum"] = (groupNum if (
        isinstance(groupNum, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(groupNum, context=_ods_context))
    if offsetGroupNum is not None: attributes["offsetGroupNum"] = (offsetGroupNum if (
        isinstance(offsetGroupNum, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(offsetGroupNum, context=_ods_context))
    if useMask is not None: attributes["useMask"] = (useMask if (
        isinstance(useMask, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(useMask, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def weight(self):
    return self.operation.operands[1]

  @builtins.property
  def offset(self):
    return self.operation.operands[2]

  @builtins.property
  def mask(self):
    return self.operation.operands[3]

  @builtins.property
  def bias(self):
    return None if len(self.operation.operands) < 5 else self.operation.operands[4]

  @builtins.property
  def stride(self):
    return self.operation.attributes["stride"]

  @stride.setter
  def stride(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["stride"] = value

  @builtins.property
  def pad(self):
    return self.operation.attributes["pad"]

  @pad.setter
  def pad(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["pad"] = value

  @builtins.property
  def dilation(self):
    return self.operation.attributes["dilation"]

  @dilation.setter
  def dilation(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dilation"] = value

  @builtins.property
  def groupNum(self):
    return self.operation.attributes["groupNum"]

  @groupNum.setter
  def groupNum(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["groupNum"] = value

  @builtins.property
  def offsetGroupNum(self):
    return self.operation.attributes["offsetGroupNum"]

  @offsetGroupNum.setter
  def offsetGroupNum(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["offsetGroupNum"] = value

  @builtins.property
  def useMask(self):
    return self.operation.attributes["useMask"]

  @useMask.setter
  def useMask(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["useMask"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

def deform_conv2d(output, input, weight, offset, mask, *, bias=None, stride=None, pad=None, dilation=None, group_num=None, offset_group_num=None, use_mask=None, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(DeformConv2dOp(output=output, input=input, weight=weight, offset=offset, mask=mask, bias=bias, stride=stride, pad=pad, dilation=dilation, groupNum=group_num, offsetGroupNum=offset_group_num, useMask=use_mask, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class DivOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.div"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, lhs, rhs, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def div(output, lhs, rhs, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(DivOp(output=output, lhs=lhs, rhs=rhs, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class DppOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.dpp"

  _ODS_REGIONS = (0, True)

  def __init__(self, boxData, inputs, anchors, anchorNum, filterThreshold, nmsThreshold, nmsMargin, seed, useClipping, stride, clsOffset, *, imageSize=None, inputShift=None, legacyMode=None, useBpuFilter=None, maxBoxNum=None, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["anchors"] = (anchors if (
    isinstance(anchors, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(anchors, context=_ods_context))
    attributes["anchorNum"] = (anchorNum if (
    isinstance(anchorNum, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(anchorNum, context=_ods_context))
    attributes["filterThreshold"] = (filterThreshold if (
    isinstance(filterThreshold, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(filterThreshold, context=_ods_context))
    attributes["nmsThreshold"] = (nmsThreshold if (
    isinstance(nmsThreshold, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(nmsThreshold, context=_ods_context))
    attributes["nmsMargin"] = (nmsMargin if (
    isinstance(nmsMargin, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(nmsMargin, context=_ods_context))
    attributes["seed"] = (seed if (
    isinstance(seed, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(seed, context=_ods_context))
    attributes["useClipping"] = (useClipping if (
    isinstance(useClipping, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(useClipping, context=_ods_context))
    attributes["stride"] = (stride if (
    isinstance(stride, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(stride, context=_ods_context))
    attributes["clsOffset"] = (clsOffset if (
    isinstance(clsOffset, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(clsOffset, context=_ods_context))
    if imageSize is not None: attributes["imageSize"] = (imageSize if (
        isinstance(imageSize, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(imageSize, context=_ods_context))
    if inputShift is not None: attributes["inputShift"] = (inputShift if (
        isinstance(inputShift, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(inputShift, context=_ods_context))
    if legacyMode is not None: attributes["legacyMode"] = (legacyMode if (
        isinstance(legacyMode, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(legacyMode, context=_ods_context))
    if useBpuFilter is not None: attributes["useBpuFilter"] = (useBpuFilter if (
        isinstance(useBpuFilter, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(useBpuFilter, context=_ods_context))
    if maxBoxNum is not None: attributes["maxBoxNum"] = (maxBoxNum if (
        isinstance(maxBoxNum, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(maxBoxNum, context=_ods_context))
    results.append(boxData)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def anchors(self):
    return self.operation.attributes["anchors"]

  @anchors.setter
  def anchors(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["anchors"] = value

  @builtins.property
  def anchorNum(self):
    return self.operation.attributes["anchorNum"]

  @anchorNum.setter
  def anchorNum(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["anchorNum"] = value

  @builtins.property
  def filterThreshold(self):
    return self.operation.attributes["filterThreshold"]

  @filterThreshold.setter
  def filterThreshold(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["filterThreshold"] = value

  @builtins.property
  def nmsThreshold(self):
    return self.operation.attributes["nmsThreshold"]

  @nmsThreshold.setter
  def nmsThreshold(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["nmsThreshold"] = value

  @builtins.property
  def nmsMargin(self):
    return self.operation.attributes["nmsMargin"]

  @nmsMargin.setter
  def nmsMargin(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["nmsMargin"] = value

  @builtins.property
  def seed(self):
    return self.operation.attributes["seed"]

  @seed.setter
  def seed(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["seed"] = value

  @builtins.property
  def useClipping(self):
    return self.operation.attributes["useClipping"]

  @useClipping.setter
  def useClipping(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["useClipping"] = value

  @builtins.property
  def stride(self):
    return self.operation.attributes["stride"]

  @stride.setter
  def stride(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["stride"] = value

  @builtins.property
  def clsOffset(self):
    return self.operation.attributes["clsOffset"]

  @clsOffset.setter
  def clsOffset(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["clsOffset"] = value

  @builtins.property
  def imageSize(self):
    return self.operation.attributes["imageSize"]

  @imageSize.setter
  def imageSize(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["imageSize"] = value

  @builtins.property
  def inputShift(self):
    return self.operation.attributes["inputShift"]

  @inputShift.setter
  def inputShift(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["inputShift"] = value

  @builtins.property
  def legacyMode(self):
    return self.operation.attributes["legacyMode"]

  @legacyMode.setter
  def legacyMode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["legacyMode"] = value

  @builtins.property
  def useBpuFilter(self):
    return self.operation.attributes["useBpuFilter"]

  @useBpuFilter.setter
  def useBpuFilter(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["useBpuFilter"] = value

  @builtins.property
  def maxBoxNum(self):
    return self.operation.attributes["maxBoxNum"]

  @maxBoxNum.setter
  def maxBoxNum(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["maxBoxNum"] = value

  @builtins.property
  def boxData(self):
    return self.operation.results[0]

def dpp(box_data, inputs, anchors, anchor_num, filter_threshold, nms_threshold, nms_margin, seed, use_clipping, stride, cls_offset, *, image_size=None, input_shift=None, legacy_mode=None, use_bpu_filter=None, max_box_num=None, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(DppOp(boxData=box_data, inputs=inputs, anchors=anchors, anchorNum=anchor_num, filterThreshold=filter_threshold, nmsThreshold=nms_threshold, nmsMargin=nms_margin, seed=seed, useClipping=use_clipping, stride=stride, clsOffset=cls_offset, imageSize=image_size, inputShift=input_shift, legacyMode=legacy_mode, useBpuFilter=use_bpu_filter, maxBoxNum=max_box_num, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class DynamicSliceOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.dynamic_slice"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, starts, ends, axes, steps, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(starts))
    operands.append(_get_op_result_or_value(ends))
    operands.append(_get_op_result_or_value(axes))
    operands.append(_get_op_result_or_value(steps))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def starts(self):
    return self.operation.operands[1]

  @builtins.property
  def ends(self):
    return self.operation.operands[2]

  @builtins.property
  def axes(self):
    return self.operation.operands[3]

  @builtins.property
  def steps(self):
    return self.operation.operands[4]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def dynamic_slice(output, input, starts, ends, axes, steps, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(DynamicSliceOp(output=output, input=input, starts=starts, ends=ends, axes=axes, steps=steps, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class ELUOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.elu"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, alpha, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["alpha"] = (alpha if (
    isinstance(alpha, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(alpha, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def alpha(self):
    return self.operation.attributes["alpha"]

  @alpha.setter
  def alpha(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["alpha"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

def elu(output, input, alpha, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(ELUOp(output=output, input=input, alpha=alpha, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class EinsumOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.einsum"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, inputs, equation, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["equation"] = (equation if (
    isinstance(equation, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(equation, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def equation(self):
    return self.operation.attributes["equation"]

  @equation.setter
  def equation(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["equation"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

def einsum(output, inputs, equation, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(EinsumOp(output=output, inputs=inputs, equation=equation, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class EmbeddingOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.embedding"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, weight, paddingIdx, scaleGradGyFreq, sparse, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(weight))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["paddingIdx"] = (paddingIdx if (
    isinstance(paddingIdx, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(paddingIdx, context=_ods_context))
    attributes["scaleGradGyFreq"] = (scaleGradGyFreq if (
    isinstance(scaleGradGyFreq, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(scaleGradGyFreq, context=_ods_context))
    attributes["sparse"] = (sparse if (
    isinstance(sparse, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(sparse, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def weight(self):
    return self.operation.operands[1]

  @builtins.property
  def paddingIdx(self):
    return self.operation.attributes["paddingIdx"]

  @paddingIdx.setter
  def paddingIdx(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["paddingIdx"] = value

  @builtins.property
  def scaleGradGyFreq(self):
    return self.operation.attributes["scaleGradGyFreq"]

  @scaleGradGyFreq.setter
  def scaleGradGyFreq(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scaleGradGyFreq"] = value

  @builtins.property
  def sparse(self):
    return self.operation.attributes["sparse"]

  @sparse.setter
  def sparse(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sparse"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

def embedding(output, input, weight, padding_idx, scale_grad_gy_freq, sparse, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(EmbeddingOp(output=output, input=input, weight=weight, paddingIdx=padding_idx, scaleGradGyFreq=scale_grad_gy_freq, sparse=sparse, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class EmptyLikeOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.empty_like"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, dtype=None, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    if dtype is not None: attributes["dtype"] = (dtype if (
        isinstance(dtype, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('TypeAttr')) else
          _ods_ir.AttrBuilder.get('TypeAttr')(dtype, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def dtype(self):
    if "dtype" not in self.operation.attributes:
      return None
    return self.operation.attributes["dtype"]

  @dtype.setter
  def dtype(self, value):
    if value is not None:
      self.operation.attributes["dtype"] = value
    elif "dtype" in self.operation.attributes:
      del self.operation.attributes["dtype"]

  @dtype.deleter
  def dtype(self):
    del self.operation.attributes["dtype"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def empty_like(output, input, *, dtype=None, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(EmptyLikeOp(output=output, input=input, dtype=dtype, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class EqualOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.equal"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, lhs, rhs, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def equal(output, lhs, rhs, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(EqualOp(output=output, lhs=lhs, rhs=rhs, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class ErfOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.erf"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def erf(output, input, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(ErfOp(output=output, input=input, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class ExpOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.exp"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def exp(output, input, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(ExpOp(output=output, input=input, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class FakeCastOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.fake_cast"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, dtype, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dtype"] = (dtype if (
    isinstance(dtype, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(dtype, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def dtype(self):
    return self.operation.attributes["dtype"]

  @dtype.setter
  def dtype(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dtype"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

def fake_cast(output, input, dtype, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(FakeCastOp(output=output, input=input, dtype=dtype, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class FilterOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.filter"

  _ODS_REGIONS = (0, True)

  def __init__(self, maxValue, maxIndex, filterCoord, filterData, input, channelBegin, channelEnd, threshold, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["channelBegin"] = (channelBegin if (
    isinstance(channelBegin, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(channelBegin, context=_ods_context))
    attributes["channelEnd"] = (channelEnd if (
    isinstance(channelEnd, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(channelEnd, context=_ods_context))
    attributes["threshold"] = (threshold if (
    isinstance(threshold, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(threshold, context=_ods_context))
    results.append(maxValue)
    results.append(maxIndex)
    results.append(filterCoord)
    results.append(filterData)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def channelBegin(self):
    return self.operation.attributes["channelBegin"]

  @channelBegin.setter
  def channelBegin(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["channelBegin"] = value

  @builtins.property
  def channelEnd(self):
    return self.operation.attributes["channelEnd"]

  @channelEnd.setter
  def channelEnd(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["channelEnd"] = value

  @builtins.property
  def threshold(self):
    return self.operation.attributes["threshold"]

  @threshold.setter
  def threshold(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["threshold"] = value

  @builtins.property
  def maxValue(self):
    return self.operation.results[0]

  @builtins.property
  def maxIndex(self):
    return self.operation.results[1]

  @builtins.property
  def filterCoord(self):
    return self.operation.results[2]

  @builtins.property
  def filterData(self):
    return self.operation.results[3]

def filter(max_value, max_index, filter_coord, filter_data, input, channel_begin, channel_end, threshold, *, extra=None, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return _get_op_result_or_op_results(FilterOp(maxValue=max_value, maxIndex=max_index, filterCoord=filter_coord, filterData=filter_data, input=input, channelBegin=channel_begin, channelEnd=channel_end, threshold=threshold, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class FlipOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.flip"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, dims, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dims"] = (dims if (
    isinstance(dims, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(dims, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def dims(self):
    return self.operation.attributes["dims"]

  @dims.setter
  def dims(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dims"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

def flip(output, input, dims, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(FlipOp(output=output, input=input, dims=dims, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class FloorOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.floor"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def floor(output, input, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(FloorOp(output=output, input=input, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class FppOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.fpp"

  _ODS_REGIONS = (0, True)

  def __init__(self, boxData, inputs, anchors, anchorNum, filterThreshold, nmsThreshold, nmsMargin, seed, headerPadSize, dataChannel, useClipping, stride, clsOffset, *, imageSize=None, inputShift=None, legacyMode=None, maxBoxNum=None, dataRank=None, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["anchors"] = (anchors if (
    isinstance(anchors, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(anchors, context=_ods_context))
    attributes["anchorNum"] = (anchorNum if (
    isinstance(anchorNum, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(anchorNum, context=_ods_context))
    attributes["filterThreshold"] = (filterThreshold if (
    isinstance(filterThreshold, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(filterThreshold, context=_ods_context))
    attributes["nmsThreshold"] = (nmsThreshold if (
    isinstance(nmsThreshold, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(nmsThreshold, context=_ods_context))
    attributes["nmsMargin"] = (nmsMargin if (
    isinstance(nmsMargin, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(nmsMargin, context=_ods_context))
    attributes["seed"] = (seed if (
    isinstance(seed, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(seed, context=_ods_context))
    attributes["headerPadSize"] = (headerPadSize if (
    isinstance(headerPadSize, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(headerPadSize, context=_ods_context))
    attributes["dataChannel"] = (dataChannel if (
    isinstance(dataChannel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(dataChannel, context=_ods_context))
    attributes["useClipping"] = (useClipping if (
    isinstance(useClipping, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(useClipping, context=_ods_context))
    attributes["stride"] = (stride if (
    isinstance(stride, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(stride, context=_ods_context))
    attributes["clsOffset"] = (clsOffset if (
    isinstance(clsOffset, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(clsOffset, context=_ods_context))
    if imageSize is not None: attributes["imageSize"] = (imageSize if (
        isinstance(imageSize, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(imageSize, context=_ods_context))
    if inputShift is not None: attributes["inputShift"] = (inputShift if (
        isinstance(inputShift, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(inputShift, context=_ods_context))
    if legacyMode is not None: attributes["legacyMode"] = (legacyMode if (
        isinstance(legacyMode, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(legacyMode, context=_ods_context))
    if maxBoxNum is not None: attributes["maxBoxNum"] = (maxBoxNum if (
        isinstance(maxBoxNum, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(maxBoxNum, context=_ods_context))
    if dataRank is not None: attributes["dataRank"] = (dataRank if (
        isinstance(dataRank, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(dataRank, context=_ods_context))
    results.append(boxData)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def anchors(self):
    return self.operation.attributes["anchors"]

  @anchors.setter
  def anchors(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["anchors"] = value

  @builtins.property
  def anchorNum(self):
    return self.operation.attributes["anchorNum"]

  @anchorNum.setter
  def anchorNum(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["anchorNum"] = value

  @builtins.property
  def filterThreshold(self):
    return self.operation.attributes["filterThreshold"]

  @filterThreshold.setter
  def filterThreshold(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["filterThreshold"] = value

  @builtins.property
  def nmsThreshold(self):
    return self.operation.attributes["nmsThreshold"]

  @nmsThreshold.setter
  def nmsThreshold(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["nmsThreshold"] = value

  @builtins.property
  def nmsMargin(self):
    return self.operation.attributes["nmsMargin"]

  @nmsMargin.setter
  def nmsMargin(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["nmsMargin"] = value

  @builtins.property
  def seed(self):
    return self.operation.attributes["seed"]

  @seed.setter
  def seed(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["seed"] = value

  @builtins.property
  def headerPadSize(self):
    return self.operation.attributes["headerPadSize"]

  @headerPadSize.setter
  def headerPadSize(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["headerPadSize"] = value

  @builtins.property
  def dataChannel(self):
    return self.operation.attributes["dataChannel"]

  @dataChannel.setter
  def dataChannel(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dataChannel"] = value

  @builtins.property
  def useClipping(self):
    return self.operation.attributes["useClipping"]

  @useClipping.setter
  def useClipping(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["useClipping"] = value

  @builtins.property
  def stride(self):
    return self.operation.attributes["stride"]

  @stride.setter
  def stride(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["stride"] = value

  @builtins.property
  def clsOffset(self):
    return self.operation.attributes["clsOffset"]

  @clsOffset.setter
  def clsOffset(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["clsOffset"] = value

  @builtins.property
  def imageSize(self):
    return self.operation.attributes["imageSize"]

  @imageSize.setter
  def imageSize(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["imageSize"] = value

  @builtins.property
  def inputShift(self):
    return self.operation.attributes["inputShift"]

  @inputShift.setter
  def inputShift(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["inputShift"] = value

  @builtins.property
  def legacyMode(self):
    return self.operation.attributes["legacyMode"]

  @legacyMode.setter
  def legacyMode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["legacyMode"] = value

  @builtins.property
  def maxBoxNum(self):
    return self.operation.attributes["maxBoxNum"]

  @maxBoxNum.setter
  def maxBoxNum(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["maxBoxNum"] = value

  @builtins.property
  def dataRank(self):
    return self.operation.attributes["dataRank"]

  @dataRank.setter
  def dataRank(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dataRank"] = value

  @builtins.property
  def boxData(self):
    return self.operation.results[0]

def fpp(box_data, inputs, anchors, anchor_num, filter_threshold, nms_threshold, nms_margin, seed, header_pad_size, data_channel, use_clipping, stride, cls_offset, *, image_size=None, input_shift=None, legacy_mode=None, max_box_num=None, data_rank=None, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(FppOp(boxData=box_data, inputs=inputs, anchors=anchors, anchorNum=anchor_num, filterThreshold=filter_threshold, nmsThreshold=nms_threshold, nmsMargin=nms_margin, seed=seed, headerPadSize=header_pad_size, dataChannel=data_channel, useClipping=use_clipping, stride=stride, clsOffset=cls_offset, imageSize=image_size, inputShift=input_shift, legacyMode=legacy_mode, maxBoxNum=max_box_num, dataRank=data_rank, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class GELUOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.gelu"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, approximate=None, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    if approximate is not None: attributes["approximate"] = (approximate if (
        isinstance(approximate, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('GeluApproximateModeAttr')) else
          _ods_ir.AttrBuilder.get('GeluApproximateModeAttr')(approximate, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def approximate(self):
    return self.operation.attributes["approximate"]

  @approximate.setter
  def approximate(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["approximate"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

def gelu(output, input, *, approximate=None, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(GELUOp(output=output, input=input, approximate=approximate, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class GatherElementsOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.gather_elements"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, indices, dim, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(indices))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dim"] = (dim if (
    isinstance(dim, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(dim, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def indices(self):
    return self.operation.operands[1]

  @builtins.property
  def dim(self):
    return self.operation.attributes["dim"]

  @dim.setter
  def dim(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dim"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

def gather_elements(output, input, indices, dim, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(GatherElementsOp(output=output, input=input, indices=indices, dim=dim, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class GatherNdOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.gather_nd"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, indices, batchDim, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(indices))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["batchDim"] = (batchDim if (
    isinstance(batchDim, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(batchDim, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def indices(self):
    return self.operation.operands[1]

  @builtins.property
  def batchDim(self):
    return self.operation.attributes["batchDim"]

  @batchDim.setter
  def batchDim(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["batchDim"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

def gather_nd(output, input, indices, batch_dim, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(GatherNdOp(output=output, input=input, indices=indices, batchDim=batch_dim, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class GreaterEqualOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.greater_equal"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, lhs, rhs, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def greater_equal(output, lhs, rhs, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(GreaterEqualOp(output=output, lhs=lhs, rhs=rhs, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class GreaterOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.greater"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, lhs, rhs, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def greater(output, lhs, rhs, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(GreaterOp(output=output, lhs=lhs, rhs=rhs, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class GridSampleOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.grid_sample"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, grid, *, mode=None, expansionMode=None, alignCorner=None, padValue=None, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(grid))
    _ods_context = _ods_get_default_loc_context(loc)
    if mode is not None: attributes["mode"] = (mode if (
        isinstance(mode, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('InterpolationModeAttr')) else
          _ods_ir.AttrBuilder.get('InterpolationModeAttr')(mode, context=_ods_context))
    if expansionMode is not None: attributes["expansionMode"] = (expansionMode if (
        isinstance(expansionMode, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('ExpansionModeAttr')) else
          _ods_ir.AttrBuilder.get('ExpansionModeAttr')(expansionMode, context=_ods_context))
    if alignCorner is not None: attributes["alignCorner"] = (alignCorner if (
        isinstance(alignCorner, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(alignCorner, context=_ods_context))
    if padValue is not None: attributes["padValue"] = (padValue if (
        isinstance(padValue, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_984')) else
          _ods_ir.AttrBuilder.get('anonymous_984')(padValue, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def grid(self):
    return self.operation.operands[1]

  @builtins.property
  def mode(self):
    return self.operation.attributes["mode"]

  @mode.setter
  def mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mode"] = value

  @builtins.property
  def expansionMode(self):
    return self.operation.attributes["expansionMode"]

  @expansionMode.setter
  def expansionMode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["expansionMode"] = value

  @builtins.property
  def alignCorner(self):
    return self.operation.attributes["alignCorner"]

  @alignCorner.setter
  def alignCorner(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["alignCorner"] = value

  @builtins.property
  def padValue(self):
    if "padValue" not in self.operation.attributes:
      return None
    return self.operation.attributes["padValue"]

  @padValue.setter
  def padValue(self, value):
    if value is not None:
      self.operation.attributes["padValue"] = value
    elif "padValue" in self.operation.attributes:
      del self.operation.attributes["padValue"]

  @padValue.deleter
  def padValue(self):
    del self.operation.attributes["padValue"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def grid_sample(output, input, grid, *, mode=None, expansion_mode=None, align_corner=None, pad_value=None, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(GridSampleOp(output=output, input=input, grid=grid, mode=mode, expansionMode=expansion_mode, alignCorner=align_corner, padValue=pad_value, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class IdentityOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.identity"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def identity(output, input, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(IdentityOp(output=output, input=input, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class ImageConvertOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.image_convert"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, inputs, *, mode=None, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    if mode is not None: attributes["mode"] = (mode if (
        isinstance(mode, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('ImageConvertModeAttr')) else
          _ods_ir.AttrBuilder.get('ImageConvertModeAttr')(mode, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def mode(self):
    return self.operation.attributes["mode"]

  @mode.setter
  def mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mode"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

def image_convert(output, inputs, *, mode=None, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(ImageConvertOp(output=output, inputs=inputs, mode=mode, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class ImagePreProcessOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.image_preprocess"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, csc=None, divisor=None, mean=None, sd=None, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    if csc is not None: attributes["csc"] = (csc if (
        isinstance(csc, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('CSCModeAttr')) else
          _ods_ir.AttrBuilder.get('CSCModeAttr')(csc, context=_ods_context))
    if divisor is not None: attributes["divisor"] = (divisor if (
        isinstance(divisor, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(divisor, context=_ods_context))
    if mean is not None: attributes["mean"] = (mean if (
        isinstance(mean, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('F64ArrayAttr')(mean, context=_ods_context))
    if sd is not None: attributes["sd"] = (sd if (
        isinstance(sd, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('F64ArrayAttr')(sd, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def csc(self):
    return self.operation.attributes["csc"]

  @csc.setter
  def csc(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["csc"] = value

  @builtins.property
  def divisor(self):
    return self.operation.attributes["divisor"]

  @divisor.setter
  def divisor(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["divisor"] = value

  @builtins.property
  def mean(self):
    return self.operation.attributes["mean"]

  @mean.setter
  def mean(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mean"] = value

  @builtins.property
  def sd(self):
    return self.operation.attributes["sd"]

  @sd.setter
  def sd(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sd"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

def image_preprocess(output, input, *, csc=None, divisor=None, mean=None, sd=None, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(ImagePreProcessOp(output=output, input=input, csc=csc, divisor=divisor, mean=mean, sd=sd, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class IndexOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.index"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, index, dim, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(index))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dim"] = (dim if (
    isinstance(dim, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(dim, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def index(self):
    return self.operation.operands[1]

  @builtins.property
  def dim(self):
    return self.operation.attributes["dim"]

  @dim.setter
  def dim(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dim"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

def index(output, input, index, dim, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(IndexOp(output=output, input=input, index=index, dim=dim, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class KvCacheUpdateOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.kv_cache_update"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, cachedOut, cachedInput, input, dim, repeatNum, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(cachedInput))
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dim"] = (dim if (
    isinstance(dim, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(dim, context=_ods_context))
    attributes["repeatNum"] = (repeatNum if (
    isinstance(repeatNum, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(repeatNum, context=_ods_context))
    results.append(output)
    results.append(cachedOut)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def cachedInput(self):
    return self.operation.operands[0]

  @builtins.property
  def input(self):
    return self.operation.operands[1]

  @builtins.property
  def dim(self):
    return self.operation.attributes["dim"]

  @dim.setter
  def dim(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dim"] = value

  @builtins.property
  def repeatNum(self):
    return self.operation.attributes["repeatNum"]

  @repeatNum.setter
  def repeatNum(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["repeatNum"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

  @builtins.property
  def cachedOut(self):
    return self.operation.results[1]

def kv_cache_update(output, cached_out, cached_input, input, dim, repeat_num, *, extra=None, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return _get_op_result_or_op_results(KvCacheUpdateOp(output=output, cachedOut=cached_out, cachedInput=cached_input, input=input, dim=dim, repeatNum=repeat_num, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class LayerNormOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.layernorm"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, dims, eps, *, weight=None, bias=None, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    if weight is not None: operands.append(_get_op_result_or_value(weight))
    if bias is not None: operands.append(_get_op_result_or_value(bias))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dims"] = (dims if (
    isinstance(dims, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(dims, context=_ods_context))
    attributes["eps"] = (eps if (
    isinstance(eps, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(eps, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 1, 2, 0, 0)
    return self.operation.operands[start]

  @builtins.property
  def weight(self):
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 1, 2, 1, 0)
    return self.operation.operands[start:start + elements_per_group]

  @builtins.property
  def bias(self):
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 1, 2, 1, 1)
    return self.operation.operands[start:start + elements_per_group]

  @builtins.property
  def dims(self):
    return self.operation.attributes["dims"]

  @dims.setter
  def dims(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dims"] = value

  @builtins.property
  def eps(self):
    return self.operation.attributes["eps"]

  @eps.setter
  def eps(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["eps"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

def layernorm(output, input, dims, eps, *, weight=None, bias=None, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(LayerNormOp(output=output, input=input, dims=dims, eps=eps, weight=weight, bias=bias, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class LeakyReLUOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.leaky_relu"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, slop, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["slop"] = (slop if (
    isinstance(slop, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(slop, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def slop(self):
    return self.operation.attributes["slop"]

  @slop.setter
  def slop(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["slop"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

def leaky_relu(output, input, slop, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(LeakyReLUOp(output=output, input=input, slop=slop, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class LessEqualOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.less_equal"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, lhs, rhs, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def less_equal(output, lhs, rhs, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(LessEqualOp(output=output, lhs=lhs, rhs=rhs, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class LessOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.less"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, lhs, rhs, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def less(output, lhs, rhs, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(LessOp(output=output, lhs=lhs, rhs=rhs, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class LinearOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.linear"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, weight, *, bias=None, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(weight))
    if bias is not None: operands.append(_get_op_result_or_value(bias))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def weight(self):
    return self.operation.operands[1]

  @builtins.property
  def bias(self):
    return None if len(self.operation.operands) < 3 else self.operation.operands[2]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def linear(output, input, weight, *, bias=None, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(LinearOp(output=output, input=input, weight=weight, bias=bias, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class LogOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.log"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def log(output, input, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(LogOp(output=output, input=input, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class LogSoftmaxOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.log_softmax"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, dim, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dim"] = (dim if (
    isinstance(dim, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(dim, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def dim(self):
    return self.operation.attributes["dim"]

  @dim.setter
  def dim(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dim"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

def log_softmax(output, input, dim, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(LogSoftmaxOp(output=output, input=input, dim=dim, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class LogicalAndOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.logical_and"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, lhs, rhs, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def logical_and(output, lhs, rhs, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(LogicalAndOp(output=output, lhs=lhs, rhs=rhs, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class LogicalNotOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.logical_not"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def logical_not(output, input, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(LogicalNotOp(output=output, input=input, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class LogicalOrOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.logical_or"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, lhs, rhs, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def logical_or(output, lhs, rhs, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(LogicalOrOp(output=output, lhs=lhs, rhs=rhs, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class LogicalXorOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.logical_xor"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, lhs, rhs, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def logical_xor(output, lhs, rhs, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(LogicalXorOp(output=output, lhs=lhs, rhs=rhs, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class LpNormalizeOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.lp_normalize"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, p=None, dim=None, eps=None, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    if p is not None: attributes["p"] = (p if (
        isinstance(p, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(p, context=_ods_context))
    if dim is not None: attributes["dim"] = (dim if (
        isinstance(dim, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(dim, context=_ods_context))
    if eps is not None: attributes["eps"] = (eps if (
        isinstance(eps, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(eps, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def p(self):
    return self.operation.attributes["p"]

  @p.setter
  def p(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["p"] = value

  @builtins.property
  def dim(self):
    return self.operation.attributes["dim"]

  @dim.setter
  def dim(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dim"] = value

  @builtins.property
  def eps(self):
    return self.operation.attributes["eps"]

  @eps.setter
  def eps(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["eps"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

def lp_normalize(output, input, *, p=None, dim=None, eps=None, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(LpNormalizeOp(output=output, input=input, p=p, dim=dim, eps=eps, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class LpPoolOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.lp_pool"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, kernel, stride, pad, dilation, p, *, ceilMode=None, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["kernel"] = (kernel if (
    isinstance(kernel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(kernel, context=_ods_context))
    attributes["stride"] = (stride if (
    isinstance(stride, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(stride, context=_ods_context))
    attributes["pad"] = (pad if (
    isinstance(pad, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(pad, context=_ods_context))
    attributes["dilation"] = (dilation if (
    isinstance(dilation, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(dilation, context=_ods_context))
    attributes["p"] = (p if (
    isinstance(p, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(p, context=_ods_context))
    if ceilMode is not None: attributes["ceilMode"] = (ceilMode if (
        isinstance(ceilMode, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(ceilMode, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def kernel(self):
    return self.operation.attributes["kernel"]

  @kernel.setter
  def kernel(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["kernel"] = value

  @builtins.property
  def stride(self):
    return self.operation.attributes["stride"]

  @stride.setter
  def stride(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["stride"] = value

  @builtins.property
  def pad(self):
    return self.operation.attributes["pad"]

  @pad.setter
  def pad(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["pad"] = value

  @builtins.property
  def dilation(self):
    return self.operation.attributes["dilation"]

  @dilation.setter
  def dilation(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dilation"] = value

  @builtins.property
  def p(self):
    return self.operation.attributes["p"]

  @p.setter
  def p(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["p"] = value

  @builtins.property
  def ceilMode(self):
    return self.operation.attributes["ceilMode"]

  @ceilMode.setter
  def ceilMode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["ceilMode"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

def lp_pool(output, input, kernel, stride, pad, dilation, p, *, ceil_mode=None, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(LpPoolOp(output=output, input=input, kernel=kernel, stride=stride, pad=pad, dilation=dilation, p=p, ceilMode=ceil_mode, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class LutOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.lut"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, config, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(config))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def config(self):
    return self.operation.operands[1]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def lut(output, input, config, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(LutOp(output=output, input=input, config=config, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class MakeTupleOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.make_tuple"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, inputs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def make_tuple(output, inputs, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(MakeTupleOp(output=output, inputs=inputs, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class MaskedSelectOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.masked_select"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, mask, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(mask))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def mask(self):
    return self.operation.operands[1]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def masked_select(output, input, mask, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(MaskedSelectOp(output=output, input=input, mask=mask, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class MatMulOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.matmul"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, lhs, rhs, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def matmul(output, lhs, rhs, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(MatMulOp(output=output, lhs=lhs, rhs=rhs, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class MaxOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.max"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, lhs, rhs, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def max(output, lhs, rhs, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(MaxOp(output=output, lhs=lhs, rhs=rhs, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class MaxPoolOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.max_pool"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, kernel, *, stride=None, pad=None, dilation=None, ceilMode=None, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["kernel"] = (kernel if (
    isinstance(kernel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(kernel, context=_ods_context))
    if stride is not None: attributes["stride"] = (stride if (
        isinstance(stride, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(stride, context=_ods_context))
    if pad is not None: attributes["pad"] = (pad if (
        isinstance(pad, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(pad, context=_ods_context))
    if dilation is not None: attributes["dilation"] = (dilation if (
        isinstance(dilation, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(dilation, context=_ods_context))
    if ceilMode is not None: attributes["ceilMode"] = (ceilMode if (
        isinstance(ceilMode, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(ceilMode, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def kernel(self):
    return self.operation.attributes["kernel"]

  @kernel.setter
  def kernel(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["kernel"] = value

  @builtins.property
  def stride(self):
    return self.operation.attributes["stride"]

  @stride.setter
  def stride(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["stride"] = value

  @builtins.property
  def pad(self):
    return self.operation.attributes["pad"]

  @pad.setter
  def pad(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["pad"] = value

  @builtins.property
  def dilation(self):
    return self.operation.attributes["dilation"]

  @dilation.setter
  def dilation(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dilation"] = value

  @builtins.property
  def ceilMode(self):
    return self.operation.attributes["ceilMode"]

  @ceilMode.setter
  def ceilMode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["ceilMode"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

def max_pool(output, input, kernel, *, stride=None, pad=None, dilation=None, ceil_mode=None, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(MaxPoolOp(output=output, input=input, kernel=kernel, stride=stride, pad=pad, dilation=dilation, ceilMode=ceil_mode, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class MaxPoolWithIndicesOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.max_pool_with_indices"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, indices, input, kernel, *, stride=None, pad=None, dilation=None, ceilMode=None, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["kernel"] = (kernel if (
    isinstance(kernel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(kernel, context=_ods_context))
    if stride is not None: attributes["stride"] = (stride if (
        isinstance(stride, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(stride, context=_ods_context))
    if pad is not None: attributes["pad"] = (pad if (
        isinstance(pad, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(pad, context=_ods_context))
    if dilation is not None: attributes["dilation"] = (dilation if (
        isinstance(dilation, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(dilation, context=_ods_context))
    if ceilMode is not None: attributes["ceilMode"] = (ceilMode if (
        isinstance(ceilMode, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(ceilMode, context=_ods_context))
    results.append(output)
    results.append(indices)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def kernel(self):
    return self.operation.attributes["kernel"]

  @kernel.setter
  def kernel(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["kernel"] = value

  @builtins.property
  def stride(self):
    return self.operation.attributes["stride"]

  @stride.setter
  def stride(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["stride"] = value

  @builtins.property
  def pad(self):
    return self.operation.attributes["pad"]

  @pad.setter
  def pad(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["pad"] = value

  @builtins.property
  def dilation(self):
    return self.operation.attributes["dilation"]

  @dilation.setter
  def dilation(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dilation"] = value

  @builtins.property
  def ceilMode(self):
    return self.operation.attributes["ceilMode"]

  @ceilMode.setter
  def ceilMode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["ceilMode"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

  @builtins.property
  def indices(self):
    return self.operation.results[1]

def max_pool_with_indices(output, indices, input, kernel, *, stride=None, pad=None, dilation=None, ceil_mode=None, extra=None, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return _get_op_result_or_op_results(MaxPoolWithIndicesOp(output=output, indices=indices, input=input, kernel=kernel, stride=stride, pad=pad, dilation=dilation, ceilMode=ceil_mode, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class MaxUnpoolOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.max_unpool"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, indices, kernel, *, outputShape=None, stride=None, pad=None, dilation=None, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(indices))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["kernel"] = (kernel if (
    isinstance(kernel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(kernel, context=_ods_context))
    if outputShape is not None: attributes["outputShape"] = (outputShape if (
        isinstance(outputShape, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(outputShape, context=_ods_context))
    if stride is not None: attributes["stride"] = (stride if (
        isinstance(stride, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(stride, context=_ods_context))
    if pad is not None: attributes["pad"] = (pad if (
        isinstance(pad, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(pad, context=_ods_context))
    if dilation is not None: attributes["dilation"] = (dilation if (
        isinstance(dilation, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(dilation, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def indices(self):
    return self.operation.operands[1]

  @builtins.property
  def kernel(self):
    return self.operation.attributes["kernel"]

  @kernel.setter
  def kernel(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["kernel"] = value

  @builtins.property
  def outputShape(self):
    return self.operation.attributes["outputShape"]

  @outputShape.setter
  def outputShape(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputShape"] = value

  @builtins.property
  def stride(self):
    return self.operation.attributes["stride"]

  @stride.setter
  def stride(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["stride"] = value

  @builtins.property
  def pad(self):
    return self.operation.attributes["pad"]

  @pad.setter
  def pad(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["pad"] = value

  @builtins.property
  def dilation(self):
    return self.operation.attributes["dilation"]

  @dilation.setter
  def dilation(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dilation"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

def max_unpool(output, input, indices, kernel, *, output_shape=None, stride=None, pad=None, dilation=None, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(MaxUnpoolOp(output=output, input=input, indices=indices, kernel=kernel, outputShape=output_shape, stride=stride, pad=pad, dilation=dilation, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class MinOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.min"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, lhs, rhs, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def min(output, lhs, rhs, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(MinOp(output=output, lhs=lhs, rhs=rhs, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class MishOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.mish"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def mish(output, input, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(MishOp(output=output, input=input, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class ModOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.mod"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, lhs, rhs, *, sameSignAsDividend=None, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    if sameSignAsDividend is not None: attributes["sameSignAsDividend"] = (sameSignAsDividend if (
        isinstance(sameSignAsDividend, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(sameSignAsDividend, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def sameSignAsDividend(self):
    return self.operation.attributes["sameSignAsDividend"]

  @sameSignAsDividend.setter
  def sameSignAsDividend(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sameSignAsDividend"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

def mod(output, lhs, rhs, *, same_sign_as_dividend=None, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(ModOp(output=output, lhs=lhs, rhs=rhs, sameSignAsDividend=same_sign_as_dividend, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class MulOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.mul"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, lhs, rhs, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def mul(output, lhs, rhs, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(MulOp(output=output, lhs=lhs, rhs=rhs, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class NanToNumOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.nan_to_num"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, nan=None, posinf=None, neginf=None, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    if nan is not None: attributes["nan"] = (nan if (
        isinstance(nan, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(nan, context=_ods_context))
    if posinf is not None: attributes["posinf"] = (posinf if (
        isinstance(posinf, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(posinf, context=_ods_context))
    if neginf is not None: attributes["neginf"] = (neginf if (
        isinstance(neginf, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(neginf, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def nan(self):
    return self.operation.attributes["nan"]

  @nan.setter
  def nan(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["nan"] = value

  @builtins.property
  def posinf(self):
    if "posinf" not in self.operation.attributes:
      return None
    return self.operation.attributes["posinf"]

  @posinf.setter
  def posinf(self, value):
    if value is not None:
      self.operation.attributes["posinf"] = value
    elif "posinf" in self.operation.attributes:
      del self.operation.attributes["posinf"]

  @posinf.deleter
  def posinf(self):
    del self.operation.attributes["posinf"]

  @builtins.property
  def neginf(self):
    if "neginf" not in self.operation.attributes:
      return None
    return self.operation.attributes["neginf"]

  @neginf.setter
  def neginf(self, value):
    if value is not None:
      self.operation.attributes["neginf"] = value
    elif "neginf" in self.operation.attributes:
      del self.operation.attributes["neginf"]

  @neginf.deleter
  def neginf(self):
    del self.operation.attributes["neginf"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def nan_to_num(output, input, *, nan=None, posinf=None, neginf=None, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(NanToNumOp(output=output, input=input, nan=nan, posinf=posinf, neginf=neginf, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class NegOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.neg"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def neg(output, input, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(NegOp(output=output, input=input, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class NonMaxSuppressionOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.nms"

  _ODS_REGIONS = (0, True)

  def __init__(self, indices, boxes, scores, *, mode=None, iouThreshold=None, scoreThreshold=None, maxOutputBoxesPerClass=None, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(boxes))
    operands.append(_get_op_result_or_value(scores))
    _ods_context = _ods_get_default_loc_context(loc)
    if mode is not None: attributes["mode"] = (mode if (
        isinstance(mode, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoxTypeModeAttr')) else
          _ods_ir.AttrBuilder.get('BoxTypeModeAttr')(mode, context=_ods_context))
    if iouThreshold is not None: attributes["iouThreshold"] = (iouThreshold if (
        isinstance(iouThreshold, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(iouThreshold, context=_ods_context))
    if scoreThreshold is not None: attributes["scoreThreshold"] = (scoreThreshold if (
        isinstance(scoreThreshold, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(scoreThreshold, context=_ods_context))
    if maxOutputBoxesPerClass is not None: attributes["maxOutputBoxesPerClass"] = (maxOutputBoxesPerClass if (
        isinstance(maxOutputBoxesPerClass, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(maxOutputBoxesPerClass, context=_ods_context))
    results.append(indices)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def boxes(self):
    return self.operation.operands[0]

  @builtins.property
  def scores(self):
    return self.operation.operands[1]

  @builtins.property
  def mode(self):
    return self.operation.attributes["mode"]

  @mode.setter
  def mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mode"] = value

  @builtins.property
  def iouThreshold(self):
    return self.operation.attributes["iouThreshold"]

  @iouThreshold.setter
  def iouThreshold(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["iouThreshold"] = value

  @builtins.property
  def scoreThreshold(self):
    return self.operation.attributes["scoreThreshold"]

  @scoreThreshold.setter
  def scoreThreshold(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scoreThreshold"] = value

  @builtins.property
  def maxOutputBoxesPerClass(self):
    return self.operation.attributes["maxOutputBoxesPerClass"]

  @maxOutputBoxesPerClass.setter
  def maxOutputBoxesPerClass(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["maxOutputBoxesPerClass"] = value

  @builtins.property
  def indices(self):
    return self.operation.results[0]

def nms(indices, boxes, scores, *, mode=None, iou_threshold=None, score_threshold=None, max_output_boxes_per_class=None, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(NonMaxSuppressionOp(indices=indices, boxes=boxes, scores=scores, mode=mode, iouThreshold=iou_threshold, scoreThreshold=score_threshold, maxOutputBoxesPerClass=max_output_boxes_per_class, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class NonZeroOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.nonzero"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def nonzero(output, input, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(NonZeroOp(output=output, input=input, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class NotEqualOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.not_equal"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, lhs, rhs, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def not_equal(output, lhs, rhs, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(NotEqualOp(output=output, lhs=lhs, rhs=rhs, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class NumbaOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.numba"

  _ODS_REGIONS = (0, True)

  def __init__(self, outputs, inputs, path, irFileName, funcName, *, libraryMode=None, libraryName=None, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["path"] = (path if (
    isinstance(path, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(path, context=_ods_context))
    attributes["irFileName"] = (irFileName if (
    isinstance(irFileName, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(irFileName, context=_ods_context))
    attributes["funcName"] = (funcName if (
    isinstance(funcName, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(funcName, context=_ods_context))
    if libraryMode is not None: attributes["libraryMode"] = (libraryMode if (
        isinstance(libraryMode, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LibraryModeAttr')) else
          _ods_ir.AttrBuilder.get('LibraryModeAttr')(libraryMode, context=_ods_context))
    if libraryName is not None: attributes["libraryName"] = (libraryName if (
        isinstance(libraryName, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(libraryName, context=_ods_context))
    results.extend(outputs)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def path(self):
    return self.operation.attributes["path"]

  @path.setter
  def path(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["path"] = value

  @builtins.property
  def irFileName(self):
    return self.operation.attributes["irFileName"]

  @irFileName.setter
  def irFileName(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["irFileName"] = value

  @builtins.property
  def funcName(self):
    return self.operation.attributes["funcName"]

  @funcName.setter
  def funcName(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["funcName"] = value

  @builtins.property
  def libraryMode(self):
    return self.operation.attributes["libraryMode"]

  @libraryMode.setter
  def libraryMode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["libraryMode"] = value

  @builtins.property
  def libraryName(self):
    if "libraryName" not in self.operation.attributes:
      return None
    return self.operation.attributes["libraryName"]

  @libraryName.setter
  def libraryName(self, value):
    if value is not None:
      self.operation.attributes["libraryName"] = value
    elif "libraryName" in self.operation.attributes:
      del self.operation.attributes["libraryName"]

  @libraryName.deleter
  def libraryName(self):
    del self.operation.attributes["libraryName"]

  @builtins.property
  def outputs(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def numba(outputs, inputs, path, ir_file_name, func_name, *, library_mode=None, library_name=None, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(NumbaOp(outputs=outputs, inputs=inputs, path=path, irFileName=ir_file_name, funcName=func_name, libraryMode=library_mode, libraryName=library_name, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class PadOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.pad"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, begin, end, *, expansionMode=None, padValue=None, foldable=None, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["begin"] = (begin if (
    isinstance(begin, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(begin, context=_ods_context))
    attributes["end"] = (end if (
    isinstance(end, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(end, context=_ods_context))
    if expansionMode is not None: attributes["expansionMode"] = (expansionMode if (
        isinstance(expansionMode, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('ExpansionModeAttr')) else
          _ods_ir.AttrBuilder.get('ExpansionModeAttr')(expansionMode, context=_ods_context))
    if padValue is not None: attributes["padValue"] = (padValue if (
        isinstance(padValue, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_984')) else
          _ods_ir.AttrBuilder.get('anonymous_984')(padValue, context=_ods_context))
    if foldable is not None: attributes["foldable"] = (foldable if (
        isinstance(foldable, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(foldable, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def begin(self):
    return self.operation.attributes["begin"]

  @begin.setter
  def begin(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["begin"] = value

  @builtins.property
  def end(self):
    return self.operation.attributes["end"]

  @end.setter
  def end(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["end"] = value

  @builtins.property
  def expansionMode(self):
    return self.operation.attributes["expansionMode"]

  @expansionMode.setter
  def expansionMode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["expansionMode"] = value

  @builtins.property
  def padValue(self):
    if "padValue" not in self.operation.attributes:
      return None
    return self.operation.attributes["padValue"]

  @padValue.setter
  def padValue(self, value):
    if value is not None:
      self.operation.attributes["padValue"] = value
    elif "padValue" in self.operation.attributes:
      del self.operation.attributes["padValue"]

  @padValue.deleter
  def padValue(self):
    del self.operation.attributes["padValue"]

  @builtins.property
  def foldable(self):
    return self.operation.attributes["foldable"]

  @foldable.setter
  def foldable(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["foldable"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

def pad(output, input, begin, end, *, expansion_mode=None, pad_value=None, foldable=None, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(PadOp(output=output, input=input, begin=begin, end=end, expansionMode=expansion_mode, padValue=pad_value, foldable=foldable, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class PointPillarPreProcessOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.point_pillar_preprocess"

  _ODS_REGIONS = (0, True)

  def __init__(self, voxels, coords, points, pcRanges, voxelSizes, maxVoxelNum, maxPointsPerVoxel, *, normRanges=None, normDims=None, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(points))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["pcRanges"] = (pcRanges if (
    isinstance(pcRanges, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('F64ArrayAttr')(pcRanges, context=_ods_context))
    if normRanges is not None: attributes["normRanges"] = (normRanges if (
        isinstance(normRanges, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('F64ArrayAttr')(normRanges, context=_ods_context))
    attributes["voxelSizes"] = (voxelSizes if (
    isinstance(voxelSizes, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('F64ArrayAttr')(voxelSizes, context=_ods_context))
    attributes["maxVoxelNum"] = (maxVoxelNum if (
    isinstance(maxVoxelNum, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(maxVoxelNum, context=_ods_context))
    attributes["maxPointsPerVoxel"] = (maxPointsPerVoxel if (
    isinstance(maxPointsPerVoxel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(maxPointsPerVoxel, context=_ods_context))
    if normDims is not None: attributes["normDims"] = (normDims if (
        isinstance(normDims, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(normDims, context=_ods_context))
    results.append(voxels)
    results.append(coords)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def points(self):
    return self.operation.operands[0]

  @builtins.property
  def pcRanges(self):
    return self.operation.attributes["pcRanges"]

  @pcRanges.setter
  def pcRanges(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["pcRanges"] = value

  @builtins.property
  def normRanges(self):
    if "normRanges" not in self.operation.attributes:
      return None
    return self.operation.attributes["normRanges"]

  @normRanges.setter
  def normRanges(self, value):
    if value is not None:
      self.operation.attributes["normRanges"] = value
    elif "normRanges" in self.operation.attributes:
      del self.operation.attributes["normRanges"]

  @normRanges.deleter
  def normRanges(self):
    del self.operation.attributes["normRanges"]

  @builtins.property
  def voxelSizes(self):
    return self.operation.attributes["voxelSizes"]

  @voxelSizes.setter
  def voxelSizes(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["voxelSizes"] = value

  @builtins.property
  def maxVoxelNum(self):
    return self.operation.attributes["maxVoxelNum"]

  @maxVoxelNum.setter
  def maxVoxelNum(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["maxVoxelNum"] = value

  @builtins.property
  def maxPointsPerVoxel(self):
    return self.operation.attributes["maxPointsPerVoxel"]

  @maxPointsPerVoxel.setter
  def maxPointsPerVoxel(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["maxPointsPerVoxel"] = value

  @builtins.property
  def normDims(self):
    return self.operation.attributes["normDims"]

  @normDims.setter
  def normDims(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["normDims"] = value

  @builtins.property
  def voxels(self):
    return self.operation.results[0]

  @builtins.property
  def coords(self):
    return self.operation.results[1]

def point_pillar_preprocess(voxels, coords, points, pc_ranges, voxel_sizes, max_voxel_num, max_points_per_voxel, *, norm_ranges=None, norm_dims=None, extra=None, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return _get_op_result_or_op_results(PointPillarPreProcessOp(voxels=voxels, coords=coords, points=points, pcRanges=pc_ranges, voxelSizes=voxel_sizes, maxVoxelNum=max_voxel_num, maxPointsPerVoxel=max_points_per_voxel, normRanges=norm_ranges, normDims=norm_dims, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class PointPillarScatterOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.point_pillar_scatter"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, voxels, coords, outShape, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(voxels))
    operands.append(_get_op_result_or_value(coords))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["outShape"] = (outShape if (
    isinstance(outShape, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Hbdk_I64ArrayAttr4')) else
      _ods_ir.AttrBuilder.get('Hbdk_I64ArrayAttr4')(outShape, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def voxels(self):
    return self.operation.operands[0]

  @builtins.property
  def coords(self):
    return self.operation.operands[1]

  @builtins.property
  def outShape(self):
    return self.operation.attributes["outShape"]

  @outShape.setter
  def outShape(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outShape"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

def point_pillar_scatter(output, voxels, coords, out_shape, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(PointPillarScatterOp(output=output, voxels=voxels, coords=coords, outShape=out_shape, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class PowOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.pow"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, lhs, rhs, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def pow(output, lhs, rhs, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(PowOp(output=output, lhs=lhs, rhs=rhs, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class PreluOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.prelu"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, slope, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(slope))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def slope(self):
    return self.operation.operands[1]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def prelu(output, input, slope, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(PreluOp(output=output, input=input, slope=slope, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class ReLUOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.relu"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def relu(output, input, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(ReLUOp(output=output, input=input, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class ReciprocalOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.reciprocal"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def reciprocal(output, input, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(ReciprocalOp(output=output, input=input, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class ReduceAllOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.reduce_all"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, dims, *, keepDim=None, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dims"] = (dims if (
    isinstance(dims, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(dims, context=_ods_context))
    if keepDim is not None: attributes["keepDim"] = (keepDim if (
        isinstance(keepDim, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(keepDim, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def dims(self):
    return self.operation.attributes["dims"]

  @dims.setter
  def dims(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dims"] = value

  @builtins.property
  def keepDim(self):
    return self.operation.attributes["keepDim"]

  @keepDim.setter
  def keepDim(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["keepDim"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

def reduce_all(output, input, dims, *, keep_dim=None, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(ReduceAllOp(output=output, input=input, dims=dims, keepDim=keep_dim, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class ReduceArgmaxOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.reduce_argmax"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, dims, *, keepDim=None, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dims"] = (dims if (
    isinstance(dims, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(dims, context=_ods_context))
    if keepDim is not None: attributes["keepDim"] = (keepDim if (
        isinstance(keepDim, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(keepDim, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def dims(self):
    return self.operation.attributes["dims"]

  @dims.setter
  def dims(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dims"] = value

  @builtins.property
  def keepDim(self):
    return self.operation.attributes["keepDim"]

  @keepDim.setter
  def keepDim(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["keepDim"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

def reduce_argmax(output, input, dims, *, keep_dim=None, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(ReduceArgmaxOp(output=output, input=input, dims=dims, keepDim=keep_dim, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class ReduceArgminOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.reduce_argmin"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, dims, *, keepDim=None, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dims"] = (dims if (
    isinstance(dims, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(dims, context=_ods_context))
    if keepDim is not None: attributes["keepDim"] = (keepDim if (
        isinstance(keepDim, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(keepDim, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def dims(self):
    return self.operation.attributes["dims"]

  @dims.setter
  def dims(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dims"] = value

  @builtins.property
  def keepDim(self):
    return self.operation.attributes["keepDim"]

  @keepDim.setter
  def keepDim(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["keepDim"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

def reduce_argmin(output, input, dims, *, keep_dim=None, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(ReduceArgminOp(output=output, input=input, dims=dims, keepDim=keep_dim, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class ReduceLogSumOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.reduce_logsum"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, dims, *, keepDim=None, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dims"] = (dims if (
    isinstance(dims, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(dims, context=_ods_context))
    if keepDim is not None: attributes["keepDim"] = (keepDim if (
        isinstance(keepDim, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(keepDim, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def dims(self):
    return self.operation.attributes["dims"]

  @dims.setter
  def dims(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dims"] = value

  @builtins.property
  def keepDim(self):
    return self.operation.attributes["keepDim"]

  @keepDim.setter
  def keepDim(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["keepDim"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

def reduce_logsum(output, input, dims, *, keep_dim=None, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(ReduceLogSumOp(output=output, input=input, dims=dims, keepDim=keep_dim, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class ReduceMaxOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.reduce_max"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, dims, *, keepDim=None, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dims"] = (dims if (
    isinstance(dims, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(dims, context=_ods_context))
    if keepDim is not None: attributes["keepDim"] = (keepDim if (
        isinstance(keepDim, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(keepDim, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def dims(self):
    return self.operation.attributes["dims"]

  @dims.setter
  def dims(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dims"] = value

  @builtins.property
  def keepDim(self):
    return self.operation.attributes["keepDim"]

  @keepDim.setter
  def keepDim(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["keepDim"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

def reduce_max(output, input, dims, *, keep_dim=None, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(ReduceMaxOp(output=output, input=input, dims=dims, keepDim=keep_dim, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class ReduceMeanOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.reduce_mean"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, dims, *, keepDim=None, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dims"] = (dims if (
    isinstance(dims, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(dims, context=_ods_context))
    if keepDim is not None: attributes["keepDim"] = (keepDim if (
        isinstance(keepDim, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(keepDim, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def dims(self):
    return self.operation.attributes["dims"]

  @dims.setter
  def dims(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dims"] = value

  @builtins.property
  def keepDim(self):
    return self.operation.attributes["keepDim"]

  @keepDim.setter
  def keepDim(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["keepDim"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

def reduce_mean(output, input, dims, *, keep_dim=None, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(ReduceMeanOp(output=output, input=input, dims=dims, keepDim=keep_dim, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class ReduceMinOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.reduce_min"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, dims, *, keepDim=None, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dims"] = (dims if (
    isinstance(dims, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(dims, context=_ods_context))
    if keepDim is not None: attributes["keepDim"] = (keepDim if (
        isinstance(keepDim, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(keepDim, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def dims(self):
    return self.operation.attributes["dims"]

  @dims.setter
  def dims(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dims"] = value

  @builtins.property
  def keepDim(self):
    return self.operation.attributes["keepDim"]

  @keepDim.setter
  def keepDim(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["keepDim"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

def reduce_min(output, input, dims, *, keep_dim=None, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(ReduceMinOp(output=output, input=input, dims=dims, keepDim=keep_dim, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class ReduceProdOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.reduce_prod"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, dims, *, keepDim=None, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dims"] = (dims if (
    isinstance(dims, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(dims, context=_ods_context))
    if keepDim is not None: attributes["keepDim"] = (keepDim if (
        isinstance(keepDim, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(keepDim, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def dims(self):
    return self.operation.attributes["dims"]

  @dims.setter
  def dims(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dims"] = value

  @builtins.property
  def keepDim(self):
    return self.operation.attributes["keepDim"]

  @keepDim.setter
  def keepDim(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["keepDim"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

def reduce_prod(output, input, dims, *, keep_dim=None, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(ReduceProdOp(output=output, input=input, dims=dims, keepDim=keep_dim, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class ReduceSumOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.reduce_sum"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, dims, *, keepDim=None, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dims"] = (dims if (
    isinstance(dims, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(dims, context=_ods_context))
    if keepDim is not None: attributes["keepDim"] = (keepDim if (
        isinstance(keepDim, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(keepDim, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def dims(self):
    return self.operation.attributes["dims"]

  @dims.setter
  def dims(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dims"] = value

  @builtins.property
  def keepDim(self):
    return self.operation.attributes["keepDim"]

  @keepDim.setter
  def keepDim(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["keepDim"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

def reduce_sum(output, input, dims, *, keep_dim=None, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(ReduceSumOp(output=output, input=input, dims=dims, keepDim=keep_dim, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class ReduceSumSquareOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.reduce_sumsquare"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, dims, *, keepDim=None, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dims"] = (dims if (
    isinstance(dims, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(dims, context=_ods_context))
    if keepDim is not None: attributes["keepDim"] = (keepDim if (
        isinstance(keepDim, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(keepDim, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def dims(self):
    return self.operation.attributes["dims"]

  @dims.setter
  def dims(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dims"] = value

  @builtins.property
  def keepDim(self):
    return self.operation.attributes["keepDim"]

  @keepDim.setter
  def keepDim(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["keepDim"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

def reduce_sumsquare(output, input, dims, *, keep_dim=None, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(ReduceSumSquareOp(output=output, input=input, dims=dims, keepDim=keep_dim, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class ReshapeOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.reshape"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, shape, *, foldable=None, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["shape"] = (shape if (
    isinstance(shape, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(shape, context=_ods_context))
    if foldable is not None: attributes["foldable"] = (foldable if (
        isinstance(foldable, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(foldable, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def shape(self):
    return self.operation.attributes["shape"]

  @shape.setter
  def shape(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["shape"] = value

  @builtins.property
  def foldable(self):
    return self.operation.attributes["foldable"]

  @foldable.setter
  def foldable(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["foldable"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

def reshape(output, input, shape, *, foldable=None, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(ReshapeOp(output=output, input=input, shape=shape, foldable=foldable, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class Resize2dOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.resize2d"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, step, *, ratio=None, size=None, initialOffset=None, mode=None, expansionMode=None, padValue=None, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    if ratio is not None: attributes["ratio"] = (ratio if (
        isinstance(ratio, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('F64ArrayAttr')(ratio, context=_ods_context))
    if size is not None: attributes["size"] = (size if (
        isinstance(size, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(size, context=_ods_context))
    attributes["step"] = (step if (
    isinstance(step, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Hbdk_F64ArrayAttr2')) else
      _ods_ir.AttrBuilder.get('Hbdk_F64ArrayAttr2')(step, context=_ods_context))
    if initialOffset is not None: attributes["initialOffset"] = (initialOffset if (
        isinstance(initialOffset, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('F64ArrayAttr')(initialOffset, context=_ods_context))
    if mode is not None: attributes["mode"] = (mode if (
        isinstance(mode, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('InterpolationModeAttr')) else
          _ods_ir.AttrBuilder.get('InterpolationModeAttr')(mode, context=_ods_context))
    if expansionMode is not None: attributes["expansionMode"] = (expansionMode if (
        isinstance(expansionMode, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('ExpansionModeAttr')) else
          _ods_ir.AttrBuilder.get('ExpansionModeAttr')(expansionMode, context=_ods_context))
    if padValue is not None: attributes["padValue"] = (padValue if (
        isinstance(padValue, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_984')) else
          _ods_ir.AttrBuilder.get('anonymous_984')(padValue, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def ratio(self):
    if "ratio" not in self.operation.attributes:
      return None
    return self.operation.attributes["ratio"]

  @ratio.setter
  def ratio(self, value):
    if value is not None:
      self.operation.attributes["ratio"] = value
    elif "ratio" in self.operation.attributes:
      del self.operation.attributes["ratio"]

  @ratio.deleter
  def ratio(self):
    del self.operation.attributes["ratio"]

  @builtins.property
  def size(self):
    if "size" not in self.operation.attributes:
      return None
    return self.operation.attributes["size"]

  @size.setter
  def size(self, value):
    if value is not None:
      self.operation.attributes["size"] = value
    elif "size" in self.operation.attributes:
      del self.operation.attributes["size"]

  @size.deleter
  def size(self):
    del self.operation.attributes["size"]

  @builtins.property
  def step(self):
    return self.operation.attributes["step"]

  @step.setter
  def step(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["step"] = value

  @builtins.property
  def initialOffset(self):
    return self.operation.attributes["initialOffset"]

  @initialOffset.setter
  def initialOffset(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["initialOffset"] = value

  @builtins.property
  def mode(self):
    return self.operation.attributes["mode"]

  @mode.setter
  def mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mode"] = value

  @builtins.property
  def expansionMode(self):
    return self.operation.attributes["expansionMode"]

  @expansionMode.setter
  def expansionMode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["expansionMode"] = value

  @builtins.property
  def padValue(self):
    if "padValue" not in self.operation.attributes:
      return None
    return self.operation.attributes["padValue"]

  @padValue.setter
  def padValue(self, value):
    if value is not None:
      self.operation.attributes["padValue"] = value
    elif "padValue" in self.operation.attributes:
      del self.operation.attributes["padValue"]

  @padValue.deleter
  def padValue(self):
    del self.operation.attributes["padValue"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def resize2d(output, input, step, *, ratio=None, size=None, initial_offset=None, mode=None, expansion_mode=None, pad_value=None, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(Resize2dOp(output=output, input=input, step=step, ratio=ratio, size=size, initialOffset=initial_offset, mode=mode, expansionMode=expansion_mode, padValue=pad_value, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class RleOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.rle"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def rle(output, input, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(RleOp(output=output, input=input, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class RmsNormOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.rms_norm"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, dims, eps, *, weight=None, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    if weight is not None: operands.append(_get_op_result_or_value(weight))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dims"] = (dims if (
    isinstance(dims, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(dims, context=_ods_context))
    attributes["eps"] = (eps if (
    isinstance(eps, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(eps, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def weight(self):
    return None if len(self.operation.operands) < 2 else self.operation.operands[1]

  @builtins.property
  def dims(self):
    return self.operation.attributes["dims"]

  @dims.setter
  def dims(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dims"] = value

  @builtins.property
  def eps(self):
    return self.operation.attributes["eps"]

  @eps.setter
  def eps(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["eps"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

def rms_norm(output, input, dims, eps, *, weight=None, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(RmsNormOp(output=output, input=input, dims=dims, eps=eps, weight=weight, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class RoiAlignOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.roi_align"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, inputs, shape, featureStrides, samplingRatio, interpolateMode, canonicalBoxSize, canonicalLevel, *, boxClipRatio=None, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["shape"] = (shape if (
    isinstance(shape, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(shape, context=_ods_context))
    attributes["featureStrides"] = (featureStrides if (
    isinstance(featureStrides, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(featureStrides, context=_ods_context))
    attributes["samplingRatio"] = (samplingRatio if (
    isinstance(samplingRatio, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(samplingRatio, context=_ods_context))
    attributes["interpolateMode"] = (interpolateMode if (
    isinstance(interpolateMode, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(interpolateMode, context=_ods_context))
    attributes["canonicalBoxSize"] = (canonicalBoxSize if (
    isinstance(canonicalBoxSize, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(canonicalBoxSize, context=_ods_context))
    attributes["canonicalLevel"] = (canonicalLevel if (
    isinstance(canonicalLevel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(canonicalLevel, context=_ods_context))
    if boxClipRatio is not None: attributes["boxClipRatio"] = (boxClipRatio if (
        isinstance(boxClipRatio, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('F64ArrayAttr')(boxClipRatio, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def shape(self):
    return self.operation.attributes["shape"]

  @shape.setter
  def shape(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["shape"] = value

  @builtins.property
  def featureStrides(self):
    return self.operation.attributes["featureStrides"]

  @featureStrides.setter
  def featureStrides(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["featureStrides"] = value

  @builtins.property
  def samplingRatio(self):
    return self.operation.attributes["samplingRatio"]

  @samplingRatio.setter
  def samplingRatio(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["samplingRatio"] = value

  @builtins.property
  def interpolateMode(self):
    return self.operation.attributes["interpolateMode"]

  @interpolateMode.setter
  def interpolateMode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["interpolateMode"] = value

  @builtins.property
  def canonicalBoxSize(self):
    return self.operation.attributes["canonicalBoxSize"]

  @canonicalBoxSize.setter
  def canonicalBoxSize(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["canonicalBoxSize"] = value

  @builtins.property
  def canonicalLevel(self):
    return self.operation.attributes["canonicalLevel"]

  @canonicalLevel.setter
  def canonicalLevel(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["canonicalLevel"] = value

  @builtins.property
  def boxClipRatio(self):
    if "boxClipRatio" not in self.operation.attributes:
      return None
    return self.operation.attributes["boxClipRatio"]

  @boxClipRatio.setter
  def boxClipRatio(self, value):
    if value is not None:
      self.operation.attributes["boxClipRatio"] = value
    elif "boxClipRatio" in self.operation.attributes:
      del self.operation.attributes["boxClipRatio"]

  @boxClipRatio.deleter
  def boxClipRatio(self):
    del self.operation.attributes["boxClipRatio"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def roi_align(output, inputs, shape, feature_strides, sampling_ratio, interpolate_mode, canonical_box_size, canonical_level, *, box_clip_ratio=None, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(RoiAlignOp(output=output, inputs=inputs, shape=shape, featureStrides=feature_strides, samplingRatio=sampling_ratio, interpolateMode=interpolate_mode, canonicalBoxSize=canonical_box_size, canonicalLevel=canonical_level, boxClipRatio=box_clip_ratio, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class RoiResizeOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.roi_resize"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, y, roi, size, *, uv=None, padValue=None, mode=None, interpolateMode=None, expansionMode=None, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(y))
    if uv is not None: operands.append(_get_op_result_or_value(uv))
    operands.append(_get_op_result_or_value(roi))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["size"] = (size if (
    isinstance(size, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Hbdk_I64ArrayAttr2')) else
      _ods_ir.AttrBuilder.get('Hbdk_I64ArrayAttr2')(size, context=_ods_context))
    if padValue is not None: attributes["padValue"] = (padValue if (
        isinstance(padValue, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(padValue, context=_ods_context))
    if mode is not None: attributes["mode"] = (mode if (
        isinstance(mode, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('ImageConvertModeAttr')) else
          _ods_ir.AttrBuilder.get('ImageConvertModeAttr')(mode, context=_ods_context))
    if interpolateMode is not None: attributes["interpolateMode"] = (interpolateMode if (
        isinstance(interpolateMode, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('InterpolationModeAttr')) else
          _ods_ir.AttrBuilder.get('InterpolationModeAttr')(interpolateMode, context=_ods_context))
    if expansionMode is not None: attributes["expansionMode"] = (expansionMode if (
        isinstance(expansionMode, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('ExpansionModeAttr')) else
          _ods_ir.AttrBuilder.get('ExpansionModeAttr')(expansionMode, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def y(self):
    return self.operation.operands[0]

  @builtins.property
  def uv(self):
    return None if len(self.operation.operands) < 3 else self.operation.operands[1]

  @builtins.property
  def roi(self):
    _ods_variadic_group_length = len(self.operation.operands) - 3 + 1
    return self.operation.operands[2 + _ods_variadic_group_length - 1]

  @builtins.property
  def size(self):
    return self.operation.attributes["size"]

  @size.setter
  def size(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["size"] = value

  @builtins.property
  def padValue(self):
    return self.operation.attributes["padValue"]

  @padValue.setter
  def padValue(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["padValue"] = value

  @builtins.property
  def mode(self):
    return self.operation.attributes["mode"]

  @mode.setter
  def mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mode"] = value

  @builtins.property
  def interpolateMode(self):
    return self.operation.attributes["interpolateMode"]

  @interpolateMode.setter
  def interpolateMode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["interpolateMode"] = value

  @builtins.property
  def expansionMode(self):
    return self.operation.attributes["expansionMode"]

  @expansionMode.setter
  def expansionMode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["expansionMode"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

def roi_resize(output, y, roi, size, *, uv=None, pad_value=None, mode=None, interpolate_mode=None, expansion_mode=None, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(RoiResizeOp(output=output, y=y, roi=roi, size=size, uv=uv, padValue=pad_value, mode=mode, interpolateMode=interpolate_mode, expansionMode=expansion_mode, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class RollOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.roll"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, shifts, dims, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["shifts"] = (shifts if (
    isinstance(shifts, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(shifts, context=_ods_context))
    attributes["dims"] = (dims if (
    isinstance(dims, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(dims, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def shifts(self):
    return self.operation.attributes["shifts"]

  @shifts.setter
  def shifts(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["shifts"] = value

  @builtins.property
  def dims(self):
    return self.operation.attributes["dims"]

  @dims.setter
  def dims(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dims"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

def roll(output, input, shifts, dims, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(RollOp(output=output, input=input, shifts=shifts, dims=dims, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class RoundOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.round"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, decimals=None, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    if decimals is not None: attributes["decimals"] = (decimals if (
        isinstance(decimals, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(decimals, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def decimals(self):
    return self.operation.attributes["decimals"]

  @decimals.setter
  def decimals(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["decimals"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

def round(output, input, *, decimals=None, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(RoundOp(output=output, input=input, decimals=decimals, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class RppOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.rpp"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, roi, inputs, boxnum, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(roi))
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["boxnum"] = (boxnum if (
    isinstance(boxnum, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(boxnum, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def roi(self):
    return self.operation.operands[0]

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def boxnum(self):
    return self.operation.attributes["boxnum"]

  @boxnum.setter
  def boxnum(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["boxnum"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

def rpp(output, roi, inputs, boxnum, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(RppOp(output=output, roi=roi, inputs=inputs, boxnum=boxnum, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class RppV2Op(_ods_ir.OpView):
  OPERATION_NAME = "hbir.rpp_v2"

  _ODS_REGIONS = (0, True)

  def __init__(self, int_output, float_output, bbox_data, bbox_score, bbox_deltas, *, original_img_h=None, original_img_w=None, nms_threshold=None, score_threshold=None, class_number=None, nms_top_n=None, bbox_delta_mean=None, bbox_delta_std=None, image_size_fixed=None, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(bbox_data))
    operands.append(_get_op_result_or_value(bbox_score))
    operands.append(_get_op_result_or_value(bbox_deltas))
    _ods_context = _ods_get_default_loc_context(loc)
    if original_img_h is not None: attributes["original_img_h"] = (original_img_h if (
        isinstance(original_img_h, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(original_img_h, context=_ods_context))
    if original_img_w is not None: attributes["original_img_w"] = (original_img_w if (
        isinstance(original_img_w, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(original_img_w, context=_ods_context))
    if nms_threshold is not None: attributes["nms_threshold"] = (nms_threshold if (
        isinstance(nms_threshold, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(nms_threshold, context=_ods_context))
    if score_threshold is not None: attributes["score_threshold"] = (score_threshold if (
        isinstance(score_threshold, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(score_threshold, context=_ods_context))
    if class_number is not None: attributes["class_number"] = (class_number if (
        isinstance(class_number, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(class_number, context=_ods_context))
    if nms_top_n is not None: attributes["nms_top_n"] = (nms_top_n if (
        isinstance(nms_top_n, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(nms_top_n, context=_ods_context))
    if bbox_delta_mean is not None: attributes["bbox_delta_mean"] = (bbox_delta_mean if (
        isinstance(bbox_delta_mean, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('F64ArrayAttr')(bbox_delta_mean, context=_ods_context))
    if bbox_delta_std is not None: attributes["bbox_delta_std"] = (bbox_delta_std if (
        isinstance(bbox_delta_std, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('F64ArrayAttr')(bbox_delta_std, context=_ods_context))
    if image_size_fixed is not None: attributes["image_size_fixed"] = (image_size_fixed if (
        isinstance(image_size_fixed, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(image_size_fixed, context=_ods_context))
    results.append(int_output)
    results.append(float_output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def bbox_data(self):
    return self.operation.operands[0]

  @builtins.property
  def bbox_score(self):
    return self.operation.operands[1]

  @builtins.property
  def bbox_deltas(self):
    return self.operation.operands[2]

  @builtins.property
  def original_img_h(self):
    return self.operation.attributes["original_img_h"]

  @original_img_h.setter
  def original_img_h(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["original_img_h"] = value

  @builtins.property
  def original_img_w(self):
    return self.operation.attributes["original_img_w"]

  @original_img_w.setter
  def original_img_w(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["original_img_w"] = value

  @builtins.property
  def nms_threshold(self):
    return self.operation.attributes["nms_threshold"]

  @nms_threshold.setter
  def nms_threshold(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["nms_threshold"] = value

  @builtins.property
  def score_threshold(self):
    return self.operation.attributes["score_threshold"]

  @score_threshold.setter
  def score_threshold(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["score_threshold"] = value

  @builtins.property
  def class_number(self):
    return self.operation.attributes["class_number"]

  @class_number.setter
  def class_number(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["class_number"] = value

  @builtins.property
  def nms_top_n(self):
    return self.operation.attributes["nms_top_n"]

  @nms_top_n.setter
  def nms_top_n(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["nms_top_n"] = value

  @builtins.property
  def bbox_delta_mean(self):
    return self.operation.attributes["bbox_delta_mean"]

  @bbox_delta_mean.setter
  def bbox_delta_mean(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["bbox_delta_mean"] = value

  @builtins.property
  def bbox_delta_std(self):
    return self.operation.attributes["bbox_delta_std"]

  @bbox_delta_std.setter
  def bbox_delta_std(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["bbox_delta_std"] = value

  @builtins.property
  def image_size_fixed(self):
    return self.operation.attributes["image_size_fixed"]

  @image_size_fixed.setter
  def image_size_fixed(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["image_size_fixed"] = value

  @builtins.property
  def int_output(self):
    return self.operation.results[0]

  @builtins.property
  def float_output(self):
    return self.operation.results[1]

def rpp_v2(int_output, float_output, bbox_data, bbox_score, bbox_deltas, *, original_img_h=None, original_img_w=None, nms_threshold=None, score_threshold=None, class_number=None, nms_top_n=None, bbox_delta_mean=None, bbox_delta_std=None, image_size_fixed=None, extra=None, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return _get_op_result_or_op_results(RppV2Op(int_output=int_output, float_output=float_output, bbox_data=bbox_data, bbox_score=bbox_score, bbox_deltas=bbox_deltas, original_img_h=original_img_h, original_img_w=original_img_w, nms_threshold=nms_threshold, score_threshold=score_threshold, class_number=class_number, nms_top_n=nms_top_n, bbox_delta_mean=bbox_delta_mean, bbox_delta_std=bbox_delta_std, image_size_fixed=image_size_fixed, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class RsqrtOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.rsqrt"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def rsqrt(output, input, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(RsqrtOp(output=output, input=input, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class ScatterElementsOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.scatter_elements"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, data, indices, updates, *, axis=None, scatterReduceMode=None, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(data))
    operands.append(_get_op_result_or_value(indices))
    operands.append(_get_op_result_or_value(updates))
    _ods_context = _ods_get_default_loc_context(loc)
    if axis is not None: attributes["axis"] = (axis if (
        isinstance(axis, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(axis, context=_ods_context))
    if scatterReduceMode is not None: attributes["scatterReduceMode"] = (scatterReduceMode if (
        isinstance(scatterReduceMode, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('ScatterReduceModeAttr')) else
          _ods_ir.AttrBuilder.get('ScatterReduceModeAttr')(scatterReduceMode, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def data(self):
    return self.operation.operands[0]

  @builtins.property
  def indices(self):
    return self.operation.operands[1]

  @builtins.property
  def updates(self):
    return self.operation.operands[2]

  @builtins.property
  def axis(self):
    return self.operation.attributes["axis"]

  @axis.setter
  def axis(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axis"] = value

  @builtins.property
  def scatterReduceMode(self):
    return self.operation.attributes["scatterReduceMode"]

  @scatterReduceMode.setter
  def scatterReduceMode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scatterReduceMode"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

def scatter_elements(output, data, indices, updates, *, axis=None, scatter_reduce_mode=None, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(ScatterElementsOp(output=output, data=data, indices=indices, updates=updates, axis=axis, scatterReduceMode=scatter_reduce_mode, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class ScatterNDOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.scatter_nd"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, data, indices, updates, *, scatterReduceMode=None, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(data))
    operands.append(_get_op_result_or_value(indices))
    operands.append(_get_op_result_or_value(updates))
    _ods_context = _ods_get_default_loc_context(loc)
    if scatterReduceMode is not None: attributes["scatterReduceMode"] = (scatterReduceMode if (
        isinstance(scatterReduceMode, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('ScatterReduceModeAttr')) else
          _ods_ir.AttrBuilder.get('ScatterReduceModeAttr')(scatterReduceMode, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def data(self):
    return self.operation.operands[0]

  @builtins.property
  def indices(self):
    return self.operation.operands[1]

  @builtins.property
  def updates(self):
    return self.operation.operands[2]

  @builtins.property
  def scatterReduceMode(self):
    return self.operation.attributes["scatterReduceMode"]

  @scatterReduceMode.setter
  def scatterReduceMode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scatterReduceMode"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

def scatter_nd(output, data, indices, updates, *, scatter_reduce_mode=None, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(ScatterNDOp(output=output, data=data, indices=indices, updates=updates, scatterReduceMode=scatter_reduce_mode, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class SelectOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.select"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, dim, index, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dim"] = (dim if (
    isinstance(dim, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(dim, context=_ods_context))
    attributes["index"] = (index if (
    isinstance(index, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(index, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def dim(self):
    return self.operation.attributes["dim"]

  @dim.setter
  def dim(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dim"] = value

  @builtins.property
  def index(self):
    return self.operation.attributes["index"]

  @index.setter
  def index(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["index"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

def select(output, input, dim, index, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(SelectOp(output=output, input=input, dim=dim, index=index, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class ShuffleFactorOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.shufflefactor"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, factors, dims, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["factors"] = (factors if (
    isinstance(factors, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(factors, context=_ods_context))
    attributes["dims"] = (dims if (
    isinstance(dims, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(dims, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def factors(self):
    return self.operation.attributes["factors"]

  @factors.setter
  def factors(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["factors"] = value

  @builtins.property
  def dims(self):
    return self.operation.attributes["dims"]

  @dims.setter
  def dims(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dims"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

def shufflefactor(output, input, factors, dims, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(ShuffleFactorOp(output=output, input=input, factors=factors, dims=dims, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class SigmoidOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.sigmoid"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def sigmoid(output, input, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(SigmoidOp(output=output, input=input, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class SignOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.sign"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def sign(output, input, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(SignOp(output=output, input=input, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class SinOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.sin"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def sin(output, input, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(SinOp(output=output, input=input, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class SinhOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.sinh"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def sinh(output, input, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(SinhOp(output=output, input=input, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class SliceOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.slice"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, begin, end, step, *, foldable=None, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["begin"] = (begin if (
    isinstance(begin, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(begin, context=_ods_context))
    attributes["end"] = (end if (
    isinstance(end, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(end, context=_ods_context))
    attributes["step"] = (step if (
    isinstance(step, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(step, context=_ods_context))
    if foldable is not None: attributes["foldable"] = (foldable if (
        isinstance(foldable, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(foldable, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def begin(self):
    return self.operation.attributes["begin"]

  @begin.setter
  def begin(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["begin"] = value

  @builtins.property
  def end(self):
    return self.operation.attributes["end"]

  @end.setter
  def end(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["end"] = value

  @builtins.property
  def step(self):
    return self.operation.attributes["step"]

  @step.setter
  def step(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["step"] = value

  @builtins.property
  def foldable(self):
    return self.operation.attributes["foldable"]

  @foldable.setter
  def foldable(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["foldable"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

def slice(output, input, begin, end, step, *, foldable=None, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(SliceOp(output=output, input=input, begin=begin, end=end, step=step, foldable=foldable, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class SliceScatterOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.slice_scatter"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, src, dim, start, end, *, step=None, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(src))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dim"] = (dim if (
    isinstance(dim, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(dim, context=_ods_context))
    attributes["start"] = (start if (
    isinstance(start, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(start, context=_ods_context))
    attributes["end"] = (end if (
    isinstance(end, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(end, context=_ods_context))
    if step is not None: attributes["step"] = (step if (
        isinstance(step, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(step, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def src(self):
    return self.operation.operands[1]

  @builtins.property
  def dim(self):
    return self.operation.attributes["dim"]

  @dim.setter
  def dim(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dim"] = value

  @builtins.property
  def start(self):
    return self.operation.attributes["start"]

  @start.setter
  def start(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["start"] = value

  @builtins.property
  def end(self):
    return self.operation.attributes["end"]

  @end.setter
  def end(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["end"] = value

  @builtins.property
  def step(self):
    return self.operation.attributes["step"]

  @step.setter
  def step(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["step"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

def slice_scatter(output, input, src, dim, start, end, *, step=None, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(SliceScatterOp(output=output, input=input, src=src, dim=dim, start=start, end=end, step=step, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class SoftmaxOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.softmax"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, dim, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dim"] = (dim if (
    isinstance(dim, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(dim, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def dim(self):
    return self.operation.attributes["dim"]

  @dim.setter
  def dim(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dim"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

def softmax(output, input, dim, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(SoftmaxOp(output=output, input=input, dim=dim, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class SoftplusOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.softplus"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, beta, threshold, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["beta"] = (beta if (
    isinstance(beta, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(beta, context=_ods_context))
    attributes["threshold"] = (threshold if (
    isinstance(threshold, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(threshold, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def beta(self):
    return self.operation.attributes["beta"]

  @beta.setter
  def beta(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["beta"] = value

  @builtins.property
  def threshold(self):
    return self.operation.attributes["threshold"]

  @threshold.setter
  def threshold(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["threshold"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

def softplus(output, input, beta, threshold, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(SoftplusOp(output=output, input=input, beta=beta, threshold=threshold, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class SortOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.sort"

  _ODS_REGIONS = (0, True)

  def __init__(self, values, indices, input, *, dim=None, descending=None, stable=None, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    if dim is not None: attributes["dim"] = (dim if (
        isinstance(dim, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(dim, context=_ods_context))
    if descending is not None: attributes["descending"] = (descending if (
        isinstance(descending, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(descending, context=_ods_context))
    if stable is not None: attributes["stable"] = (stable if (
        isinstance(stable, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(stable, context=_ods_context))
    results.append(values)
    results.append(indices)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def dim(self):
    return self.operation.attributes["dim"]

  @dim.setter
  def dim(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dim"] = value

  @builtins.property
  def descending(self):
    return self.operation.attributes["descending"]

  @descending.setter
  def descending(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["descending"] = value

  @builtins.property
  def stable(self):
    return self.operation.attributes["stable"]

  @stable.setter
  def stable(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["stable"] = value

  @builtins.property
  def values(self):
    return self.operation.results[0]

  @builtins.property
  def indices(self):
    return self.operation.results[1]

def sort(values, indices, input, *, dim=None, descending=None, stable=None, extra=None, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return _get_op_result_or_op_results(SortOp(values=values, indices=indices, input=input, dim=dim, descending=descending, stable=stable, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class SqrtOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.sqrt"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def sqrt(output, input, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(SqrtOp(output=output, input=input, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class StackOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.stack"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, inputs, dim, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dim"] = (dim if (
    isinstance(dim, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(dim, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def dim(self):
    return self.operation.attributes["dim"]

  @dim.setter
  def dim(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dim"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

def stack(output, inputs, dim, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(StackOp(output=output, inputs=inputs, dim=dim, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class SubOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.sub"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, lhs, rhs, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def sub(output, lhs, rhs, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(SubOp(output=output, lhs=lhs, rhs=rhs, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class SwishOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.swish"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def swish(output, input, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(SwishOp(output=output, input=input, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class TanOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.tan"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def tan(output, input, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(TanOp(output=output, input=input, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class TanhOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.tanh"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def tanh(output, input, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(TanhOp(output=output, input=input, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class TileOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.tile"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, multiplies, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["multiplies"] = (multiplies if (
    isinstance(multiplies, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(multiplies, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def multiplies(self):
    return self.operation.attributes["multiplies"]

  @multiplies.setter
  def multiplies(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["multiplies"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

def tile(output, input, multiplies, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(TileOp(output=output, input=input, multiplies=multiplies, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class TopkOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.topk"

  _ODS_REGIONS = (0, True)

  def __init__(self, values, indices, input, k, *, dim=None, largest=None, sorted=None, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["k"] = (k if (
    isinstance(k, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(k, context=_ods_context))
    if dim is not None: attributes["dim"] = (dim if (
        isinstance(dim, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(dim, context=_ods_context))
    if largest is not None: attributes["largest"] = (largest if (
        isinstance(largest, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(largest, context=_ods_context))
    if sorted is not None: attributes["sorted"] = (sorted if (
        isinstance(sorted, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(sorted, context=_ods_context))
    results.append(values)
    results.append(indices)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def k(self):
    return self.operation.attributes["k"]

  @k.setter
  def k(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["k"] = value

  @builtins.property
  def dim(self):
    return self.operation.attributes["dim"]

  @dim.setter
  def dim(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dim"] = value

  @builtins.property
  def largest(self):
    return self.operation.attributes["largest"]

  @largest.setter
  def largest(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["largest"] = value

  @builtins.property
  def sorted(self):
    return self.operation.attributes["sorted"]

  @sorted.setter
  def sorted(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sorted"] = value

  @builtins.property
  def values(self):
    return self.operation.results[0]

  @builtins.property
  def indices(self):
    return self.operation.results[1]

def topk(values, indices, input, k, *, dim=None, largest=None, sorted=None, extra=None, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return _get_op_result_or_op_results(TopkOp(values=values, indices=indices, input=input, k=k, dim=dim, largest=largest, sorted=sorted, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class TransposeOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.transpose"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, dims, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dims"] = (dims if (
    isinstance(dims, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(dims, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def dims(self):
    return self.operation.attributes["dims"]

  @dims.setter
  def dims(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dims"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

def transpose(output, input, dims, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(TransposeOp(output=output, input=input, dims=dims, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class TritonCallOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.triton_call"

  _ODS_REGIONS = (0, True)

  def __init__(self, inputs, signature, inputIndices, outputIndices, ttir, *, inputOutputIndices=None, parameters=None, library=None, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["signature"] = (signature if (
    isinstance(signature, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(signature, context=_ods_context))
    attributes["inputIndices"] = (inputIndices if (
    isinstance(inputIndices, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ArrayAttr')) else
      _ods_ir.AttrBuilder.get('ArrayAttr')(inputIndices, context=_ods_context))
    attributes["outputIndices"] = (outputIndices if (
    isinstance(outputIndices, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ArrayAttr')) else
      _ods_ir.AttrBuilder.get('ArrayAttr')(outputIndices, context=_ods_context))
    attributes["ttir"] = (ttir if (
    isinstance(ttir, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(ttir, context=_ods_context))
    if inputOutputIndices is not None: attributes["inputOutputIndices"] = (inputOutputIndices if (
        isinstance(inputOutputIndices, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('ArrayAttr')) else
          _ods_ir.AttrBuilder.get('ArrayAttr')(inputOutputIndices, context=_ods_context))
    if parameters is not None: attributes["parameters"] = (parameters if (
        isinstance(parameters, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('ArrayAttr')) else
          _ods_ir.AttrBuilder.get('ArrayAttr')(parameters, context=_ods_context))
    if library is not None: attributes["library"] = (library if (
        isinstance(library, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(library, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def signature(self):
    return self.operation.attributes["signature"]

  @signature.setter
  def signature(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["signature"] = value

  @builtins.property
  def inputIndices(self):
    return self.operation.attributes["inputIndices"]

  @inputIndices.setter
  def inputIndices(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["inputIndices"] = value

  @builtins.property
  def outputIndices(self):
    return self.operation.attributes["outputIndices"]

  @outputIndices.setter
  def outputIndices(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputIndices"] = value

  @builtins.property
  def ttir(self):
    return self.operation.attributes["ttir"]

  @ttir.setter
  def ttir(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["ttir"] = value

  @builtins.property
  def inputOutputIndices(self):
    if "inputOutputIndices" not in self.operation.attributes:
      return None
    return self.operation.attributes["inputOutputIndices"]

  @inputOutputIndices.setter
  def inputOutputIndices(self, value):
    if value is not None:
      self.operation.attributes["inputOutputIndices"] = value
    elif "inputOutputIndices" in self.operation.attributes:
      del self.operation.attributes["inputOutputIndices"]

  @inputOutputIndices.deleter
  def inputOutputIndices(self):
    del self.operation.attributes["inputOutputIndices"]

  @builtins.property
  def parameters(self):
    if "parameters" not in self.operation.attributes:
      return None
    return self.operation.attributes["parameters"]

  @parameters.setter
  def parameters(self, value):
    if value is not None:
      self.operation.attributes["parameters"] = value
    elif "parameters" in self.operation.attributes:
      del self.operation.attributes["parameters"]

  @parameters.deleter
  def parameters(self):
    del self.operation.attributes["parameters"]

  @builtins.property
  def library(self):
    if "library" not in self.operation.attributes:
      return None
    return self.operation.attributes["library"]

  @library.setter
  def library(self, value):
    if value is not None:
      self.operation.attributes["library"] = value
    elif "library" in self.operation.attributes:
      del self.operation.attributes["library"]

  @library.deleter
  def library(self):
    del self.operation.attributes["library"]

def triton_call(inputs, signature, input_indices, output_indices, ttir, *, input_output_indices=None, parameters=None, library=None, extra=None, loc=None, ip=None) -> _ods_ir.Operation:
  return _get_op_result_or_op_results(TritonCallOp(inputs=inputs, signature=signature, inputIndices=input_indices, outputIndices=output_indices, ttir=ttir, inputOutputIndices=input_output_indices, parameters=parameters, library=library, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class TupleGetOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.tuple_get"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, index, *, name=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["index"] = (index if (
    isinstance(index, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(index, context=_ods_context))
    if name is not None: attributes["name"] = (name if (
        isinstance(name, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(name, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def index(self):
    return self.operation.attributes["index"]

  @index.setter
  def index(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["index"] = value

  @builtins.property
  def name(self):
    if "name" not in self.operation.attributes:
      return None
    return self.operation.attributes["name"]

  @name.setter
  def name(self, value):
    if value is not None:
      self.operation.attributes["name"] = value
    elif "name" in self.operation.attributes:
      del self.operation.attributes["name"]

  @name.deleter
  def name(self):
    del self.operation.attributes["name"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def tuple_get(output, input, index, *, name=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(TupleGetOp(output=output, input=input, index=index, name=name, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class WarpOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.warp"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, move, *, mode=None, expansionMode=None, padValue=None, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(move))
    _ods_context = _ods_get_default_loc_context(loc)
    if mode is not None: attributes["mode"] = (mode if (
        isinstance(mode, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('InterpolationModeAttr')) else
          _ods_ir.AttrBuilder.get('InterpolationModeAttr')(mode, context=_ods_context))
    if expansionMode is not None: attributes["expansionMode"] = (expansionMode if (
        isinstance(expansionMode, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('ExpansionModeAttr')) else
          _ods_ir.AttrBuilder.get('ExpansionModeAttr')(expansionMode, context=_ods_context))
    if padValue is not None: attributes["padValue"] = (padValue if (
        isinstance(padValue, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_984')) else
          _ods_ir.AttrBuilder.get('anonymous_984')(padValue, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def move(self):
    return self.operation.operands[1]

  @builtins.property
  def mode(self):
    return self.operation.attributes["mode"]

  @mode.setter
  def mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mode"] = value

  @builtins.property
  def expansionMode(self):
    return self.operation.attributes["expansionMode"]

  @expansionMode.setter
  def expansionMode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["expansionMode"] = value

  @builtins.property
  def padValue(self):
    if "padValue" not in self.operation.attributes:
      return None
    return self.operation.attributes["padValue"]

  @padValue.setter
  def padValue(self, value):
    if value is not None:
      self.operation.attributes["padValue"] = value
    elif "padValue" in self.operation.attributes:
      del self.operation.attributes["padValue"]

  @padValue.deleter
  def padValue(self):
    del self.operation.attributes["padValue"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def warp(output, input, move, *, mode=None, expansion_mode=None, pad_value=None, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(WarpOp(output=output, input=input, move=move, mode=mode, expansionMode=expansion_mode, padValue=pad_value, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class WhereOp(_ods_ir.OpView):
  OPERATION_NAME = "hbir.where"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, condition, lhs, rhs, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(condition))
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def condition(self):
    return self.operation.operands[0]

  @builtins.property
  def lhs(self):
    return self.operation.operands[1]

  @builtins.property
  def rhs(self):
    return self.operation.operands[2]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def where(output, condition, lhs, rhs, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(WhereOp(output=output, condition=condition, lhs=lhs, rhs=rhs, extra=extra, loc=loc, ip=ip))
