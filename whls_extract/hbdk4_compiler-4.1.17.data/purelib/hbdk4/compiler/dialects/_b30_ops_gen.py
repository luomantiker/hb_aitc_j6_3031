
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import (
    equally_sized_accessor as _ods_equally_sized_accessor,
    get_default_loc_context as _ods_get_default_loc_context,
    get_op_result_or_op_results as _get_op_result_or_op_results,
    get_op_result_or_value as _get_op_result_or_value,
    get_op_results_or_values as _get_op_results_or_values,
    segmented_accessor as _ods_segmented_accessor,
)
_ods_ir = _ods_cext.ir

import builtins
from typing import Sequence as _Sequence, Union as _Union


@_ods_cext.register_dialect
class _Dialect(_ods_ir.Dialect):
  DIALECT_NAMESPACE = "b30"

@_ods_cext.register_operation(_Dialect)
class BinaryEltwiseOp(_ods_ir.OpView):
  OPERATION_NAME = "b30.binary_eltwise"

  _ODS_REGIONS = (1, True)

  def __init__(self, output, lhs, rhs, mode, *, quant_info=None, roundMode=None, saturate=None, perTensorQuant=None, instanceId=None, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    if quant_info is not None: operands.append(_get_op_result_or_value(quant_info))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["mode"] = (mode if (
    isinstance(mode, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('EltwiseModeAttr')) else
      _ods_ir.AttrBuilder.get('EltwiseModeAttr')(mode, context=_ods_context))
    if roundMode is not None: attributes["roundMode"] = (roundMode if (
        isinstance(roundMode, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('RoundModeAttr')) else
          _ods_ir.AttrBuilder.get('RoundModeAttr')(roundMode, context=_ods_context))
    if saturate is not None: attributes["saturate"] = (saturate if (
        isinstance(saturate, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(saturate, context=_ods_context))
    if perTensorQuant is not None: attributes["perTensorQuant"] = (perTensorQuant if (
        isinstance(perTensorQuant, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(perTensorQuant, context=_ods_context))
    if instanceId is not None: attributes["instanceId"] = (instanceId if (
        isinstance(instanceId, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(instanceId, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def quant_info(self):
    return None if len(self.operation.operands) < 3 else self.operation.operands[2]

  @builtins.property
  def mode(self):
    return self.operation.attributes["mode"]

  @mode.setter
  def mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mode"] = value

  @builtins.property
  def roundMode(self):
    return self.operation.attributes["roundMode"]

  @roundMode.setter
  def roundMode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["roundMode"] = value

  @builtins.property
  def saturate(self):
    return self.operation.attributes["saturate"]

  @saturate.setter
  def saturate(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["saturate"] = value

  @builtins.property
  def perTensorQuant(self):
    return self.operation.attributes["perTensorQuant"]

  @perTensorQuant.setter
  def perTensorQuant(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["perTensorQuant"] = value

  @builtins.property
  def instanceId(self):
    return self.operation.attributes["instanceId"]

  @instanceId.setter
  def instanceId(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["instanceId"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

  @builtins.property
  def body(self):
    return self.regions[0]

def binary_eltwise(output, lhs, rhs, mode, *, quant_info=None, round_mode=None, saturate=None, per_tensor_quant=None, instance_id=None, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(BinaryEltwiseOp(output=output, lhs=lhs, rhs=rhs, mode=mode, quant_info=quant_info, roundMode=round_mode, saturate=saturate, perTensorQuant=per_tensor_quant, instanceId=instance_id, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class Conv2dOp(_ods_ir.OpView):
  OPERATION_NAME = "b30.conv2d"

  _ODS_OPERAND_SEGMENTS = [1,1,1,0,0,]

  _ODS_REGIONS = (1, True)

  def __init__(self, output, input, weight, quantInfo, kernel, *, sumin=None, lutTable=None, groupSize=None, stride=None, pad=None, dilation=None, padValue=None, relu=None, instanceId=None, processDone=None, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(weight))
    operands.append(_get_op_result_or_value(quantInfo))
    operands.append(_get_op_result_or_value(sumin) if sumin is not None else None)
    operands.append(_get_op_result_or_value(lutTable) if lutTable is not None else None)
    _ods_context = _ods_get_default_loc_context(loc)
    if groupSize is not None: attributes["groupSize"] = (groupSize if (
        isinstance(groupSize, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(groupSize, context=_ods_context))
    attributes["kernel"] = (kernel if (
    isinstance(kernel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Hbdk_I64ArrayAttr2')) else
      _ods_ir.AttrBuilder.get('Hbdk_I64ArrayAttr2')(kernel, context=_ods_context))
    if stride is not None: attributes["stride"] = (stride if (
        isinstance(stride, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(stride, context=_ods_context))
    if pad is not None: attributes["pad"] = (pad if (
        isinstance(pad, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(pad, context=_ods_context))
    if dilation is not None: attributes["dilation"] = (dilation if (
        isinstance(dilation, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(dilation, context=_ods_context))
    if padValue is not None: attributes["padValue"] = (padValue if (
        isinstance(padValue, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(padValue, context=_ods_context))
    if relu is not None: attributes["relu"] = (relu if (
        isinstance(relu, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(relu, context=_ods_context))
    if instanceId is not None: attributes["instanceId"] = (instanceId if (
        isinstance(instanceId, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(instanceId, context=_ods_context))
    if processDone is not None: attributes["processDone"] = (processDone if (
        isinstance(processDone, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('ConvProcess')) else
          _ods_ir.AttrBuilder.get('ConvProcess')(processDone, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def weight(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0]

  @builtins.property
  def quantInfo(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range[0]

  @builtins.property
  def sumin(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def lutTable(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 4)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def groupSize(self):
    if "groupSize" not in self.operation.attributes:
      return None
    return self.operation.attributes["groupSize"]

  @groupSize.setter
  def groupSize(self, value):
    if value is not None:
      self.operation.attributes["groupSize"] = value
    elif "groupSize" in self.operation.attributes:
      del self.operation.attributes["groupSize"]

  @groupSize.deleter
  def groupSize(self):
    del self.operation.attributes["groupSize"]

  @builtins.property
  def kernel(self):
    return self.operation.attributes["kernel"]

  @kernel.setter
  def kernel(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["kernel"] = value

  @builtins.property
  def stride(self):
    return self.operation.attributes["stride"]

  @stride.setter
  def stride(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["stride"] = value

  @builtins.property
  def pad(self):
    return self.operation.attributes["pad"]

  @pad.setter
  def pad(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["pad"] = value

  @builtins.property
  def dilation(self):
    return self.operation.attributes["dilation"]

  @dilation.setter
  def dilation(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dilation"] = value

  @builtins.property
  def padValue(self):
    return self.operation.attributes["padValue"]

  @padValue.setter
  def padValue(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["padValue"] = value

  @builtins.property
  def relu(self):
    return self.operation.attributes["relu"]

  @relu.setter
  def relu(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["relu"] = value

  @builtins.property
  def instanceId(self):
    return self.operation.attributes["instanceId"]

  @instanceId.setter
  def instanceId(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["instanceId"] = value

  @builtins.property
  def processDone(self):
    return self.operation.attributes["processDone"]

  @processDone.setter
  def processDone(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["processDone"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

  @builtins.property
  def body(self):
    return self.regions[0]

def conv2d(output, input, weight, quant_info, kernel, *, sumin=None, lut_table=None, group_size=None, stride=None, pad=None, dilation=None, pad_value=None, relu=None, instance_id=None, process_done=None, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(Conv2dOp(output=output, input=input, weight=weight, quantInfo=quant_info, kernel=kernel, sumin=sumin, lutTable=lut_table, groupSize=group_size, stride=stride, pad=pad, dilation=dilation, padValue=pad_value, relu=relu, instanceId=instance_id, processDone=process_done, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class DequantizeOp(_ods_ir.OpView):
  OPERATION_NAME = "b30.dequantize"

  _ODS_REGIONS = (1, True)

  def __init__(self, output, input, bias, scale, mode, *, roundMode=None, perTensorQuant=None, instanceId=None, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(bias))
    operands.append(_get_op_result_or_value(scale))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["mode"] = (mode if (
    isinstance(mode, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('EltwiseModeAttr')) else
      _ods_ir.AttrBuilder.get('EltwiseModeAttr')(mode, context=_ods_context))
    if roundMode is not None: attributes["roundMode"] = (roundMode if (
        isinstance(roundMode, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('RoundModeAttr')) else
          _ods_ir.AttrBuilder.get('RoundModeAttr')(roundMode, context=_ods_context))
    if perTensorQuant is not None: attributes["perTensorQuant"] = (perTensorQuant if (
        isinstance(perTensorQuant, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(perTensorQuant, context=_ods_context))
    if instanceId is not None: attributes["instanceId"] = (instanceId if (
        isinstance(instanceId, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(instanceId, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def bias(self):
    return self.operation.operands[1]

  @builtins.property
  def scale(self):
    return self.operation.operands[2]

  @builtins.property
  def mode(self):
    return self.operation.attributes["mode"]

  @mode.setter
  def mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mode"] = value

  @builtins.property
  def roundMode(self):
    return self.operation.attributes["roundMode"]

  @roundMode.setter
  def roundMode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["roundMode"] = value

  @builtins.property
  def perTensorQuant(self):
    return self.operation.attributes["perTensorQuant"]

  @perTensorQuant.setter
  def perTensorQuant(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["perTensorQuant"] = value

  @builtins.property
  def instanceId(self):
    return self.operation.attributes["instanceId"]

  @instanceId.setter
  def instanceId(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["instanceId"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

  @builtins.property
  def body(self):
    return self.regions[0]

def dequantize(output, input, bias, scale, mode, *, round_mode=None, per_tensor_quant=None, instance_id=None, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(DequantizeOp(output=output, input=input, bias=bias, scale=scale, mode=mode, roundMode=round_mode, perTensorQuant=per_tensor_quant, instanceId=instance_id, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class FilterOp(_ods_ir.OpView):
  OPERATION_NAME = "b30.filter"

  _ODS_REGIONS = (1, True)

  def __init__(self, filterData, data, score, mergeAxisExceptC, threshold, *, partialCount=None, partialData=None, startCoord=None, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(data))
    operands.append(_get_op_result_or_value(score))
    if partialCount is not None: operands.append(_get_op_result_or_value(partialCount))
    if partialData is not None: operands.append(_get_op_result_or_value(partialData))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["mergeAxisExceptC"] = (mergeAxisExceptC if (
    isinstance(mergeAxisExceptC, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(mergeAxisExceptC, context=_ods_context))
    attributes["threshold"] = (threshold if (
    isinstance(threshold, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(threshold, context=_ods_context))
    if startCoord is not None: attributes["startCoord"] = (startCoord if (
        isinstance(startCoord, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(startCoord, context=_ods_context))
    results.append(filterData)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def data(self):
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 2, 2, 0, 0)
    return self.operation.operands[start]

  @builtins.property
  def score(self):
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 2, 2, 1, 0)
    return self.operation.operands[start]

  @builtins.property
  def partialCount(self):
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 2, 2, 2, 0)
    return self.operation.operands[start:start + elements_per_group]

  @builtins.property
  def partialData(self):
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 2, 2, 2, 1)
    return self.operation.operands[start:start + elements_per_group]

  @builtins.property
  def mergeAxisExceptC(self):
    return self.operation.attributes["mergeAxisExceptC"]

  @mergeAxisExceptC.setter
  def mergeAxisExceptC(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mergeAxisExceptC"] = value

  @builtins.property
  def threshold(self):
    return self.operation.attributes["threshold"]

  @threshold.setter
  def threshold(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["threshold"] = value

  @builtins.property
  def startCoord(self):
    return self.operation.attributes["startCoord"]

  @startCoord.setter
  def startCoord(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["startCoord"] = value

  @builtins.property
  def filterData(self):
    return self.operation.results[0]

  @builtins.property
  def body(self):
    return self.regions[0]

def filter(filter_data, data, score, merge_axis_except_c, threshold, *, partial_count=None, partial_data=None, start_coord=None, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(FilterOp(filterData=filter_data, data=data, score=score, mergeAxisExceptC=merge_axis_except_c, threshold=threshold, partialCount=partial_count, partialData=partial_data, startCoord=start_coord, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class Gather2dOp(_ods_ir.OpView):
  OPERATION_NAME = "b30.gather2d"

  _ODS_REGIONS = (1, True)

  def __init__(self, output, input, mv, *, initialOffset=None, expansionMode=None, mvMode=None, mvYX=None, is1D=None, instanceId=None, padValue=None, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(mv))
    _ods_context = _ods_get_default_loc_context(loc)
    if initialOffset is not None: attributes["initialOffset"] = (initialOffset if (
        isinstance(initialOffset, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(initialOffset, context=_ods_context))
    if expansionMode is not None: attributes["expansionMode"] = (expansionMode if (
        isinstance(expansionMode, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('ExpansionModeAttr')) else
          _ods_ir.AttrBuilder.get('ExpansionModeAttr')(expansionMode, context=_ods_context))
    if mvMode is not None: attributes["mvMode"] = (mvMode if (
        isinstance(mvMode, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MotionVectorModeAttr')) else
          _ods_ir.AttrBuilder.get('MotionVectorModeAttr')(mvMode, context=_ods_context))
    if mvYX is not None: attributes["mvYX"] = (mvYX if (
        isinstance(mvYX, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(mvYX, context=_ods_context))
    if is1D is not None: attributes["is1D"] = (is1D if (
        isinstance(is1D, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(is1D, context=_ods_context))
    if instanceId is not None: attributes["instanceId"] = (instanceId if (
        isinstance(instanceId, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(instanceId, context=_ods_context))
    if padValue is not None: attributes["padValue"] = (padValue if (
        isinstance(padValue, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_973')) else
          _ods_ir.AttrBuilder.get('anonymous_973')(padValue, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def mv(self):
    return self.operation.operands[1]

  @builtins.property
  def initialOffset(self):
    return self.operation.attributes["initialOffset"]

  @initialOffset.setter
  def initialOffset(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["initialOffset"] = value

  @builtins.property
  def expansionMode(self):
    return self.operation.attributes["expansionMode"]

  @expansionMode.setter
  def expansionMode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["expansionMode"] = value

  @builtins.property
  def mvMode(self):
    return self.operation.attributes["mvMode"]

  @mvMode.setter
  def mvMode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mvMode"] = value

  @builtins.property
  def mvYX(self):
    return self.operation.attributes["mvYX"]

  @mvYX.setter
  def mvYX(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mvYX"] = value

  @builtins.property
  def is1D(self):
    return self.operation.attributes["is1D"]

  @is1D.setter
  def is1D(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["is1D"] = value

  @builtins.property
  def instanceId(self):
    return self.operation.attributes["instanceId"]

  @instanceId.setter
  def instanceId(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["instanceId"] = value

  @builtins.property
  def padValue(self):
    if "padValue" not in self.operation.attributes:
      return None
    return self.operation.attributes["padValue"]

  @padValue.setter
  def padValue(self, value):
    if value is not None:
      self.operation.attributes["padValue"] = value
    elif "padValue" in self.operation.attributes:
      del self.operation.attributes["padValue"]

  @padValue.deleter
  def padValue(self):
    del self.operation.attributes["padValue"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

  @builtins.property
  def body(self):
    return self.regions[0]

def gather2d(output, input, mv, *, initial_offset=None, expansion_mode=None, mv_mode=None, mv_yx=None, is1_d=None, instance_id=None, pad_value=None, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(Gather2dOp(output=output, input=input, mv=mv, initialOffset=initial_offset, expansionMode=expansion_mode, mvMode=mv_mode, mvYX=mv_yx, is1D=is1_d, instanceId=instance_id, padValue=pad_value, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class GenQuantInfoOp(_ods_ir.OpView):
  OPERATION_NAME = "b30.gen_quant_info"

  _ODS_REGIONS = (0, True)

  def __init__(self, encode, bias, finType, weightType, foutType, *, weight=None, suminType=None, intPP=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(bias))
    if weight is not None: operands.append(_get_op_result_or_value(weight))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["finType"] = (finType if (
    isinstance(finType, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_894')) else
      _ods_ir.AttrBuilder.get('anonymous_894')(finType, context=_ods_context))
    attributes["weightType"] = (weightType if (
    isinstance(weightType, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_894')) else
      _ods_ir.AttrBuilder.get('anonymous_894')(weightType, context=_ods_context))
    attributes["foutType"] = (foutType if (
    isinstance(foutType, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_894')) else
      _ods_ir.AttrBuilder.get('anonymous_894')(foutType, context=_ods_context))
    if suminType is not None: attributes["suminType"] = (suminType if (
        isinstance(suminType, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_894')) else
          _ods_ir.AttrBuilder.get('anonymous_894')(suminType, context=_ods_context))
    if intPP is not None: attributes["intPP"] = (intPP if (
        isinstance(intPP, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(intPP, context=_ods_context))
    results.append(encode)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def bias(self):
    return self.operation.operands[0]

  @builtins.property
  def weight(self):
    return None if len(self.operation.operands) < 2 else self.operation.operands[1]

  @builtins.property
  def finType(self):
    return self.operation.attributes["finType"]

  @finType.setter
  def finType(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["finType"] = value

  @builtins.property
  def weightType(self):
    return self.operation.attributes["weightType"]

  @weightType.setter
  def weightType(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["weightType"] = value

  @builtins.property
  def foutType(self):
    return self.operation.attributes["foutType"]

  @foutType.setter
  def foutType(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["foutType"] = value

  @builtins.property
  def suminType(self):
    if "suminType" not in self.operation.attributes:
      return None
    return self.operation.attributes["suminType"]

  @suminType.setter
  def suminType(self, value):
    if value is not None:
      self.operation.attributes["suminType"] = value
    elif "suminType" in self.operation.attributes:
      del self.operation.attributes["suminType"]

  @suminType.deleter
  def suminType(self):
    del self.operation.attributes["suminType"]

  @builtins.property
  def intPP(self):
    return self.operation.attributes["intPP"]

  @intPP.setter
  def intPP(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["intPP"] = value

  @builtins.property
  def encode(self):
    return self.operation.results[0]

def gen_quant_info(encode, bias, fin_type, weight_type, fout_type, *, weight=None, sumin_type=None, int_pp=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(GenQuantInfoOp(encode=encode, bias=bias, finType=fin_type, weightType=weight_type, foutType=fout_type, weight=weight, suminType=sumin_type, intPP=int_pp, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class LinearOp(_ods_ir.OpView):
  OPERATION_NAME = "b30.linear"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, weight, quantInfo, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(weight))
    operands.append(_get_op_result_or_value(quantInfo))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def weight(self):
    return self.operation.operands[1]

  @builtins.property
  def quantInfo(self):
    return self.operation.operands[2]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def linear(output, input, weight, quant_info, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(LinearOp(output=output, input=input, weight=weight, quantInfo=quant_info, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class LutOp(_ods_ir.OpView):
  OPERATION_NAME = "b30.lut"

  _ODS_REGIONS = (1, True)

  def __init__(self, output, input, config, *, quant_info=None, symmetricMode=None, roundMode=None, saturate=None, mode=None, instanceId=None, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(config))
    if quant_info is not None: operands.append(_get_op_result_or_value(quant_info))
    _ods_context = _ods_get_default_loc_context(loc)
    if symmetricMode is not None: attributes["symmetricMode"] = (symmetricMode if (
        isinstance(symmetricMode, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SymmetricModeAttr')) else
          _ods_ir.AttrBuilder.get('SymmetricModeAttr')(symmetricMode, context=_ods_context))
    if roundMode is not None: attributes["roundMode"] = (roundMode if (
        isinstance(roundMode, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('RoundModeAttr')) else
          _ods_ir.AttrBuilder.get('RoundModeAttr')(roundMode, context=_ods_context))
    if saturate is not None: attributes["saturate"] = (saturate if (
        isinstance(saturate, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(saturate, context=_ods_context))
    if mode is not None: attributes["mode"] = (mode if (
        isinstance(mode, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LutModeAttr')) else
          _ods_ir.AttrBuilder.get('LutModeAttr')(mode, context=_ods_context))
    if instanceId is not None: attributes["instanceId"] = (instanceId if (
        isinstance(instanceId, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(instanceId, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def config(self):
    return self.operation.operands[1]

  @builtins.property
  def quant_info(self):
    return None if len(self.operation.operands) < 3 else self.operation.operands[2]

  @builtins.property
  def symmetricMode(self):
    return self.operation.attributes["symmetricMode"]

  @symmetricMode.setter
  def symmetricMode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["symmetricMode"] = value

  @builtins.property
  def roundMode(self):
    return self.operation.attributes["roundMode"]

  @roundMode.setter
  def roundMode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["roundMode"] = value

  @builtins.property
  def saturate(self):
    return self.operation.attributes["saturate"]

  @saturate.setter
  def saturate(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["saturate"] = value

  @builtins.property
  def mode(self):
    return self.operation.attributes["mode"]

  @mode.setter
  def mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mode"] = value

  @builtins.property
  def instanceId(self):
    return self.operation.attributes["instanceId"]

  @instanceId.setter
  def instanceId(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["instanceId"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

  @builtins.property
  def body(self):
    return self.regions[0]

def lut(output, input, config, *, quant_info=None, symmetric_mode=None, round_mode=None, saturate=None, mode=None, instance_id=None, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(LutOp(output=output, input=input, config=config, quant_info=quant_info, symmetricMode=symmetric_mode, roundMode=round_mode, saturate=saturate, mode=mode, instanceId=instance_id, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class MatMulOp(_ods_ir.OpView):
  OPERATION_NAME = "b30.matmul"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, lhs, rhs, quantInfo, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    operands.append(_get_op_result_or_value(quantInfo))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def quantInfo(self):
    return self.operation.operands[2]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def matmul(output, lhs, rhs, quant_info, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(MatMulOp(output=output, lhs=lhs, rhs=rhs, quantInfo=quant_info, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class OutOfOrderLoadOp(_ods_ir.OpView):
  OPERATION_NAME = "b30.out_of_order_load"

  _ODS_REGIONS = (1, True)

  def __init__(self, output, input, *, offsets=None, sizes=None, strides=None, instanceId=None, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    if offsets is not None: attributes["offsets"] = (offsets if (
        isinstance(offsets, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(offsets, context=_ods_context))
    if sizes is not None: attributes["sizes"] = (sizes if (
        isinstance(sizes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(sizes, context=_ods_context))
    if strides is not None: attributes["strides"] = (strides if (
        isinstance(strides, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(strides, context=_ods_context))
    if instanceId is not None: attributes["instanceId"] = (instanceId if (
        isinstance(instanceId, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(instanceId, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def offsets(self):
    if "offsets" not in self.operation.attributes:
      return None
    return self.operation.attributes["offsets"]

  @offsets.setter
  def offsets(self, value):
    if value is not None:
      self.operation.attributes["offsets"] = value
    elif "offsets" in self.operation.attributes:
      del self.operation.attributes["offsets"]

  @offsets.deleter
  def offsets(self):
    del self.operation.attributes["offsets"]

  @builtins.property
  def sizes(self):
    if "sizes" not in self.operation.attributes:
      return None
    return self.operation.attributes["sizes"]

  @sizes.setter
  def sizes(self, value):
    if value is not None:
      self.operation.attributes["sizes"] = value
    elif "sizes" in self.operation.attributes:
      del self.operation.attributes["sizes"]

  @sizes.deleter
  def sizes(self):
    del self.operation.attributes["sizes"]

  @builtins.property
  def strides(self):
    if "strides" not in self.operation.attributes:
      return None
    return self.operation.attributes["strides"]

  @strides.setter
  def strides(self, value):
    if value is not None:
      self.operation.attributes["strides"] = value
    elif "strides" in self.operation.attributes:
      del self.operation.attributes["strides"]

  @strides.deleter
  def strides(self):
    del self.operation.attributes["strides"]

  @builtins.property
  def instanceId(self):
    return self.operation.attributes["instanceId"]

  @instanceId.setter
  def instanceId(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["instanceId"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

  @builtins.property
  def body(self):
    return self.regions[0]

def out_of_order_load(output, input, *, offsets=None, sizes=None, strides=None, instance_id=None, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(OutOfOrderLoadOp(output=output, input=input, offsets=offsets, sizes=sizes, strides=strides, instanceId=instance_id, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class PacketOp(_ods_ir.OpView):
  OPERATION_NAME = "b30.packet"

  _ODS_REGIONS = (1, True)

  def __init__(self, output, coldOutput, input, mode, *, coldInput=None, maskedValue=None, laneOffset=None, enXor=None, offsets=None, sizes=None, strides=None, instanceId=None, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    if coldInput is not None: operands.append(_get_op_result_or_value(coldInput))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["mode"] = (mode if (
    isinstance(mode, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('PacketModeAttr')) else
      _ods_ir.AttrBuilder.get('PacketModeAttr')(mode, context=_ods_context))
    if maskedValue is not None: attributes["maskedValue"] = (maskedValue if (
        isinstance(maskedValue, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(maskedValue, context=_ods_context))
    if laneOffset is not None: attributes["laneOffset"] = (laneOffset if (
        isinstance(laneOffset, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(laneOffset, context=_ods_context))
    if enXor is not None: attributes["enXor"] = (enXor if (
        isinstance(enXor, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(enXor, context=_ods_context))
    if offsets is not None: attributes["offsets"] = (offsets if (
        isinstance(offsets, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(offsets, context=_ods_context))
    if sizes is not None: attributes["sizes"] = (sizes if (
        isinstance(sizes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(sizes, context=_ods_context))
    if strides is not None: attributes["strides"] = (strides if (
        isinstance(strides, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(strides, context=_ods_context))
    if instanceId is not None: attributes["instanceId"] = (instanceId if (
        isinstance(instanceId, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(instanceId, context=_ods_context))
    results.append(output)
    if coldOutput is not None: results.append(coldOutput)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def coldInput(self):
    return None if len(self.operation.operands) < 2 else self.operation.operands[1]

  @builtins.property
  def mode(self):
    return self.operation.attributes["mode"]

  @mode.setter
  def mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mode"] = value

  @builtins.property
  def maskedValue(self):
    return self.operation.attributes["maskedValue"]

  @maskedValue.setter
  def maskedValue(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["maskedValue"] = value

  @builtins.property
  def laneOffset(self):
    return self.operation.attributes["laneOffset"]

  @laneOffset.setter
  def laneOffset(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["laneOffset"] = value

  @builtins.property
  def enXor(self):
    return self.operation.attributes["enXor"]

  @enXor.setter
  def enXor(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["enXor"] = value

  @builtins.property
  def offsets(self):
    if "offsets" not in self.operation.attributes:
      return None
    return self.operation.attributes["offsets"]

  @offsets.setter
  def offsets(self, value):
    if value is not None:
      self.operation.attributes["offsets"] = value
    elif "offsets" in self.operation.attributes:
      del self.operation.attributes["offsets"]

  @offsets.deleter
  def offsets(self):
    del self.operation.attributes["offsets"]

  @builtins.property
  def sizes(self):
    if "sizes" not in self.operation.attributes:
      return None
    return self.operation.attributes["sizes"]

  @sizes.setter
  def sizes(self, value):
    if value is not None:
      self.operation.attributes["sizes"] = value
    elif "sizes" in self.operation.attributes:
      del self.operation.attributes["sizes"]

  @sizes.deleter
  def sizes(self):
    del self.operation.attributes["sizes"]

  @builtins.property
  def strides(self):
    if "strides" not in self.operation.attributes:
      return None
    return self.operation.attributes["strides"]

  @strides.setter
  def strides(self, value):
    if value is not None:
      self.operation.attributes["strides"] = value
    elif "strides" in self.operation.attributes:
      del self.operation.attributes["strides"]

  @strides.deleter
  def strides(self):
    del self.operation.attributes["strides"]

  @builtins.property
  def instanceId(self):
    return self.operation.attributes["instanceId"]

  @instanceId.setter
  def instanceId(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["instanceId"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

  @builtins.property
  def coldOutput(self):
    return None if len(self.operation.results) < 2 else self.operation.results[1]

  @builtins.property
  def body(self):
    return self.regions[0]

def packet(output, cold_output, input, mode, *, cold_input=None, masked_value=None, lane_offset=None, en_xor=None, offsets=None, sizes=None, strides=None, instance_id=None, extra=None, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return _get_op_result_or_op_results(PacketOp(output=output, coldOutput=cold_output, input=input, mode=mode, coldInput=cold_input, maskedValue=masked_value, laneOffset=lane_offset, enXor=en_xor, offsets=offsets, sizes=sizes, strides=strides, instanceId=instance_id, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class Pool2dOp(_ods_ir.OpView):
  OPERATION_NAME = "b30.pool2d"

  _ODS_REGIONS = (1, True)

  def __init__(self, output, input, kernel, mode, *, stride=None, pad=None, qppActionTypes=None, qppActionParams=None, instanceId=None, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["kernel"] = (kernel if (
    isinstance(kernel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Hbdk_I64ArrayAttr2')) else
      _ods_ir.AttrBuilder.get('Hbdk_I64ArrayAttr2')(kernel, context=_ods_context))
    attributes["mode"] = (mode if (
    isinstance(mode, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('PoolModeAttr')) else
      _ods_ir.AttrBuilder.get('PoolModeAttr')(mode, context=_ods_context))
    if stride is not None: attributes["stride"] = (stride if (
        isinstance(stride, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(stride, context=_ods_context))
    if pad is not None: attributes["pad"] = (pad if (
        isinstance(pad, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(pad, context=_ods_context))
    if qppActionTypes is not None: attributes["qppActionTypes"] = (qppActionTypes if (
        isinstance(qppActionTypes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Hbdk_QppActionAttr')) else
          _ods_ir.AttrBuilder.get('Hbdk_QppActionAttr')(qppActionTypes, context=_ods_context))
    if qppActionParams is not None: attributes["qppActionParams"] = (qppActionParams if (
        isinstance(qppActionParams, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(qppActionParams, context=_ods_context))
    if instanceId is not None: attributes["instanceId"] = (instanceId if (
        isinstance(instanceId, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(instanceId, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def kernel(self):
    return self.operation.attributes["kernel"]

  @kernel.setter
  def kernel(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["kernel"] = value

  @builtins.property
  def mode(self):
    return self.operation.attributes["mode"]

  @mode.setter
  def mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mode"] = value

  @builtins.property
  def stride(self):
    return self.operation.attributes["stride"]

  @stride.setter
  def stride(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["stride"] = value

  @builtins.property
  def pad(self):
    return self.operation.attributes["pad"]

  @pad.setter
  def pad(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["pad"] = value

  @builtins.property
  def qppActionTypes(self):
    return self.operation.attributes["qppActionTypes"]

  @qppActionTypes.setter
  def qppActionTypes(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["qppActionTypes"] = value

  @builtins.property
  def qppActionParams(self):
    return self.operation.attributes["qppActionParams"]

  @qppActionParams.setter
  def qppActionParams(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["qppActionParams"] = value

  @builtins.property
  def instanceId(self):
    return self.operation.attributes["instanceId"]

  @instanceId.setter
  def instanceId(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["instanceId"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

  @builtins.property
  def body(self):
    return self.regions[0]

def pool2d(output, input, kernel, mode, *, stride=None, pad=None, qpp_action_types=None, qpp_action_params=None, instance_id=None, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(Pool2dOp(output=output, input=input, kernel=kernel, mode=mode, stride=stride, pad=pad, qppActionTypes=qpp_action_types, qppActionParams=qpp_action_params, instanceId=instance_id, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class QuantizeOp(_ods_ir.OpView):
  OPERATION_NAME = "b30.quantize"

  _ODS_REGIONS = (1, True)

  def __init__(self, output, input, bias, scale, mode, *, roundMode=None, saturate=None, perTensorQuant=None, instanceId=None, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(bias))
    operands.append(_get_op_result_or_value(scale))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["mode"] = (mode if (
    isinstance(mode, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('EltwiseModeAttr')) else
      _ods_ir.AttrBuilder.get('EltwiseModeAttr')(mode, context=_ods_context))
    if roundMode is not None: attributes["roundMode"] = (roundMode if (
        isinstance(roundMode, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('RoundModeAttr')) else
          _ods_ir.AttrBuilder.get('RoundModeAttr')(roundMode, context=_ods_context))
    if saturate is not None: attributes["saturate"] = (saturate if (
        isinstance(saturate, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(saturate, context=_ods_context))
    if perTensorQuant is not None: attributes["perTensorQuant"] = (perTensorQuant if (
        isinstance(perTensorQuant, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(perTensorQuant, context=_ods_context))
    if instanceId is not None: attributes["instanceId"] = (instanceId if (
        isinstance(instanceId, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(instanceId, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def bias(self):
    return self.operation.operands[1]

  @builtins.property
  def scale(self):
    return self.operation.operands[2]

  @builtins.property
  def mode(self):
    return self.operation.attributes["mode"]

  @mode.setter
  def mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mode"] = value

  @builtins.property
  def roundMode(self):
    return self.operation.attributes["roundMode"]

  @roundMode.setter
  def roundMode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["roundMode"] = value

  @builtins.property
  def saturate(self):
    return self.operation.attributes["saturate"]

  @saturate.setter
  def saturate(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["saturate"] = value

  @builtins.property
  def perTensorQuant(self):
    return self.operation.attributes["perTensorQuant"]

  @perTensorQuant.setter
  def perTensorQuant(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["perTensorQuant"] = value

  @builtins.property
  def instanceId(self):
    return self.operation.attributes["instanceId"]

  @instanceId.setter
  def instanceId(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["instanceId"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

  @builtins.property
  def body(self):
    return self.regions[0]

def quantize(output, input, bias, scale, mode, *, round_mode=None, saturate=None, per_tensor_quant=None, instance_id=None, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(QuantizeOp(output=output, input=input, bias=bias, scale=scale, mode=mode, roundMode=round_mode, saturate=saturate, perTensorQuant=per_tensor_quant, instanceId=instance_id, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class ReduceOp(_ods_ir.OpView):
  OPERATION_NAME = "b30.reduce"

  _ODS_REGIONS = (1, True)

  def __init__(self, output, input, mode, dims, keepDim, *, partialSum=None, qppActionTypes=None, qppActionParams=None, offsetOnReducedAxis=None, instanceId=None, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    if partialSum is not None: operands.append(_get_op_result_or_value(partialSum))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["mode"] = (mode if (
    isinstance(mode, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ReduceModeAttr')) else
      _ods_ir.AttrBuilder.get('ReduceModeAttr')(mode, context=_ods_context))
    attributes["dims"] = (dims if (
    isinstance(dims, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(dims, context=_ods_context))
    attributes["keepDim"] = (keepDim if (
    isinstance(keepDim, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(keepDim, context=_ods_context))
    if qppActionTypes is not None: attributes["qppActionTypes"] = (qppActionTypes if (
        isinstance(qppActionTypes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Hbdk_QppActionAttr')) else
          _ods_ir.AttrBuilder.get('Hbdk_QppActionAttr')(qppActionTypes, context=_ods_context))
    if qppActionParams is not None: attributes["qppActionParams"] = (qppActionParams if (
        isinstance(qppActionParams, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(qppActionParams, context=_ods_context))
    if offsetOnReducedAxis is not None: attributes["offsetOnReducedAxis"] = (offsetOnReducedAxis if (
        isinstance(offsetOnReducedAxis, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(offsetOnReducedAxis, context=_ods_context))
    if instanceId is not None: attributes["instanceId"] = (instanceId if (
        isinstance(instanceId, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(instanceId, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def partialSum(self):
    return None if len(self.operation.operands) < 2 else self.operation.operands[1]

  @builtins.property
  def mode(self):
    return self.operation.attributes["mode"]

  @mode.setter
  def mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mode"] = value

  @builtins.property
  def dims(self):
    return self.operation.attributes["dims"]

  @dims.setter
  def dims(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dims"] = value

  @builtins.property
  def keepDim(self):
    return self.operation.attributes["keepDim"]

  @keepDim.setter
  def keepDim(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["keepDim"] = value

  @builtins.property
  def qppActionTypes(self):
    return self.operation.attributes["qppActionTypes"]

  @qppActionTypes.setter
  def qppActionTypes(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["qppActionTypes"] = value

  @builtins.property
  def qppActionParams(self):
    return self.operation.attributes["qppActionParams"]

  @qppActionParams.setter
  def qppActionParams(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["qppActionParams"] = value

  @builtins.property
  def offsetOnReducedAxis(self):
    return self.operation.attributes["offsetOnReducedAxis"]

  @offsetOnReducedAxis.setter
  def offsetOnReducedAxis(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["offsetOnReducedAxis"] = value

  @builtins.property
  def instanceId(self):
    return self.operation.attributes["instanceId"]

  @instanceId.setter
  def instanceId(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["instanceId"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

  @builtins.property
  def body(self):
    return self.regions[0]

def reduce(output, input, mode, dims, keep_dim, *, partial_sum=None, qpp_action_types=None, qpp_action_params=None, offset_on_reduced_axis=None, instance_id=None, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(ReduceOp(output=output, input=input, mode=mode, dims=dims, keepDim=keep_dim, partialSum=partial_sum, qppActionTypes=qpp_action_types, qppActionParams=qpp_action_params, offsetOnReducedAxis=offset_on_reduced_axis, instanceId=instance_id, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class RescaleOp(_ods_ir.OpView):
  OPERATION_NAME = "b30.rescale"

  _ODS_REGIONS = (1, True)

  def __init__(self, output, input, quant_info, *, mode=None, roundMode=None, saturate=None, perTensorQuant=None, instanceId=None, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(quant_info))
    _ods_context = _ods_get_default_loc_context(loc)
    if mode is not None: attributes["mode"] = (mode if (
        isinstance(mode, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('EltwiseModeAttr')) else
          _ods_ir.AttrBuilder.get('EltwiseModeAttr')(mode, context=_ods_context))
    if roundMode is not None: attributes["roundMode"] = (roundMode if (
        isinstance(roundMode, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('RoundModeAttr')) else
          _ods_ir.AttrBuilder.get('RoundModeAttr')(roundMode, context=_ods_context))
    if saturate is not None: attributes["saturate"] = (saturate if (
        isinstance(saturate, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(saturate, context=_ods_context))
    if perTensorQuant is not None: attributes["perTensorQuant"] = (perTensorQuant if (
        isinstance(perTensorQuant, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(perTensorQuant, context=_ods_context))
    if instanceId is not None: attributes["instanceId"] = (instanceId if (
        isinstance(instanceId, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(instanceId, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def quant_info(self):
    return self.operation.operands[1]

  @builtins.property
  def mode(self):
    return self.operation.attributes["mode"]

  @mode.setter
  def mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mode"] = value

  @builtins.property
  def roundMode(self):
    return self.operation.attributes["roundMode"]

  @roundMode.setter
  def roundMode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["roundMode"] = value

  @builtins.property
  def saturate(self):
    return self.operation.attributes["saturate"]

  @saturate.setter
  def saturate(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["saturate"] = value

  @builtins.property
  def perTensorQuant(self):
    return self.operation.attributes["perTensorQuant"]

  @perTensorQuant.setter
  def perTensorQuant(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["perTensorQuant"] = value

  @builtins.property
  def instanceId(self):
    return self.operation.attributes["instanceId"]

  @instanceId.setter
  def instanceId(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["instanceId"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

  @builtins.property
  def body(self):
    return self.regions[0]

def rescale(output, input, quant_info, *, mode=None, round_mode=None, saturate=None, per_tensor_quant=None, instance_id=None, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(RescaleOp(output=output, input=input, quant_info=quant_info, mode=mode, roundMode=round_mode, saturate=saturate, perTensorQuant=per_tensor_quant, instanceId=instance_id, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class ReshapeOp(_ods_ir.OpView):
  OPERATION_NAME = "b30.reshape"

  _ODS_REGIONS = (1, True)

  def __init__(self, output, input, shape, *, foldable=None, instanceId=None, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["shape"] = (shape if (
    isinstance(shape, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(shape, context=_ods_context))
    if foldable is not None: attributes["foldable"] = (foldable if (
        isinstance(foldable, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(foldable, context=_ods_context))
    if instanceId is not None: attributes["instanceId"] = (instanceId if (
        isinstance(instanceId, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(instanceId, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def shape(self):
    return self.operation.attributes["shape"]

  @shape.setter
  def shape(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["shape"] = value

  @builtins.property
  def foldable(self):
    return self.operation.attributes["foldable"]

  @foldable.setter
  def foldable(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["foldable"] = value

  @builtins.property
  def instanceId(self):
    return self.operation.attributes["instanceId"]

  @instanceId.setter
  def instanceId(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["instanceId"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

  @builtins.property
  def body(self):
    return self.regions[0]

def reshape(output, input, shape, *, foldable=None, instance_id=None, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(ReshapeOp(output=output, input=input, shape=shape, foldable=foldable, instanceId=instance_id, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class Resize2dOp(_ods_ir.OpView):
  OPERATION_NAME = "b30.resize2d"

  _ODS_REGIONS = (1, True)

  def __init__(self, output, input, step, *, initialOffset=None, mode=None, expansionMode=None, roundMode=None, padValue=None, instanceId=None, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["step"] = (step if (
    isinstance(step, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Hbdk_I64ArrayAttr2')) else
      _ods_ir.AttrBuilder.get('Hbdk_I64ArrayAttr2')(step, context=_ods_context))
    if initialOffset is not None: attributes["initialOffset"] = (initialOffset if (
        isinstance(initialOffset, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(initialOffset, context=_ods_context))
    if mode is not None: attributes["mode"] = (mode if (
        isinstance(mode, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('InterpolationModeAttr')) else
          _ods_ir.AttrBuilder.get('InterpolationModeAttr')(mode, context=_ods_context))
    if expansionMode is not None: attributes["expansionMode"] = (expansionMode if (
        isinstance(expansionMode, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('ExpansionModeAttr')) else
          _ods_ir.AttrBuilder.get('ExpansionModeAttr')(expansionMode, context=_ods_context))
    if roundMode is not None: attributes["roundMode"] = (roundMode if (
        isinstance(roundMode, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('RoundModeAttr')) else
          _ods_ir.AttrBuilder.get('RoundModeAttr')(roundMode, context=_ods_context))
    if padValue is not None: attributes["padValue"] = (padValue if (
        isinstance(padValue, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(padValue, context=_ods_context))
    if instanceId is not None: attributes["instanceId"] = (instanceId if (
        isinstance(instanceId, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(instanceId, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def step(self):
    return self.operation.attributes["step"]

  @step.setter
  def step(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["step"] = value

  @builtins.property
  def initialOffset(self):
    return self.operation.attributes["initialOffset"]

  @initialOffset.setter
  def initialOffset(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["initialOffset"] = value

  @builtins.property
  def mode(self):
    return self.operation.attributes["mode"]

  @mode.setter
  def mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mode"] = value

  @builtins.property
  def expansionMode(self):
    return self.operation.attributes["expansionMode"]

  @expansionMode.setter
  def expansionMode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["expansionMode"] = value

  @builtins.property
  def roundMode(self):
    return self.operation.attributes["roundMode"]

  @roundMode.setter
  def roundMode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["roundMode"] = value

  @builtins.property
  def padValue(self):
    if "padValue" not in self.operation.attributes:
      return None
    return self.operation.attributes["padValue"]

  @padValue.setter
  def padValue(self, value):
    if value is not None:
      self.operation.attributes["padValue"] = value
    elif "padValue" in self.operation.attributes:
      del self.operation.attributes["padValue"]

  @padValue.deleter
  def padValue(self):
    del self.operation.attributes["padValue"]

  @builtins.property
  def instanceId(self):
    return self.operation.attributes["instanceId"]

  @instanceId.setter
  def instanceId(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["instanceId"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

  @builtins.property
  def body(self):
    return self.regions[0]

def resize2d(output, input, step, *, initial_offset=None, mode=None, expansion_mode=None, round_mode=None, pad_value=None, instance_id=None, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(Resize2dOp(output=output, input=input, step=step, initialOffset=initial_offset, mode=mode, expansionMode=expansion_mode, roundMode=round_mode, padValue=pad_value, instanceId=instance_id, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class RleOp(_ods_ir.OpView):
  OPERATION_NAME = "b30.rle"

  _ODS_REGIONS = (1, True)

  def __init__(self, output, input, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

  @builtins.property
  def body(self):
    return self.regions[0]

def rle(output, input, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(RleOp(output=output, input=input, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class Scatter2dOp(_ods_ir.OpView):
  OPERATION_NAME = "b30.scatter2d"

  _ODS_REGIONS = (1, True)

  def __init__(self, output, input, indices, updates, mode, *, initialOffset=None, roundMode=None, mvYX=None, instanceId=None, splitNum=None, initOut=None, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(indices))
    operands.append(_get_op_result_or_value(updates))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["mode"] = (mode if (
    isinstance(mode, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ScatterReduceModeAttr')) else
      _ods_ir.AttrBuilder.get('ScatterReduceModeAttr')(mode, context=_ods_context))
    if initialOffset is not None: attributes["initialOffset"] = (initialOffset if (
        isinstance(initialOffset, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(initialOffset, context=_ods_context))
    if roundMode is not None: attributes["roundMode"] = (roundMode if (
        isinstance(roundMode, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('RoundModeAttr')) else
          _ods_ir.AttrBuilder.get('RoundModeAttr')(roundMode, context=_ods_context))
    if mvYX is not None: attributes["mvYX"] = (mvYX if (
        isinstance(mvYX, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(mvYX, context=_ods_context))
    if instanceId is not None: attributes["instanceId"] = (instanceId if (
        isinstance(instanceId, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(instanceId, context=_ods_context))
    if splitNum is not None: attributes["splitNum"] = (splitNum if (
        isinstance(splitNum, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(splitNum, context=_ods_context))
    if initOut is not None: attributes["initOut"] = (initOut if (
        isinstance(initOut, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(initOut, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def indices(self):
    return self.operation.operands[1]

  @builtins.property
  def updates(self):
    return self.operation.operands[2]

  @builtins.property
  def mode(self):
    return self.operation.attributes["mode"]

  @mode.setter
  def mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mode"] = value

  @builtins.property
  def initialOffset(self):
    return self.operation.attributes["initialOffset"]

  @initialOffset.setter
  def initialOffset(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["initialOffset"] = value

  @builtins.property
  def roundMode(self):
    return self.operation.attributes["roundMode"]

  @roundMode.setter
  def roundMode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["roundMode"] = value

  @builtins.property
  def mvYX(self):
    return self.operation.attributes["mvYX"]

  @mvYX.setter
  def mvYX(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mvYX"] = value

  @builtins.property
  def instanceId(self):
    return self.operation.attributes["instanceId"]

  @instanceId.setter
  def instanceId(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["instanceId"] = value

  @builtins.property
  def splitNum(self):
    return self.operation.attributes["splitNum"]

  @splitNum.setter
  def splitNum(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["splitNum"] = value

  @builtins.property
  def initOut(self):
    return self.operation.attributes["initOut"]

  @initOut.setter
  def initOut(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["initOut"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

  @builtins.property
  def body(self):
    return self.regions[0]

def scatter2d(output, input, indices, updates, mode, *, initial_offset=None, round_mode=None, mv_yx=None, instance_id=None, split_num=None, init_out=None, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(Scatter2dOp(output=output, input=input, indices=indices, updates=updates, mode=mode, initialOffset=initial_offset, roundMode=round_mode, mvYX=mv_yx, instanceId=instance_id, splitNum=split_num, initOut=init_out, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class TernaryEltwiseOp(_ods_ir.OpView):
  OPERATION_NAME = "b30.ternary_eltwise"

  _ODS_REGIONS = (1, True)

  def __init__(self, output, lhs, rhs, condition, mode, *, instanceId=None, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    operands.append(_get_op_result_or_value(condition))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["mode"] = (mode if (
    isinstance(mode, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('EltwiseModeAttr')) else
      _ods_ir.AttrBuilder.get('EltwiseModeAttr')(mode, context=_ods_context))
    if instanceId is not None: attributes["instanceId"] = (instanceId if (
        isinstance(instanceId, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(instanceId, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def condition(self):
    return self.operation.operands[2]

  @builtins.property
  def mode(self):
    return self.operation.attributes["mode"]

  @mode.setter
  def mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mode"] = value

  @builtins.property
  def instanceId(self):
    return self.operation.attributes["instanceId"]

  @instanceId.setter
  def instanceId(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["instanceId"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

  @builtins.property
  def body(self):
    return self.regions[0]

def ternary_eltwise(output, lhs, rhs, condition, mode, *, instance_id=None, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(TernaryEltwiseOp(output=output, lhs=lhs, rhs=rhs, condition=condition, mode=mode, instanceId=instance_id, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class TransLayoutOp(_ods_ir.OpView):
  OPERATION_NAME = "b30.trans_layout"

  _ODS_REGIONS = (1, True)

  def __init__(self, output, input, *, modes=None, funcs=None, instanceId=None, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    if modes is not None: attributes["modes"] = (modes if (
        isinstance(modes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('B30_TransLayoutModesAttr')) else
          _ods_ir.AttrBuilder.get('B30_TransLayoutModesAttr')(modes, context=_ods_context))
    if funcs is not None: attributes["funcs"] = (funcs if (
        isinstance(funcs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(funcs, context=_ods_context))
    if instanceId is not None: attributes["instanceId"] = (instanceId if (
        isinstance(instanceId, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(instanceId, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def modes(self):
    return self.operation.attributes["modes"]

  @modes.setter
  def modes(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["modes"] = value

  @builtins.property
  def funcs(self):
    return self.operation.attributes["funcs"]

  @funcs.setter
  def funcs(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["funcs"] = value

  @builtins.property
  def instanceId(self):
    return self.operation.attributes["instanceId"]

  @instanceId.setter
  def instanceId(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["instanceId"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

  @builtins.property
  def body(self):
    return self.regions[0]

def trans_layout(output, input, *, modes=None, funcs=None, instance_id=None, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(TransLayoutOp(output=output, input=input, modes=modes, funcs=funcs, instanceId=instance_id, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class UnaryEltwiseOp(_ods_ir.OpView):
  OPERATION_NAME = "b30.unary_eltwise"

  _ODS_REGIONS = (1, True)

  def __init__(self, output, input, mode, *, quant_info=None, roundMode=None, saturate=None, perTensorQuant=None, instanceId=None, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    if quant_info is not None: operands.append(_get_op_result_or_value(quant_info))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["mode"] = (mode if (
    isinstance(mode, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('EltwiseModeAttr')) else
      _ods_ir.AttrBuilder.get('EltwiseModeAttr')(mode, context=_ods_context))
    if roundMode is not None: attributes["roundMode"] = (roundMode if (
        isinstance(roundMode, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('RoundModeAttr')) else
          _ods_ir.AttrBuilder.get('RoundModeAttr')(roundMode, context=_ods_context))
    if saturate is not None: attributes["saturate"] = (saturate if (
        isinstance(saturate, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(saturate, context=_ods_context))
    if perTensorQuant is not None: attributes["perTensorQuant"] = (perTensorQuant if (
        isinstance(perTensorQuant, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(perTensorQuant, context=_ods_context))
    if instanceId is not None: attributes["instanceId"] = (instanceId if (
        isinstance(instanceId, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(instanceId, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def quant_info(self):
    return None if len(self.operation.operands) < 2 else self.operation.operands[1]

  @builtins.property
  def mode(self):
    return self.operation.attributes["mode"]

  @mode.setter
  def mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mode"] = value

  @builtins.property
  def roundMode(self):
    return self.operation.attributes["roundMode"]

  @roundMode.setter
  def roundMode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["roundMode"] = value

  @builtins.property
  def saturate(self):
    return self.operation.attributes["saturate"]

  @saturate.setter
  def saturate(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["saturate"] = value

  @builtins.property
  def perTensorQuant(self):
    return self.operation.attributes["perTensorQuant"]

  @perTensorQuant.setter
  def perTensorQuant(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["perTensorQuant"] = value

  @builtins.property
  def instanceId(self):
    return self.operation.attributes["instanceId"]

  @instanceId.setter
  def instanceId(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["instanceId"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

  @builtins.property
  def body(self):
    return self.regions[0]

def unary_eltwise(output, input, mode, *, quant_info=None, round_mode=None, saturate=None, per_tensor_quant=None, instance_id=None, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(UnaryEltwiseOp(output=output, input=input, mode=mode, quant_info=quant_info, roundMode=round_mode, saturate=saturate, perTensorQuant=per_tensor_quant, instanceId=instance_id, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class WarpOp(_ods_ir.OpView):
  OPERATION_NAME = "b30.warp"

  _ODS_REGIONS = (1, True)

  def __init__(self, output, input, mv, *, initialOffset=None, mode=None, expansionMode=None, roundMode=None, mvYX=None, bottomPadInvalid=None, topPadInvalid=None, mvMode=None, shiftBits=None, a=None, b=None, s=None, padValue=None, instanceId=None, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(mv))
    _ods_context = _ods_get_default_loc_context(loc)
    if initialOffset is not None: attributes["initialOffset"] = (initialOffset if (
        isinstance(initialOffset, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(initialOffset, context=_ods_context))
    if mode is not None: attributes["mode"] = (mode if (
        isinstance(mode, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('InterpolationModeAttr')) else
          _ods_ir.AttrBuilder.get('InterpolationModeAttr')(mode, context=_ods_context))
    if expansionMode is not None: attributes["expansionMode"] = (expansionMode if (
        isinstance(expansionMode, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('ExpansionModeAttr')) else
          _ods_ir.AttrBuilder.get('ExpansionModeAttr')(expansionMode, context=_ods_context))
    if roundMode is not None: attributes["roundMode"] = (roundMode if (
        isinstance(roundMode, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('RoundModeAttr')) else
          _ods_ir.AttrBuilder.get('RoundModeAttr')(roundMode, context=_ods_context))
    if mvYX is not None: attributes["mvYX"] = (mvYX if (
        isinstance(mvYX, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(mvYX, context=_ods_context))
    if bottomPadInvalid is not None: attributes["bottomPadInvalid"] = (bottomPadInvalid if (
        isinstance(bottomPadInvalid, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(bottomPadInvalid, context=_ods_context))
    if topPadInvalid is not None: attributes["topPadInvalid"] = (topPadInvalid if (
        isinstance(topPadInvalid, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(topPadInvalid, context=_ods_context))
    if mvMode is not None: attributes["mvMode"] = (mvMode if (
        isinstance(mvMode, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MotionVectorModeAttr')) else
          _ods_ir.AttrBuilder.get('MotionVectorModeAttr')(mvMode, context=_ods_context))
    if shiftBits is not None: attributes["shiftBits"] = (shiftBits if (
        isinstance(shiftBits, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(shiftBits, context=_ods_context))
    if a is not None: attributes["a"] = (a if (
        isinstance(a, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(a, context=_ods_context))
    if b is not None: attributes["b"] = (b if (
        isinstance(b, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(b, context=_ods_context))
    if s is not None: attributes["s"] = (s if (
        isinstance(s, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(s, context=_ods_context))
    if padValue is not None: attributes["padValue"] = (padValue if (
        isinstance(padValue, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_973')) else
          _ods_ir.AttrBuilder.get('anonymous_973')(padValue, context=_ods_context))
    if instanceId is not None: attributes["instanceId"] = (instanceId if (
        isinstance(instanceId, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(instanceId, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def mv(self):
    return self.operation.operands[1]

  @builtins.property
  def initialOffset(self):
    return self.operation.attributes["initialOffset"]

  @initialOffset.setter
  def initialOffset(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["initialOffset"] = value

  @builtins.property
  def mode(self):
    return self.operation.attributes["mode"]

  @mode.setter
  def mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mode"] = value

  @builtins.property
  def expansionMode(self):
    return self.operation.attributes["expansionMode"]

  @expansionMode.setter
  def expansionMode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["expansionMode"] = value

  @builtins.property
  def roundMode(self):
    return self.operation.attributes["roundMode"]

  @roundMode.setter
  def roundMode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["roundMode"] = value

  @builtins.property
  def mvYX(self):
    return self.operation.attributes["mvYX"]

  @mvYX.setter
  def mvYX(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mvYX"] = value

  @builtins.property
  def bottomPadInvalid(self):
    return self.operation.attributes["bottomPadInvalid"]

  @bottomPadInvalid.setter
  def bottomPadInvalid(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["bottomPadInvalid"] = value

  @builtins.property
  def topPadInvalid(self):
    return self.operation.attributes["topPadInvalid"]

  @topPadInvalid.setter
  def topPadInvalid(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["topPadInvalid"] = value

  @builtins.property
  def mvMode(self):
    return self.operation.attributes["mvMode"]

  @mvMode.setter
  def mvMode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mvMode"] = value

  @builtins.property
  def shiftBits(self):
    return self.operation.attributes["shiftBits"]

  @shiftBits.setter
  def shiftBits(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["shiftBits"] = value

  @builtins.property
  def a(self):
    return self.operation.attributes["a"]

  @a.setter
  def a(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["a"] = value

  @builtins.property
  def b(self):
    return self.operation.attributes["b"]

  @b.setter
  def b(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["b"] = value

  @builtins.property
  def s(self):
    return self.operation.attributes["s"]

  @s.setter
  def s(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["s"] = value

  @builtins.property
  def padValue(self):
    if "padValue" not in self.operation.attributes:
      return None
    return self.operation.attributes["padValue"]

  @padValue.setter
  def padValue(self, value):
    if value is not None:
      self.operation.attributes["padValue"] = value
    elif "padValue" in self.operation.attributes:
      del self.operation.attributes["padValue"]

  @padValue.deleter
  def padValue(self):
    del self.operation.attributes["padValue"]

  @builtins.property
  def instanceId(self):
    return self.operation.attributes["instanceId"]

  @instanceId.setter
  def instanceId(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["instanceId"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

  @builtins.property
  def body(self):
    return self.regions[0]

def warp(output, input, mv, *, initial_offset=None, mode=None, expansion_mode=None, round_mode=None, mv_yx=None, bottom_pad_invalid=None, top_pad_invalid=None, mv_mode=None, shift_bits=None, a=None, b=None, s=None, pad_value=None, instance_id=None, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(WarpOp(output=output, input=input, mv=mv, initialOffset=initial_offset, mode=mode, expansionMode=expansion_mode, roundMode=round_mode, mvYX=mv_yx, bottomPadInvalid=bottom_pad_invalid, topPadInvalid=top_pad_invalid, mvMode=mv_mode, shiftBits=shift_bits, a=a, b=b, s=s, padValue=pad_value, instanceId=instance_id, extra=extra, loc=loc, ip=ip))
