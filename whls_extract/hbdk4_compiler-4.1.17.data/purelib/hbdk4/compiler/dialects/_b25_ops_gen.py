
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import (
    equally_sized_accessor as _ods_equally_sized_accessor,
    get_default_loc_context as _ods_get_default_loc_context,
    get_op_result_or_op_results as _get_op_result_or_op_results,
    get_op_result_or_value as _get_op_result_or_value,
    get_op_results_or_values as _get_op_results_or_values,
    segmented_accessor as _ods_segmented_accessor,
)
_ods_ir = _ods_cext.ir

import builtins
from typing import Sequence as _Sequence, Union as _Union


@_ods_cext.register_dialect
class _Dialect(_ods_ir.Dialect):
  DIALECT_NAMESPACE = "b25"

@_ods_cext.register_operation(_Dialect)
class BinaryEltwiseOp(_ods_ir.OpView):
  OPERATION_NAME = "b25.binary_eltwise"

  _ODS_REGIONS = (1, True)

  def __init__(self, output, lhs, rhs, mode, *, quant_info=None, roundMode=None, saturate=None, perTensorQuant=None, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    if quant_info is not None: operands.append(_get_op_result_or_value(quant_info))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["mode"] = (mode if (
    isinstance(mode, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('EltwiseModeAttr')) else
      _ods_ir.AttrBuilder.get('EltwiseModeAttr')(mode, context=_ods_context))
    if roundMode is not None: attributes["roundMode"] = (roundMode if (
        isinstance(roundMode, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('RoundModeAttr')) else
          _ods_ir.AttrBuilder.get('RoundModeAttr')(roundMode, context=_ods_context))
    if saturate is not None: attributes["saturate"] = (saturate if (
        isinstance(saturate, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(saturate, context=_ods_context))
    if perTensorQuant is not None: attributes["perTensorQuant"] = (perTensorQuant if (
        isinstance(perTensorQuant, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(perTensorQuant, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def quant_info(self):
    return None if len(self.operation.operands) < 3 else self.operation.operands[2]

  @builtins.property
  def mode(self):
    return self.operation.attributes["mode"]

  @mode.setter
  def mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mode"] = value

  @builtins.property
  def roundMode(self):
    return self.operation.attributes["roundMode"]

  @roundMode.setter
  def roundMode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["roundMode"] = value

  @builtins.property
  def saturate(self):
    return self.operation.attributes["saturate"]

  @saturate.setter
  def saturate(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["saturate"] = value

  @builtins.property
  def perTensorQuant(self):
    return self.operation.attributes["perTensorQuant"]

  @perTensorQuant.setter
  def perTensorQuant(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["perTensorQuant"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

  @builtins.property
  def body(self):
    return self.regions[0]

def binary_eltwise(output, lhs, rhs, mode, *, quant_info=None, round_mode=None, saturate=None, per_tensor_quant=None, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(BinaryEltwiseOp(output=output, lhs=lhs, rhs=rhs, mode=mode, quant_info=quant_info, roundMode=round_mode, saturate=saturate, perTensorQuant=per_tensor_quant, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class Conv2dOp(_ods_ir.OpView):
  OPERATION_NAME = "b25.conv2d"

  _ODS_OPERAND_SEGMENTS = [1,1,1,0,0,]

  _ODS_REGIONS = (1, True)

  def __init__(self, output, input, weight, quantInfo, kernel, *, sumin=None, lutTable=None, groupSize=None, stride=None, pad=None, dilation=None, padValue=None, relu=None, instanceId=None, processDone=None, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(weight))
    operands.append(_get_op_result_or_value(quantInfo))
    operands.append(_get_op_result_or_value(sumin) if sumin is not None else None)
    operands.append(_get_op_result_or_value(lutTable) if lutTable is not None else None)
    _ods_context = _ods_get_default_loc_context(loc)
    if groupSize is not None: attributes["groupSize"] = (groupSize if (
        isinstance(groupSize, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(groupSize, context=_ods_context))
    attributes["kernel"] = (kernel if (
    isinstance(kernel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Hbdk_I64ArrayAttr2')) else
      _ods_ir.AttrBuilder.get('Hbdk_I64ArrayAttr2')(kernel, context=_ods_context))
    if stride is not None: attributes["stride"] = (stride if (
        isinstance(stride, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(stride, context=_ods_context))
    if pad is not None: attributes["pad"] = (pad if (
        isinstance(pad, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(pad, context=_ods_context))
    if dilation is not None: attributes["dilation"] = (dilation if (
        isinstance(dilation, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(dilation, context=_ods_context))
    if padValue is not None: attributes["padValue"] = (padValue if (
        isinstance(padValue, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(padValue, context=_ods_context))
    if relu is not None: attributes["relu"] = (relu if (
        isinstance(relu, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(relu, context=_ods_context))
    if instanceId is not None: attributes["instanceId"] = (instanceId if (
        isinstance(instanceId, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(instanceId, context=_ods_context))
    if processDone is not None: attributes["processDone"] = (processDone if (
        isinstance(processDone, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('ConvProcess')) else
          _ods_ir.AttrBuilder.get('ConvProcess')(processDone, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def weight(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0]

  @builtins.property
  def quantInfo(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range[0]

  @builtins.property
  def sumin(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def lutTable(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 4)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def groupSize(self):
    if "groupSize" not in self.operation.attributes:
      return None
    return self.operation.attributes["groupSize"]

  @groupSize.setter
  def groupSize(self, value):
    if value is not None:
      self.operation.attributes["groupSize"] = value
    elif "groupSize" in self.operation.attributes:
      del self.operation.attributes["groupSize"]

  @groupSize.deleter
  def groupSize(self):
    del self.operation.attributes["groupSize"]

  @builtins.property
  def kernel(self):
    return self.operation.attributes["kernel"]

  @kernel.setter
  def kernel(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["kernel"] = value

  @builtins.property
  def stride(self):
    return self.operation.attributes["stride"]

  @stride.setter
  def stride(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["stride"] = value

  @builtins.property
  def pad(self):
    return self.operation.attributes["pad"]

  @pad.setter
  def pad(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["pad"] = value

  @builtins.property
  def dilation(self):
    return self.operation.attributes["dilation"]

  @dilation.setter
  def dilation(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dilation"] = value

  @builtins.property
  def padValue(self):
    return self.operation.attributes["padValue"]

  @padValue.setter
  def padValue(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["padValue"] = value

  @builtins.property
  def relu(self):
    return self.operation.attributes["relu"]

  @relu.setter
  def relu(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["relu"] = value

  @builtins.property
  def instanceId(self):
    return self.operation.attributes["instanceId"]

  @instanceId.setter
  def instanceId(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["instanceId"] = value

  @builtins.property
  def processDone(self):
    return self.operation.attributes["processDone"]

  @processDone.setter
  def processDone(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["processDone"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

  @builtins.property
  def body(self):
    return self.regions[0]

def conv2d(output, input, weight, quant_info, kernel, *, sumin=None, lut_table=None, group_size=None, stride=None, pad=None, dilation=None, pad_value=None, relu=None, instance_id=None, process_done=None, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(Conv2dOp(output=output, input=input, weight=weight, quantInfo=quant_info, kernel=kernel, sumin=sumin, lutTable=lut_table, groupSize=group_size, stride=stride, pad=pad, dilation=dilation, padValue=pad_value, relu=relu, instanceId=instance_id, processDone=process_done, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class FilterOp(_ods_ir.OpView):
  OPERATION_NAME = "b25.filter"

  _ODS_REGIONS = (1, True)

  def __init__(self, filterData, data, score, mergeAxisExceptC, threshold, *, partialCount=None, partialData=None, startCoord=None, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(data))
    operands.append(_get_op_result_or_value(score))
    if partialCount is not None: operands.append(_get_op_result_or_value(partialCount))
    if partialData is not None: operands.append(_get_op_result_or_value(partialData))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["mergeAxisExceptC"] = (mergeAxisExceptC if (
    isinstance(mergeAxisExceptC, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(mergeAxisExceptC, context=_ods_context))
    attributes["threshold"] = (threshold if (
    isinstance(threshold, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(threshold, context=_ods_context))
    if startCoord is not None: attributes["startCoord"] = (startCoord if (
        isinstance(startCoord, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(startCoord, context=_ods_context))
    results.append(filterData)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def data(self):
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 2, 2, 0, 0)
    return self.operation.operands[start]

  @builtins.property
  def score(self):
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 2, 2, 1, 0)
    return self.operation.operands[start]

  @builtins.property
  def partialCount(self):
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 2, 2, 2, 0)
    return self.operation.operands[start:start + elements_per_group]

  @builtins.property
  def partialData(self):
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 2, 2, 2, 1)
    return self.operation.operands[start:start + elements_per_group]

  @builtins.property
  def mergeAxisExceptC(self):
    return self.operation.attributes["mergeAxisExceptC"]

  @mergeAxisExceptC.setter
  def mergeAxisExceptC(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mergeAxisExceptC"] = value

  @builtins.property
  def threshold(self):
    return self.operation.attributes["threshold"]

  @threshold.setter
  def threshold(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["threshold"] = value

  @builtins.property
  def startCoord(self):
    return self.operation.attributes["startCoord"]

  @startCoord.setter
  def startCoord(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["startCoord"] = value

  @builtins.property
  def filterData(self):
    return self.operation.results[0]

  @builtins.property
  def body(self):
    return self.regions[0]

def filter(filter_data, data, score, merge_axis_except_c, threshold, *, partial_count=None, partial_data=None, start_coord=None, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(FilterOp(filterData=filter_data, data=data, score=score, mergeAxisExceptC=merge_axis_except_c, threshold=threshold, partialCount=partial_count, partialData=partial_data, startCoord=start_coord, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class GenQuantInfoOp(_ods_ir.OpView):
  OPERATION_NAME = "b25.gen_quant_info"

  _ODS_REGIONS = (0, True)

  def __init__(self, encode, bias, finType, weightType, foutType, *, weight=None, suminType=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(bias))
    if weight is not None: operands.append(_get_op_result_or_value(weight))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["finType"] = (finType if (
    isinstance(finType, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_894')) else
      _ods_ir.AttrBuilder.get('anonymous_894')(finType, context=_ods_context))
    attributes["weightType"] = (weightType if (
    isinstance(weightType, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_894')) else
      _ods_ir.AttrBuilder.get('anonymous_894')(weightType, context=_ods_context))
    attributes["foutType"] = (foutType if (
    isinstance(foutType, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_894')) else
      _ods_ir.AttrBuilder.get('anonymous_894')(foutType, context=_ods_context))
    if suminType is not None: attributes["suminType"] = (suminType if (
        isinstance(suminType, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_894')) else
          _ods_ir.AttrBuilder.get('anonymous_894')(suminType, context=_ods_context))
    results.append(encode)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def bias(self):
    return self.operation.operands[0]

  @builtins.property
  def weight(self):
    return None if len(self.operation.operands) < 2 else self.operation.operands[1]

  @builtins.property
  def finType(self):
    return self.operation.attributes["finType"]

  @finType.setter
  def finType(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["finType"] = value

  @builtins.property
  def weightType(self):
    return self.operation.attributes["weightType"]

  @weightType.setter
  def weightType(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["weightType"] = value

  @builtins.property
  def foutType(self):
    return self.operation.attributes["foutType"]

  @foutType.setter
  def foutType(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["foutType"] = value

  @builtins.property
  def suminType(self):
    if "suminType" not in self.operation.attributes:
      return None
    return self.operation.attributes["suminType"]

  @suminType.setter
  def suminType(self, value):
    if value is not None:
      self.operation.attributes["suminType"] = value
    elif "suminType" in self.operation.attributes:
      del self.operation.attributes["suminType"]

  @suminType.deleter
  def suminType(self):
    del self.operation.attributes["suminType"]

  @builtins.property
  def encode(self):
    return self.operation.results[0]

def gen_quant_info(encode, bias, fin_type, weight_type, fout_type, *, weight=None, sumin_type=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(GenQuantInfoOp(encode=encode, bias=bias, finType=fin_type, weightType=weight_type, foutType=fout_type, weight=weight, suminType=sumin_type, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class LinearOp(_ods_ir.OpView):
  OPERATION_NAME = "b25.linear"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, weight, quantInfo, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(weight))
    operands.append(_get_op_result_or_value(quantInfo))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def weight(self):
    return self.operation.operands[1]

  @builtins.property
  def quantInfo(self):
    return self.operation.operands[2]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def linear(output, input, weight, quant_info, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(LinearOp(output=output, input=input, weight=weight, quantInfo=quant_info, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class LutOp(_ods_ir.OpView):
  OPERATION_NAME = "b25.lut"

  _ODS_REGIONS = (1, True)

  def __init__(self, output, input, config, *, symmetricMode=None, roundMode=None, saturate=None, mode=None, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(config))
    _ods_context = _ods_get_default_loc_context(loc)
    if symmetricMode is not None: attributes["symmetricMode"] = (symmetricMode if (
        isinstance(symmetricMode, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SymmetricModeAttr')) else
          _ods_ir.AttrBuilder.get('SymmetricModeAttr')(symmetricMode, context=_ods_context))
    if roundMode is not None: attributes["roundMode"] = (roundMode if (
        isinstance(roundMode, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('RoundModeAttr')) else
          _ods_ir.AttrBuilder.get('RoundModeAttr')(roundMode, context=_ods_context))
    if saturate is not None: attributes["saturate"] = (saturate if (
        isinstance(saturate, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(saturate, context=_ods_context))
    if mode is not None: attributes["mode"] = (mode if (
        isinstance(mode, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LutModeAttr')) else
          _ods_ir.AttrBuilder.get('LutModeAttr')(mode, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def config(self):
    return self.operation.operands[1]

  @builtins.property
  def symmetricMode(self):
    return self.operation.attributes["symmetricMode"]

  @symmetricMode.setter
  def symmetricMode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["symmetricMode"] = value

  @builtins.property
  def roundMode(self):
    return self.operation.attributes["roundMode"]

  @roundMode.setter
  def roundMode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["roundMode"] = value

  @builtins.property
  def saturate(self):
    return self.operation.attributes["saturate"]

  @saturate.setter
  def saturate(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["saturate"] = value

  @builtins.property
  def mode(self):
    return self.operation.attributes["mode"]

  @mode.setter
  def mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mode"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

  @builtins.property
  def body(self):
    return self.regions[0]

def lut(output, input, config, *, symmetric_mode=None, round_mode=None, saturate=None, mode=None, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(LutOp(output=output, input=input, config=config, symmetricMode=symmetric_mode, roundMode=round_mode, saturate=saturate, mode=mode, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class MatMulOp(_ods_ir.OpView):
  OPERATION_NAME = "b25.matmul"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, lhs, rhs, quantInfo, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    operands.append(_get_op_result_or_value(quantInfo))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def quantInfo(self):
    return self.operation.operands[2]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def matmul(output, lhs, rhs, quant_info, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(MatMulOp(output=output, lhs=lhs, rhs=rhs, quantInfo=quant_info, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class MoveHalfOp(_ods_ir.OpView):
  OPERATION_NAME = "b25.move_half"

  _ODS_REGIONS = (1, True)

  def __init__(self, output, input, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

  @builtins.property
  def body(self):
    return self.regions[0]

def move_half(output, input, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(MoveHalfOp(output=output, input=input, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class PacketOp(_ods_ir.OpView):
  OPERATION_NAME = "b25.packet"

  _ODS_REGIONS = (1, True)

  def __init__(self, output, input, mode, *, maskedValue=None, laneOffset=None, offsets=None, sizes=None, strides=None, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["mode"] = (mode if (
    isinstance(mode, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('PacketModeAttr')) else
      _ods_ir.AttrBuilder.get('PacketModeAttr')(mode, context=_ods_context))
    if maskedValue is not None: attributes["maskedValue"] = (maskedValue if (
        isinstance(maskedValue, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(maskedValue, context=_ods_context))
    if laneOffset is not None: attributes["laneOffset"] = (laneOffset if (
        isinstance(laneOffset, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(laneOffset, context=_ods_context))
    if offsets is not None: attributes["offsets"] = (offsets if (
        isinstance(offsets, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(offsets, context=_ods_context))
    if sizes is not None: attributes["sizes"] = (sizes if (
        isinstance(sizes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(sizes, context=_ods_context))
    if strides is not None: attributes["strides"] = (strides if (
        isinstance(strides, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(strides, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def mode(self):
    return self.operation.attributes["mode"]

  @mode.setter
  def mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mode"] = value

  @builtins.property
  def maskedValue(self):
    return self.operation.attributes["maskedValue"]

  @maskedValue.setter
  def maskedValue(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["maskedValue"] = value

  @builtins.property
  def laneOffset(self):
    return self.operation.attributes["laneOffset"]

  @laneOffset.setter
  def laneOffset(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["laneOffset"] = value

  @builtins.property
  def offsets(self):
    if "offsets" not in self.operation.attributes:
      return None
    return self.operation.attributes["offsets"]

  @offsets.setter
  def offsets(self, value):
    if value is not None:
      self.operation.attributes["offsets"] = value
    elif "offsets" in self.operation.attributes:
      del self.operation.attributes["offsets"]

  @offsets.deleter
  def offsets(self):
    del self.operation.attributes["offsets"]

  @builtins.property
  def sizes(self):
    if "sizes" not in self.operation.attributes:
      return None
    return self.operation.attributes["sizes"]

  @sizes.setter
  def sizes(self, value):
    if value is not None:
      self.operation.attributes["sizes"] = value
    elif "sizes" in self.operation.attributes:
      del self.operation.attributes["sizes"]

  @sizes.deleter
  def sizes(self):
    del self.operation.attributes["sizes"]

  @builtins.property
  def strides(self):
    if "strides" not in self.operation.attributes:
      return None
    return self.operation.attributes["strides"]

  @strides.setter
  def strides(self, value):
    if value is not None:
      self.operation.attributes["strides"] = value
    elif "strides" in self.operation.attributes:
      del self.operation.attributes["strides"]

  @strides.deleter
  def strides(self):
    del self.operation.attributes["strides"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

  @builtins.property
  def body(self):
    return self.regions[0]

def packet(output, input, mode, *, masked_value=None, lane_offset=None, offsets=None, sizes=None, strides=None, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(PacketOp(output=output, input=input, mode=mode, maskedValue=masked_value, laneOffset=lane_offset, offsets=offsets, sizes=sizes, strides=strides, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class Pool2dOp(_ods_ir.OpView):
  OPERATION_NAME = "b25.pool2d"

  _ODS_REGIONS = (1, True)

  def __init__(self, output, input, kernel, mode, *, buffer1=None, buffer2=None, stride=None, pad=None, qppActionTypes=None, qppActionParams=None, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    if buffer1 is not None: operands.append(_get_op_result_or_value(buffer1))
    if buffer2 is not None: operands.append(_get_op_result_or_value(buffer2))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["kernel"] = (kernel if (
    isinstance(kernel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Hbdk_I64ArrayAttr2')) else
      _ods_ir.AttrBuilder.get('Hbdk_I64ArrayAttr2')(kernel, context=_ods_context))
    attributes["mode"] = (mode if (
    isinstance(mode, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('PoolModeAttr')) else
      _ods_ir.AttrBuilder.get('PoolModeAttr')(mode, context=_ods_context))
    if stride is not None: attributes["stride"] = (stride if (
        isinstance(stride, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(stride, context=_ods_context))
    if pad is not None: attributes["pad"] = (pad if (
        isinstance(pad, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(pad, context=_ods_context))
    if qppActionTypes is not None: attributes["qppActionTypes"] = (qppActionTypes if (
        isinstance(qppActionTypes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Hbdk_QppActionAttr')) else
          _ods_ir.AttrBuilder.get('Hbdk_QppActionAttr')(qppActionTypes, context=_ods_context))
    if qppActionParams is not None: attributes["qppActionParams"] = (qppActionParams if (
        isinstance(qppActionParams, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(qppActionParams, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 1, 2, 0, 0)
    return self.operation.operands[start]

  @builtins.property
  def buffer1(self):
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 1, 2, 1, 0)
    return self.operation.operands[start:start + elements_per_group]

  @builtins.property
  def buffer2(self):
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 1, 2, 1, 1)
    return self.operation.operands[start:start + elements_per_group]

  @builtins.property
  def kernel(self):
    return self.operation.attributes["kernel"]

  @kernel.setter
  def kernel(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["kernel"] = value

  @builtins.property
  def mode(self):
    return self.operation.attributes["mode"]

  @mode.setter
  def mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mode"] = value

  @builtins.property
  def stride(self):
    return self.operation.attributes["stride"]

  @stride.setter
  def stride(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["stride"] = value

  @builtins.property
  def pad(self):
    return self.operation.attributes["pad"]

  @pad.setter
  def pad(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["pad"] = value

  @builtins.property
  def qppActionTypes(self):
    return self.operation.attributes["qppActionTypes"]

  @qppActionTypes.setter
  def qppActionTypes(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["qppActionTypes"] = value

  @builtins.property
  def qppActionParams(self):
    return self.operation.attributes["qppActionParams"]

  @qppActionParams.setter
  def qppActionParams(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["qppActionParams"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

  @builtins.property
  def body(self):
    return self.regions[0]

def pool2d(output, input, kernel, mode, *, buffer1=None, buffer2=None, stride=None, pad=None, qpp_action_types=None, qpp_action_params=None, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(Pool2dOp(output=output, input=input, kernel=kernel, mode=mode, buffer1=buffer1, buffer2=buffer2, stride=stride, pad=pad, qppActionTypes=qpp_action_types, qppActionParams=qpp_action_params, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class ReduceOp(_ods_ir.OpView):
  OPERATION_NAME = "b25.reduce"

  _ODS_REGIONS = (1, True)

  def __init__(self, output, input, mode, dims, keepDim, *, partialSum=None, qppActionTypes=None, qppActionParams=None, offsetOnReducedAxis=None, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    if partialSum is not None: operands.append(_get_op_result_or_value(partialSum))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["mode"] = (mode if (
    isinstance(mode, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ReduceModeAttr')) else
      _ods_ir.AttrBuilder.get('ReduceModeAttr')(mode, context=_ods_context))
    attributes["dims"] = (dims if (
    isinstance(dims, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(dims, context=_ods_context))
    attributes["keepDim"] = (keepDim if (
    isinstance(keepDim, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(keepDim, context=_ods_context))
    if qppActionTypes is not None: attributes["qppActionTypes"] = (qppActionTypes if (
        isinstance(qppActionTypes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Hbdk_QppActionAttr')) else
          _ods_ir.AttrBuilder.get('Hbdk_QppActionAttr')(qppActionTypes, context=_ods_context))
    if qppActionParams is not None: attributes["qppActionParams"] = (qppActionParams if (
        isinstance(qppActionParams, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(qppActionParams, context=_ods_context))
    if offsetOnReducedAxis is not None: attributes["offsetOnReducedAxis"] = (offsetOnReducedAxis if (
        isinstance(offsetOnReducedAxis, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(offsetOnReducedAxis, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def partialSum(self):
    return None if len(self.operation.operands) < 2 else self.operation.operands[1]

  @builtins.property
  def mode(self):
    return self.operation.attributes["mode"]

  @mode.setter
  def mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mode"] = value

  @builtins.property
  def dims(self):
    return self.operation.attributes["dims"]

  @dims.setter
  def dims(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dims"] = value

  @builtins.property
  def keepDim(self):
    return self.operation.attributes["keepDim"]

  @keepDim.setter
  def keepDim(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["keepDim"] = value

  @builtins.property
  def qppActionTypes(self):
    return self.operation.attributes["qppActionTypes"]

  @qppActionTypes.setter
  def qppActionTypes(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["qppActionTypes"] = value

  @builtins.property
  def qppActionParams(self):
    return self.operation.attributes["qppActionParams"]

  @qppActionParams.setter
  def qppActionParams(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["qppActionParams"] = value

  @builtins.property
  def offsetOnReducedAxis(self):
    return self.operation.attributes["offsetOnReducedAxis"]

  @offsetOnReducedAxis.setter
  def offsetOnReducedAxis(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["offsetOnReducedAxis"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

  @builtins.property
  def body(self):
    return self.regions[0]

def reduce(output, input, mode, dims, keep_dim, *, partial_sum=None, qpp_action_types=None, qpp_action_params=None, offset_on_reduced_axis=None, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(ReduceOp(output=output, input=input, mode=mode, dims=dims, keepDim=keep_dim, partialSum=partial_sum, qppActionTypes=qpp_action_types, qppActionParams=qpp_action_params, offsetOnReducedAxis=offset_on_reduced_axis, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class Resize2dOp(_ods_ir.OpView):
  OPERATION_NAME = "b25.resize2d"

  _ODS_REGIONS = (1, True)

  def __init__(self, output, input, step, *, initialOffset=None, mode=None, expansionMode=None, roundMode=None, padValue=None, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["step"] = (step if (
    isinstance(step, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Hbdk_I64ArrayAttr2')) else
      _ods_ir.AttrBuilder.get('Hbdk_I64ArrayAttr2')(step, context=_ods_context))
    if initialOffset is not None: attributes["initialOffset"] = (initialOffset if (
        isinstance(initialOffset, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(initialOffset, context=_ods_context))
    if mode is not None: attributes["mode"] = (mode if (
        isinstance(mode, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('InterpolationModeAttr')) else
          _ods_ir.AttrBuilder.get('InterpolationModeAttr')(mode, context=_ods_context))
    if expansionMode is not None: attributes["expansionMode"] = (expansionMode if (
        isinstance(expansionMode, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('ExpansionModeAttr')) else
          _ods_ir.AttrBuilder.get('ExpansionModeAttr')(expansionMode, context=_ods_context))
    if roundMode is not None: attributes["roundMode"] = (roundMode if (
        isinstance(roundMode, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('RoundModeAttr')) else
          _ods_ir.AttrBuilder.get('RoundModeAttr')(roundMode, context=_ods_context))
    if padValue is not None: attributes["padValue"] = (padValue if (
        isinstance(padValue, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(padValue, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def step(self):
    return self.operation.attributes["step"]

  @step.setter
  def step(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["step"] = value

  @builtins.property
  def initialOffset(self):
    return self.operation.attributes["initialOffset"]

  @initialOffset.setter
  def initialOffset(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["initialOffset"] = value

  @builtins.property
  def mode(self):
    return self.operation.attributes["mode"]

  @mode.setter
  def mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mode"] = value

  @builtins.property
  def expansionMode(self):
    return self.operation.attributes["expansionMode"]

  @expansionMode.setter
  def expansionMode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["expansionMode"] = value

  @builtins.property
  def roundMode(self):
    return self.operation.attributes["roundMode"]

  @roundMode.setter
  def roundMode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["roundMode"] = value

  @builtins.property
  def padValue(self):
    if "padValue" not in self.operation.attributes:
      return None
    return self.operation.attributes["padValue"]

  @padValue.setter
  def padValue(self, value):
    if value is not None:
      self.operation.attributes["padValue"] = value
    elif "padValue" in self.operation.attributes:
      del self.operation.attributes["padValue"]

  @padValue.deleter
  def padValue(self):
    del self.operation.attributes["padValue"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

  @builtins.property
  def body(self):
    return self.regions[0]

def resize2d(output, input, step, *, initial_offset=None, mode=None, expansion_mode=None, round_mode=None, pad_value=None, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(Resize2dOp(output=output, input=input, step=step, initialOffset=initial_offset, mode=mode, expansionMode=expansion_mode, roundMode=round_mode, padValue=pad_value, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class RleOp(_ods_ir.OpView):
  OPERATION_NAME = "b25.rle"

  _ODS_REGIONS = (1, True)

  def __init__(self, encodeCount, encodeData, input, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(encodeCount)
    results.append(encodeData)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def encodeCount(self):
    return self.operation.results[0]

  @builtins.property
  def encodeData(self):
    return self.operation.results[1]

  @builtins.property
  def body(self):
    return self.regions[0]

def rle(encode_count, encode_data, input, *, extra=None, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return _get_op_result_or_op_results(RleOp(encodeCount=encode_count, encodeData=encode_data, input=input, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class ShareFeatDoubleConv2dOp(_ods_ir.OpView):
  OPERATION_NAME = "b25.share_feat_double_conv2d"

  _ODS_OPERAND_SEGMENTS = [1,1,1,1,1,0,0,0,]

  _ODS_REGIONS = (1, True)

  def __init__(self, output0, output1, input, weight0, weight1, quantInfo0, quantInfo1, kernel, *, sumin0=None, sumin1=None, lutTable=None, groupSize=None, stride=None, pad=None, padValue=None, relu=None, processDone=None, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(weight0))
    operands.append(_get_op_result_or_value(weight1))
    operands.append(_get_op_result_or_value(quantInfo0))
    operands.append(_get_op_result_or_value(quantInfo1))
    operands.append(_get_op_result_or_value(sumin0) if sumin0 is not None else None)
    operands.append(_get_op_result_or_value(sumin1) if sumin1 is not None else None)
    operands.append(_get_op_result_or_value(lutTable) if lutTable is not None else None)
    _ods_context = _ods_get_default_loc_context(loc)
    if groupSize is not None: attributes["groupSize"] = (groupSize if (
        isinstance(groupSize, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(groupSize, context=_ods_context))
    attributes["kernel"] = (kernel if (
    isinstance(kernel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Hbdk_I64ArrayAttr2')) else
      _ods_ir.AttrBuilder.get('Hbdk_I64ArrayAttr2')(kernel, context=_ods_context))
    if stride is not None: attributes["stride"] = (stride if (
        isinstance(stride, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(stride, context=_ods_context))
    if pad is not None: attributes["pad"] = (pad if (
        isinstance(pad, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(pad, context=_ods_context))
    if padValue is not None: attributes["padValue"] = (padValue if (
        isinstance(padValue, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(padValue, context=_ods_context))
    if relu is not None: attributes["relu"] = (relu if (
        isinstance(relu, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(relu, context=_ods_context))
    if processDone is not None: attributes["processDone"] = (processDone if (
        isinstance(processDone, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('ConvProcess')) else
          _ods_ir.AttrBuilder.get('ConvProcess')(processDone, context=_ods_context))
    results.append(output0)
    results.append(output1)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def weight0(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0]

  @builtins.property
  def weight1(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range[0]

  @builtins.property
  def quantInfo0(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range[0]

  @builtins.property
  def quantInfo1(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 4)
    return operand_range[0]

  @builtins.property
  def sumin0(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 5)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def sumin1(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 6)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def lutTable(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 7)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def groupSize(self):
    if "groupSize" not in self.operation.attributes:
      return None
    return self.operation.attributes["groupSize"]

  @groupSize.setter
  def groupSize(self, value):
    if value is not None:
      self.operation.attributes["groupSize"] = value
    elif "groupSize" in self.operation.attributes:
      del self.operation.attributes["groupSize"]

  @groupSize.deleter
  def groupSize(self):
    del self.operation.attributes["groupSize"]

  @builtins.property
  def kernel(self):
    return self.operation.attributes["kernel"]

  @kernel.setter
  def kernel(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["kernel"] = value

  @builtins.property
  def stride(self):
    return self.operation.attributes["stride"]

  @stride.setter
  def stride(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["stride"] = value

  @builtins.property
  def pad(self):
    return self.operation.attributes["pad"]

  @pad.setter
  def pad(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["pad"] = value

  @builtins.property
  def padValue(self):
    return self.operation.attributes["padValue"]

  @padValue.setter
  def padValue(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["padValue"] = value

  @builtins.property
  def relu(self):
    return self.operation.attributes["relu"]

  @relu.setter
  def relu(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["relu"] = value

  @builtins.property
  def processDone(self):
    return self.operation.attributes["processDone"]

  @processDone.setter
  def processDone(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["processDone"] = value

  @builtins.property
  def output0(self):
    return self.operation.results[0]

  @builtins.property
  def output1(self):
    return self.operation.results[1]

  @builtins.property
  def body(self):
    return self.regions[0]

def share_feat_double_conv2d(output0, output1, input, weight0, weight1, quant_info0, quant_info1, kernel, *, sumin0=None, sumin1=None, lut_table=None, group_size=None, stride=None, pad=None, pad_value=None, relu=None, process_done=None, extra=None, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return _get_op_result_or_op_results(ShareFeatDoubleConv2dOp(output0=output0, output1=output1, input=input, weight0=weight0, weight1=weight1, quantInfo0=quant_info0, quantInfo1=quant_info1, kernel=kernel, sumin0=sumin0, sumin1=sumin1, lutTable=lut_table, groupSize=group_size, stride=stride, pad=pad, padValue=pad_value, relu=relu, processDone=process_done, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class ShareWeightDoubleConv2dOp(_ods_ir.OpView):
  OPERATION_NAME = "b25.share_weight_double_conv2d"

  _ODS_OPERAND_SEGMENTS = [1,1,1,1,0,0,0,]

  _ODS_REGIONS = (1, True)

  def __init__(self, output0, output1, input0, input1, weight, quantInfo, kernel, *, sumin0=None, sumin1=None, lutTable=None, groupSize=None, stride=None, pad=None, padValue=None, relu=None, processDone=None, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input0))
    operands.append(_get_op_result_or_value(input1))
    operands.append(_get_op_result_or_value(weight))
    operands.append(_get_op_result_or_value(quantInfo))
    operands.append(_get_op_result_or_value(sumin0) if sumin0 is not None else None)
    operands.append(_get_op_result_or_value(sumin1) if sumin1 is not None else None)
    operands.append(_get_op_result_or_value(lutTable) if lutTable is not None else None)
    _ods_context = _ods_get_default_loc_context(loc)
    if groupSize is not None: attributes["groupSize"] = (groupSize if (
        isinstance(groupSize, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(groupSize, context=_ods_context))
    attributes["kernel"] = (kernel if (
    isinstance(kernel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Hbdk_I64ArrayAttr2')) else
      _ods_ir.AttrBuilder.get('Hbdk_I64ArrayAttr2')(kernel, context=_ods_context))
    if stride is not None: attributes["stride"] = (stride if (
        isinstance(stride, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(stride, context=_ods_context))
    if pad is not None: attributes["pad"] = (pad if (
        isinstance(pad, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(pad, context=_ods_context))
    if padValue is not None: attributes["padValue"] = (padValue if (
        isinstance(padValue, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(padValue, context=_ods_context))
    if relu is not None: attributes["relu"] = (relu if (
        isinstance(relu, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(relu, context=_ods_context))
    if processDone is not None: attributes["processDone"] = (processDone if (
        isinstance(processDone, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('ConvProcess')) else
          _ods_ir.AttrBuilder.get('ConvProcess')(processDone, context=_ods_context))
    results.append(output0)
    results.append(output1)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input0(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def input1(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0]

  @builtins.property
  def weight(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range[0]

  @builtins.property
  def quantInfo(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range[0]

  @builtins.property
  def sumin0(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 4)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def sumin1(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 5)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def lutTable(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 6)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def groupSize(self):
    if "groupSize" not in self.operation.attributes:
      return None
    return self.operation.attributes["groupSize"]

  @groupSize.setter
  def groupSize(self, value):
    if value is not None:
      self.operation.attributes["groupSize"] = value
    elif "groupSize" in self.operation.attributes:
      del self.operation.attributes["groupSize"]

  @groupSize.deleter
  def groupSize(self):
    del self.operation.attributes["groupSize"]

  @builtins.property
  def kernel(self):
    return self.operation.attributes["kernel"]

  @kernel.setter
  def kernel(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["kernel"] = value

  @builtins.property
  def stride(self):
    return self.operation.attributes["stride"]

  @stride.setter
  def stride(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["stride"] = value

  @builtins.property
  def pad(self):
    return self.operation.attributes["pad"]

  @pad.setter
  def pad(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["pad"] = value

  @builtins.property
  def padValue(self):
    return self.operation.attributes["padValue"]

  @padValue.setter
  def padValue(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["padValue"] = value

  @builtins.property
  def relu(self):
    return self.operation.attributes["relu"]

  @relu.setter
  def relu(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["relu"] = value

  @builtins.property
  def processDone(self):
    return self.operation.attributes["processDone"]

  @processDone.setter
  def processDone(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["processDone"] = value

  @builtins.property
  def output0(self):
    return self.operation.results[0]

  @builtins.property
  def output1(self):
    return self.operation.results[1]

  @builtins.property
  def body(self):
    return self.regions[0]

def share_weight_double_conv2d(output0, output1, input0, input1, weight, quant_info, kernel, *, sumin0=None, sumin1=None, lut_table=None, group_size=None, stride=None, pad=None, pad_value=None, relu=None, process_done=None, extra=None, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return _get_op_result_or_op_results(ShareWeightDoubleConv2dOp(output0=output0, output1=output1, input0=input0, input1=input1, weight=weight, quantInfo=quant_info, kernel=kernel, sumin0=sumin0, sumin1=sumin1, lutTable=lut_table, groupSize=group_size, stride=stride, pad=pad, padValue=pad_value, relu=relu, processDone=process_done, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class TernaryEltwiseOp(_ods_ir.OpView):
  OPERATION_NAME = "b25.ternary_eltwise"

  _ODS_REGIONS = (1, True)

  def __init__(self, output, lhs, rhs, condition, mode, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    operands.append(_get_op_result_or_value(condition))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["mode"] = (mode if (
    isinstance(mode, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('EltwiseModeAttr')) else
      _ods_ir.AttrBuilder.get('EltwiseModeAttr')(mode, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def condition(self):
    return self.operation.operands[2]

  @builtins.property
  def mode(self):
    return self.operation.attributes["mode"]

  @mode.setter
  def mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mode"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

  @builtins.property
  def body(self):
    return self.regions[0]

def ternary_eltwise(output, lhs, rhs, condition, mode, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(TernaryEltwiseOp(output=output, lhs=lhs, rhs=rhs, condition=condition, mode=mode, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class TransLayoutOp(_ods_ir.OpView):
  OPERATION_NAME = "b25.trans_layout"

  _ODS_REGIONS = (1, True)

  def __init__(self, output, input, mode, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["mode"] = (mode if (
    isinstance(mode, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TransLayoutModeAttr')) else
      _ods_ir.AttrBuilder.get('TransLayoutModeAttr')(mode, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def mode(self):
    return self.operation.attributes["mode"]

  @mode.setter
  def mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mode"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

  @builtins.property
  def body(self):
    return self.regions[0]

def trans_layout(output, input, mode, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(TransLayoutOp(output=output, input=input, mode=mode, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class UnaryEltwiseOp(_ods_ir.OpView):
  OPERATION_NAME = "b25.unary_eltwise"

  _ODS_REGIONS = (1, True)

  def __init__(self, output, input, mode, *, quant_info=None, roundMode=None, saturate=None, perTensorQuant=None, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    if quant_info is not None: operands.append(_get_op_result_or_value(quant_info))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["mode"] = (mode if (
    isinstance(mode, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('EltwiseModeAttr')) else
      _ods_ir.AttrBuilder.get('EltwiseModeAttr')(mode, context=_ods_context))
    if roundMode is not None: attributes["roundMode"] = (roundMode if (
        isinstance(roundMode, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('RoundModeAttr')) else
          _ods_ir.AttrBuilder.get('RoundModeAttr')(roundMode, context=_ods_context))
    if saturate is not None: attributes["saturate"] = (saturate if (
        isinstance(saturate, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(saturate, context=_ods_context))
    if perTensorQuant is not None: attributes["perTensorQuant"] = (perTensorQuant if (
        isinstance(perTensorQuant, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(perTensorQuant, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def quant_info(self):
    return None if len(self.operation.operands) < 2 else self.operation.operands[1]

  @builtins.property
  def mode(self):
    return self.operation.attributes["mode"]

  @mode.setter
  def mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mode"] = value

  @builtins.property
  def roundMode(self):
    return self.operation.attributes["roundMode"]

  @roundMode.setter
  def roundMode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["roundMode"] = value

  @builtins.property
  def saturate(self):
    return self.operation.attributes["saturate"]

  @saturate.setter
  def saturate(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["saturate"] = value

  @builtins.property
  def perTensorQuant(self):
    return self.operation.attributes["perTensorQuant"]

  @perTensorQuant.setter
  def perTensorQuant(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["perTensorQuant"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

  @builtins.property
  def body(self):
    return self.regions[0]

def unary_eltwise(output, input, mode, *, quant_info=None, round_mode=None, saturate=None, per_tensor_quant=None, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(UnaryEltwiseOp(output=output, input=input, mode=mode, quant_info=quant_info, roundMode=round_mode, saturate=saturate, perTensorQuant=per_tensor_quant, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class WarpOp(_ods_ir.OpView):
  OPERATION_NAME = "b25.warp"

  _ODS_REGIONS = (1, True)

  def __init__(self, output, input, mv, *, initialOffset=None, mode=None, expansionMode=None, roundMode=None, mvYX=None, mvMode=None, shiftBits=None, padValue=None, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(mv))
    _ods_context = _ods_get_default_loc_context(loc)
    if initialOffset is not None: attributes["initialOffset"] = (initialOffset if (
        isinstance(initialOffset, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(initialOffset, context=_ods_context))
    if mode is not None: attributes["mode"] = (mode if (
        isinstance(mode, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('InterpolationModeAttr')) else
          _ods_ir.AttrBuilder.get('InterpolationModeAttr')(mode, context=_ods_context))
    if expansionMode is not None: attributes["expansionMode"] = (expansionMode if (
        isinstance(expansionMode, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('ExpansionModeAttr')) else
          _ods_ir.AttrBuilder.get('ExpansionModeAttr')(expansionMode, context=_ods_context))
    if roundMode is not None: attributes["roundMode"] = (roundMode if (
        isinstance(roundMode, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('RoundModeAttr')) else
          _ods_ir.AttrBuilder.get('RoundModeAttr')(roundMode, context=_ods_context))
    if mvYX is not None: attributes["mvYX"] = (mvYX if (
        isinstance(mvYX, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(mvYX, context=_ods_context))
    if mvMode is not None: attributes["mvMode"] = (mvMode if (
        isinstance(mvMode, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MotionVectorModeAttr')) else
          _ods_ir.AttrBuilder.get('MotionVectorModeAttr')(mvMode, context=_ods_context))
    if shiftBits is not None: attributes["shiftBits"] = (shiftBits if (
        isinstance(shiftBits, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(shiftBits, context=_ods_context))
    if padValue is not None: attributes["padValue"] = (padValue if (
        isinstance(padValue, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_951')) else
          _ods_ir.AttrBuilder.get('anonymous_951')(padValue, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def mv(self):
    return self.operation.operands[1]

  @builtins.property
  def initialOffset(self):
    return self.operation.attributes["initialOffset"]

  @initialOffset.setter
  def initialOffset(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["initialOffset"] = value

  @builtins.property
  def mode(self):
    return self.operation.attributes["mode"]

  @mode.setter
  def mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mode"] = value

  @builtins.property
  def expansionMode(self):
    return self.operation.attributes["expansionMode"]

  @expansionMode.setter
  def expansionMode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["expansionMode"] = value

  @builtins.property
  def roundMode(self):
    return self.operation.attributes["roundMode"]

  @roundMode.setter
  def roundMode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["roundMode"] = value

  @builtins.property
  def mvYX(self):
    return self.operation.attributes["mvYX"]

  @mvYX.setter
  def mvYX(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mvYX"] = value

  @builtins.property
  def mvMode(self):
    return self.operation.attributes["mvMode"]

  @mvMode.setter
  def mvMode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mvMode"] = value

  @builtins.property
  def shiftBits(self):
    return self.operation.attributes["shiftBits"]

  @shiftBits.setter
  def shiftBits(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["shiftBits"] = value

  @builtins.property
  def padValue(self):
    if "padValue" not in self.operation.attributes:
      return None
    return self.operation.attributes["padValue"]

  @padValue.setter
  def padValue(self, value):
    if value is not None:
      self.operation.attributes["padValue"] = value
    elif "padValue" in self.operation.attributes:
      del self.operation.attributes["padValue"]

  @padValue.deleter
  def padValue(self):
    del self.operation.attributes["padValue"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

  @builtins.property
  def body(self):
    return self.regions[0]

def warp(output, input, mv, *, initial_offset=None, mode=None, expansion_mode=None, round_mode=None, mv_yx=None, mv_mode=None, shift_bits=None, pad_value=None, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(WarpOp(output=output, input=input, mv=mv, initialOffset=initial_offset, mode=mode, expansionMode=expansion_mode, roundMode=round_mode, mvYX=mv_yx, mvMode=mv_mode, shiftBits=shift_bits, padValue=pad_value, extra=extra, loc=loc, ip=ip))
