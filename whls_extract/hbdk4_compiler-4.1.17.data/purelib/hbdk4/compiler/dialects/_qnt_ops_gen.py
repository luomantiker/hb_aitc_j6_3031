
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import (
    equally_sized_accessor as _ods_equally_sized_accessor,
    get_default_loc_context as _ods_get_default_loc_context,
    get_op_result_or_op_results as _get_op_result_or_op_results,
    get_op_result_or_value as _get_op_result_or_value,
    get_op_results_or_values as _get_op_results_or_values,
    segmented_accessor as _ods_segmented_accessor,
)
_ods_ir = _ods_cext.ir

import builtins
from typing import Sequence as _Sequence, Union as _Union


@_ods_cext.register_dialect
class _Dialect(_ods_ir.Dialect):
  DIALECT_NAMESPACE = "qnt"

@_ods_cext.register_operation(_Dialect)
class BarrierOp(_ods_ir.OpView):
  OPERATION_NAME = "qnt.barrier"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def barrier(output, input, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(BarrierOp(output=output, input=input, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class ConstFakeQuantOp(_ods_ir.OpView):
  OPERATION_NAME = "qnt.const_fake_quant"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, min, max, bits, *, narrowRange=None, illegal=None, axis=None, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["min"] = (min if (
    isinstance(min, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('F64ArrayAttr')(min, context=_ods_context))
    attributes["max"] = (max if (
    isinstance(max, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('F64ArrayAttr')(max, context=_ods_context))
    attributes["bits"] = (bits if (
    isinstance(bits, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(bits, context=_ods_context))
    if narrowRange is not None: attributes["narrowRange"] = (narrowRange if (
        isinstance(narrowRange, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(narrowRange, context=_ods_context))
    if illegal is not None: attributes["illegal"] = (illegal if (
        isinstance(illegal, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(illegal, context=_ods_context))
    if axis is not None: attributes["axis"] = (axis if (
        isinstance(axis, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(axis, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def min(self):
    return self.operation.attributes["min"]

  @min.setter
  def min(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["min"] = value

  @builtins.property
  def max(self):
    return self.operation.attributes["max"]

  @max.setter
  def max(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["max"] = value

  @builtins.property
  def bits(self):
    return self.operation.attributes["bits"]

  @bits.setter
  def bits(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["bits"] = value

  @builtins.property
  def narrowRange(self):
    return self.operation.attributes["narrowRange"]

  @narrowRange.setter
  def narrowRange(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["narrowRange"] = value

  @builtins.property
  def illegal(self):
    return self.operation.attributes["illegal"]

  @illegal.setter
  def illegal(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["illegal"] = value

  @builtins.property
  def axis(self):
    if "axis" not in self.operation.attributes:
      return None
    return self.operation.attributes["axis"]

  @axis.setter
  def axis(self, value):
    if value is not None:
      self.operation.attributes["axis"] = value
    elif "axis" in self.operation.attributes:
      del self.operation.attributes["axis"]

  @axis.deleter
  def axis(self):
    del self.operation.attributes["axis"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def const_fake_quant(output, input, min, max, bits, *, narrow_range=None, illegal=None, axis=None, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(ConstFakeQuantOp(output=output, input=input, min=min, max=max, bits=bits, narrowRange=narrow_range, illegal=illegal, axis=axis, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class DequantizeCastOp(_ods_ir.OpView):
  OPERATION_NAME = "qnt.dcast"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def dcast(output, input, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(DequantizeCastOp(output=output, input=input, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class DequantizeOp(_ods_ir.OpView):
  OPERATION_NAME = "qnt.dequantize"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, scales, zeros, *, axis=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["scales"] = (scales if (
    isinstance(scales, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('F64ArrayAttr')(scales, context=_ods_context))
    attributes["zeros"] = (zeros if (
    isinstance(zeros, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(zeros, context=_ods_context))
    if axis is not None: attributes["axis"] = (axis if (
        isinstance(axis, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(axis, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def scales(self):
    return self.operation.attributes["scales"]

  @scales.setter
  def scales(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scales"] = value

  @builtins.property
  def zeros(self):
    return self.operation.attributes["zeros"]

  @zeros.setter
  def zeros(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["zeros"] = value

  @builtins.property
  def axis(self):
    if "axis" not in self.operation.attributes:
      return None
    return self.operation.attributes["axis"]

  @axis.setter
  def axis(self, value):
    if value is not None:
      self.operation.attributes["axis"] = value
    elif "axis" in self.operation.attributes:
      del self.operation.attributes["axis"]

  @axis.deleter
  def axis(self):
    del self.operation.attributes["axis"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def dequantize(output, input, scales, zeros, *, axis=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(DequantizeOp(output=output, input=input, scales=scales, zeros=zeros, axis=axis, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class DynamicDequantizeOp(_ods_ir.OpView):
  OPERATION_NAME = "qnt.dynamic_dequantize"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, scales, *, symmetric=None, axis=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(scales))
    _ods_context = _ods_get_default_loc_context(loc)
    if symmetric is not None: attributes["symmetric"] = (symmetric if (
        isinstance(symmetric, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(symmetric, context=_ods_context))
    if axis is not None: attributes["axis"] = (axis if (
        isinstance(axis, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(axis, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def scales(self):
    return self.operation.operands[1]

  @builtins.property
  def symmetric(self):
    return self.operation.attributes["symmetric"]

  @symmetric.setter
  def symmetric(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["symmetric"] = value

  @builtins.property
  def axis(self):
    if "axis" not in self.operation.attributes:
      return None
    return self.operation.attributes["axis"]

  @axis.setter
  def axis(self, value):
    if value is not None:
      self.operation.attributes["axis"] = value
    elif "axis" in self.operation.attributes:
      del self.operation.attributes["axis"]

  @axis.deleter
  def axis(self):
    del self.operation.attributes["axis"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def dynamic_dequantize(output, input, scales, *, symmetric=None, axis=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(DynamicDequantizeOp(output=output, input=input, scales=scales, symmetric=symmetric, axis=axis, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class DynamicQuantizeOp(_ods_ir.OpView):
  OPERATION_NAME = "qnt.dynamic_quantize"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, scales, input, *, bitwidth=None, symmetric=None, axis=None, blockSize=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    if bitwidth is not None: attributes["bitwidth"] = (bitwidth if (
        isinstance(bitwidth, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(bitwidth, context=_ods_context))
    if symmetric is not None: attributes["symmetric"] = (symmetric if (
        isinstance(symmetric, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(symmetric, context=_ods_context))
    if axis is not None: attributes["axis"] = (axis if (
        isinstance(axis, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(axis, context=_ods_context))
    if blockSize is not None: attributes["blockSize"] = (blockSize if (
        isinstance(blockSize, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(blockSize, context=_ods_context))
    results.append(output)
    results.append(scales)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def bitwidth(self):
    return self.operation.attributes["bitwidth"]

  @bitwidth.setter
  def bitwidth(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["bitwidth"] = value

  @builtins.property
  def symmetric(self):
    return self.operation.attributes["symmetric"]

  @symmetric.setter
  def symmetric(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["symmetric"] = value

  @builtins.property
  def axis(self):
    if "axis" not in self.operation.attributes:
      return None
    return self.operation.attributes["axis"]

  @axis.setter
  def axis(self, value):
    if value is not None:
      self.operation.attributes["axis"] = value
    elif "axis" in self.operation.attributes:
      del self.operation.attributes["axis"]

  @axis.deleter
  def axis(self):
    del self.operation.attributes["axis"]

  @builtins.property
  def blockSize(self):
    if "blockSize" not in self.operation.attributes:
      return None
    return self.operation.attributes["blockSize"]

  @blockSize.setter
  def blockSize(self, value):
    if value is not None:
      self.operation.attributes["blockSize"] = value
    elif "blockSize" in self.operation.attributes:
      del self.operation.attributes["blockSize"]

  @blockSize.deleter
  def blockSize(self):
    del self.operation.attributes["blockSize"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

  @builtins.property
  def scales(self):
    return self.operation.results[1]

def dynamic_quantize(output, scales, input, *, bitwidth=None, symmetric=None, axis=None, block_size=None, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return _get_op_result_or_op_results(DynamicQuantizeOp(output=output, scales=scales, input=input, bitwidth=bitwidth, symmetric=symmetric, axis=axis, blockSize=block_size, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class FuseDynamicDequantizeOp(_ods_ir.OpView):
  OPERATION_NAME = "qnt.fused_dynamic_dequantize"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, quantInput, inputScale, weightScale, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(quantInput))
    operands.append(_get_op_result_or_value(inputScale))
    operands.append(_get_op_result_or_value(weightScale))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def quantInput(self):
    return self.operation.operands[0]

  @builtins.property
  def inputScale(self):
    return self.operation.operands[1]

  @builtins.property
  def weightScale(self):
    return self.operation.operands[2]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def fused_dynamic_dequantize(output, quant_input, input_scale, weight_scale, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(FuseDynamicDequantizeOp(output=output, quantInput=quant_input, inputScale=input_scale, weightScale=weight_scale, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class QuantizeCastOp(_ods_ir.OpView):
  OPERATION_NAME = "qnt.qcast"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, extra=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def qcast(output, input, *, extra=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(QuantizeCastOp(output=output, input=input, extra=extra, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class QuantizeOp(_ods_ir.OpView):
  OPERATION_NAME = "qnt.quantize"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, scales, zeros, *, narrowRange=None, axis=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["scales"] = (scales if (
    isinstance(scales, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('F64ArrayAttr')(scales, context=_ods_context))
    attributes["zeros"] = (zeros if (
    isinstance(zeros, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(zeros, context=_ods_context))
    if narrowRange is not None: attributes["narrowRange"] = (narrowRange if (
        isinstance(narrowRange, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(narrowRange, context=_ods_context))
    if axis is not None: attributes["axis"] = (axis if (
        isinstance(axis, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(axis, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def scales(self):
    return self.operation.attributes["scales"]

  @scales.setter
  def scales(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scales"] = value

  @builtins.property
  def zeros(self):
    return self.operation.attributes["zeros"]

  @zeros.setter
  def zeros(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["zeros"] = value

  @builtins.property
  def narrowRange(self):
    return self.operation.attributes["narrowRange"]

  @narrowRange.setter
  def narrowRange(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["narrowRange"] = value

  @builtins.property
  def axis(self):
    if "axis" not in self.operation.attributes:
      return None
    return self.operation.attributes["axis"]

  @axis.setter
  def axis(self, value):
    if value is not None:
      self.operation.attributes["axis"] = value
    elif "axis" in self.operation.attributes:
      del self.operation.attributes["axis"]

  @axis.deleter
  def axis(self):
    del self.operation.attributes["axis"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def quantize(output, input, scales, zeros, *, narrow_range=None, axis=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(QuantizeOp(output=output, input=input, scales=scales, zeros=zeros, narrowRange=narrow_range, axis=axis, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class RequantizeCastOp(_ods_ir.OpView):
  OPERATION_NAME = "qnt.rcast"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def rcast(output, input, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(RequantizeCastOp(output=output, input=input, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class StorageCastOp(_ods_ir.OpView):
  OPERATION_NAME = "qnt.scast"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def scast(output, input, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(StorageCastOp(output=output, input=input, loc=loc, ip=ip))
